---
title: 瞎扯最大子矩阵
mathjax: true
categories: []
abbrlink: 57973
date: 2019-08-30 18:13:21
updated: 2019-08-30 18:13:21
tags:
keywords:
---

**摘要**

本文所研究的是一类序列上的“最大子矩阵”问题（其实就是瞎扯）。

<!--more-->

# 序列最大子矩阵

给出一个非负整数序列 $\left\langle a_i \right\rangle_{i=1}^n$，并定义 $S(l,r)$ 
$$
S(l,r)=\begin{cases}
(r-l+1)\cdot \min_{i=l}^r a_i& l\le r\\
0 & l>r
\end{cases}
$$
则最大化 $S(l,r)$ 则被称为是该序列的一个最大子矩阵。

![sample](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/07/18/221623.jpeg)

## 单调栈

这个问题可以使用单调栈解决。维护一个元素单调递增的栈，每次插入元素，在弹栈的时侯更新答案。插入完之后，一个一个把栈弹空并更新答案。具体的算法过程自行左转。

时间复杂度 $O(n)$。

## 笛卡尔树

具体见[博客-笛卡尔树](/2019/07/18/56465/)。

时间复杂度 $O(n)$。

# 带修改序列最大子矩阵

具体的问题见我出的题目[最大子蒟阵](http://www.zhengruioi.com/contest/353/problem/870)。简化题意就是支持区间覆盖，区间翻转，求全局最大子矩阵。操作中涉及的权值以及初始时的权值是随机的。

基于不带修改的问题的笛卡尔树做法，想到使用 Treap 解决（Treap 是笛卡尔树）。每个结点维护子树所代表区间的最大子矩阵的面积。显然这个信息是可以向上合并的。因此再使用一些普通的平衡树操作以支持区间翻转和区间覆盖即可。

时间复杂度 $O(n\log_2n)$。

# 环上最大子矩阵

将数排成一个环，求最大子矩阵。

这道题容易让人想偏，但它实际上是一个脑筋急转弯。

考虑环上的一个最小权值 $a_x$。如果最优方案包含 $a_x$，那么显然我们会贪心地选择整个环的所有结点，答案为 $a_xn$；否则最优方案不包括 $a_x$，那我们就把这个元素删掉，断掉环，然后做一次序列最大子矩阵即可。

时间复杂度 $O(n)$。

# 树上最大子矩阵链

将上述问题拓展到树上，相当于我们选择一条路径，最大化路径上元素的“面积值”。

有关树上路径的问题，容易想到点分治。

对于从分治重心挂下来的链，我们可以DFS，在DFS时用单调栈维护到重心路径上的最小点权。这样就可以计算这部分的值，更新答案。

对于经过分治重心的链，考虑记录 $(a,b)$ 表示高度为 $a$ 的矩形，从分治重心挂下来的路径长度最长为 $b$。对于属于不同的根子树的两个 $(a,b),(c,d)$，显然可以用 $(c+d)\min(a,b)$ 更新答案。于是我们需要维护一个结构，支持

1. 用 $(a,b)$ 与结构中的二元组更新答案；
2. 插入一个二元组

仍然可以使用 Treap 维护（前提是权值随机，则复杂度 $O(n\log_2^2n)$）。

# 树上最大子矩阵块

我们还可以拓展为，找一个连通块，使得块内的元素的面积值最大。

这个问题可以使用并查集解决。我们将点权转化为边权（取端点的min），然后将边按边权排序，从小到大加边，然后维护连通块大小以更新答案即可。

复杂度 $O(n\log_2n)$。