---
title: '[POI2014]KUR-Couriers'
mathjax: true
abbrlink: 7183
categories:
  - 数据结构
date: 2019-04-05 15:29:30
updated: 2019-04-05 15:29:30
tags:
 - POI
keywords:
---


**摘要**

给一个数列，每次询问一个区间内有没有一个数出现次数**严格超过**一半.$n,m\leq 5\times 10^5$.


<!--more-->

复习一下主席树～

区间$[l,r]$对应版本$l-1,r$的权值线段树的差。每次查询当前结点的左右儿子结点的大小，哪一个的大小超过了区间长度的一半就转移到哪个去，否则返回0即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1<<24,MAXA=2e6;
int n,m,a[N];
int tot,rt[N],lc[N],rc[N],val[N];//val表示值域对应区间中的数的个数

int build(int l,int r){
	int u=++tot,mid=(l+r)>>1;
	if(l<r)lc[u]=build(l,mid),rc[u]=build(mid+1,r);
	return u;
}
int modify(int u,int v,int l=1,int r=MAXA){//返回结点u的副本结点
	int u2=++tot,mid=(l+r)>>1;//新建结点
	val[u2]=val[u]+1;
	if(l==r)return u2;
	if(v<=mid)lc[u2]=modify(lc[u],v,l,mid),rc[u2]=rc[u];
	else lc[u2]=lc[u],rc[u2]=modify(rc[u],v,mid+1,r);
	return u2;
}
int len;
int query(int ul,int ur,int l=1,int r=MAXA){
	assert(val[2]==0);
	if(l==r)return l;//找到
	int mid=(l+r)>>1,vl=val[lc[ur]]-val[lc[ul]],vr=val[rc[ur]]-val[rc[ul]];
	if(vl*2>len)return query(lc[ul],lc[ur],l,mid);
	else if(vr*2>len) return query(rc[ul],rc[ur],mid+1,r);
	else return 0;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	rt[0]=build(1,MAXA);
	for(int i=1;i<=n;i++)rt[i]=modify(rt[i-1],a[i]);
	for(int i=1;i<=m;i++){
		int l,r;
		scanf("%d%d",&l,&r);
		len=r-l+1;
		int k=query(rt[l-1],rt[r]);
		printf("%d\n",k);
	}
	return 0;
}
```
