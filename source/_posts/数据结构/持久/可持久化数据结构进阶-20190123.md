---
title: 可持久化数据结构进阶
categories:
  - 数据结构
mathjax: true
abbrlink: 1858
date: 2019-01-23 10:26:09
updated: 2019-05-07 13:29:09
tags:
---

# 引言

可持久化数据结构第二弹~

PS：本文全程口糊……

<!--more-->

# 权值线段树的运算

仍然是主席树的部分，我们先系统讲解权值线段树的运算

考虑两颗结构相同的权值线段树 $A,B$，那么定义有如下运算：

- 加法：$A+B$ 表示对应结点的 $cnt$ 相加得到的权值线段树
- 减法：$A-B$ 表示对应结点的 $cnt$ 相减得到的权值线段树
- 数乘：对于**整数**$x$，$A\cdot x$ 表示对应结点的 cnt 乘 $x$ 得到的权值线段树

对于上述 $A+B,A-B$，我们显然不需要建立这颗权值线段树，只需要在 $A,B$ 上维护对应的结点，实时计算 $cnt$ 即可，那么在这颗线段树上操作的复杂度则为 $O(\log_2n)$；

$A\cdot x$ 同理，不过因为只有一颗树，操作复杂度为 $O(\log_2n)$.

再举个例子，对于线段树：
$$
T=\sum_{i=1}^kA_i\cdot x_i
$$
它的操作复杂度则为 $O(k\log_2n)$.（可以理解为常数为 $k$）

在主席树上，减法的实际意义是区间的 $cnt$.

那么查询自然就是 $O(\log_2n)$ 的复杂度。

# 动态主席树

也就是带修改查询区间第 k 小

## 权值线段树上修改

首先明确修改操作的在权值线段树上的实现

把 $a$ 改为 $b$，即相当于把包含 $a$ 的值域区间的 $cnt$ 减 1，把包含 $b$ 的值域区间的 $cnt$ 加 1.

那么对于可持久化权值线段树（主席树）呢

主席树的历史版本维护的是前缀区间对应的权值线段树，如果修改了一个位置 $pos$ 上的值，会导致包含 $pos$ 的前缀区间对应的权值线段树跟着被修改，换言之版本 $pos\sim n$ 的权值线段树都要修改才行

## 树状数组套可持久化权值线段树

我们考虑**静态**主席树的本质，在初始化的时候，每次上历史版本的基础上新建结点，构建当前版本的线段树

这其实就是一个前缀求和的过程啊

结合权值线段树的加法运算，我们发现每一次在权值线段树上增加一个数，相当于把 $O(\log_2n)$ 个结点的 $cnt$ 加 1，换言之这就是权值线段树的加法运算，可以视为**权值线段树的前缀和**

对于动态主席树，一次修改会导致 $O(n)$ 的权值线段树被修改，复杂度是 $O(n\log_2n)$ 的

那么如果我们用树状数组维护前缀和呢？

那么查询版本 $t$ 的权值线段树，相当于是 $O(\log_2n)$ 个权值线段树的和

根据权值线段树的运算，对于一次区间查询，复杂度为 $O(\log_2^2n)$.（实现的时候可能要用一个外部数组实现同步跳点）

对于修改操作，也只需要修改 $O(\log_2n)$ 棵线段树，复杂度 $O(\log_2^2n)$.

## 强制在线

也就是不让你离散化

其实没什么问题，去掉初始化的部分就行

访问的时候边访问边建点

对于 $[0,2^{31})$ 的值域最多遍历 $O(\log_2n)$ 个结点，没什么问题

# 可持久化区间第 k 小

看到题目是不是有点懵逼

它的意思就是，带修改操作（直接修改，不是在历史版本上修改），并在历史版本查询区间第 k 小

之前的树状数组套可持久化权值线段树只能查询当前状态下的区间第 k 小

这个问题不用主席树，用可持久化线段树套权值线段树就行（滑稽）

具体定义如下，对于要维护的序列 $A$，对 $A$ 的下标开一个可持久化线段树，那么对于其中的结点 $u$，假设它对应的区间 $[l,r]$，即对应序列 $A_l\sim A_r$，再在这个结点上开一个基于 $A_l\sim A_r$ 的权值线段树

## 查询

显然，询问区间 $[L,R]$ 可以被分为 $O(\log_2n)$ 个部分，每个部分对应一颗权值线段树，那么同步跳点，复杂度 $O(\log_2^2n)$.

## 修改

修改一个位置 $pos$ 的值，会把 $pos$ 在线段树上对应的结点到根节点上的权值线段树都 $O(\log_2n)$ 修改一遍，总复杂度为 $O(\log_2^2n)$.

对于新建结点上的权值线段树，直接把原结点上的权值线段树持久化，节省空间（这里并不强调权值线段树的持久化，因为和外层线段树是同步的，所以不必强调）

# 树上路径第 k 小

给一颗加权有根树，每次询问 $a$ 到 $b$ 路径上的第 k 小边权

## 静态查询

之前的可持久化权值线段树都是建立在线性区间上的

那么考虑到权值线段树**极其优秀以铸就其毒瘤**的运算律，我们尝试在树形结构上建立主席树

对于根节点到 $u$ 这条路径上的边权序列，建立**权值线段树**$T_u$.

显然 $T_u$ 的权值线段树可以通过父节点的权值线段树持久化得到

那么就能在 $O(n\log_2n)$ 的时间内完成初始化

而路径 $(u,v)$ 可以由两部分得到：$(u,LCA(u,v)),(LCA(u,v),v)$.

那么对于这两段，分别用权值线段树的减法就能得到对应路径的线段树，再相加即为 $(u,v)$ 对应的线段树，即 $T=T_u+T_v-T_{LCA(u,v)}-T_{Par_{LCA(u,v)}}$.

那么在权值线段树 $T$ 上查询第 $k$ 小即可，时间复杂度 $O(\log_2n)$.

## 动态查询

即带修改操作的查询

对于一类不改变树结构的修改，可以转化为在 DFS 序列上的修改

对于一条边的修改，会影响其子树结点 $u_i$ 的 $T_{u_i}$. 那么放在 DFS 序列上就是一段区间的修改

因此我们用线段树维护 DFS 序列上的区间，对每个区间套一个可持久化权值线段树

未完待续......

# 参考文献

[1]. 陈立杰。可持久化数据结构研究。
