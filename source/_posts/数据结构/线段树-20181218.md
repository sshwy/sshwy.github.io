---
title: 线段树 -SegmentTree
categories:
  - 数据结构
mathjax: true
abbrlink: 54163
date: 2018-12-19 18:28:00
updated: 2018-12-19 18:28:00
---
# 线段树基础

线段树，是利用一个区间建立一个完全二叉树，来快速实现区间修改、查询操作。

<!--more-->

例如，要求对序列 A{1,3,4,2,5,3,7,8}进行如下两种操作：
- **add(l,r,v)**: 把 [l,r] 的元素都增加 v
- **sum(l,r)**: 求 [l,r] 的元素和

以此为例，从最基础的构建讲起。

## 线段树结构

对于闭区间 $[l,r]$, 若其对应的树的结点为 $root$，则有如下定义：

- 当 $l=r$ 时，root 没有子节点
- 否则，令 $mid=\lfloor\frac{l+r}{2}\rfloor$，则其左子区间为 $[l,mid]$, 对应结点 $root\times2$，右子区间为 $[mid+1,r]$, 对应结点 $root\times2+1$

如此递归定义，可构建一个线段树。在进行查询与修改的时候，将区间一分为二递归处理。

## 树构建

针对初始数据，我们需要对其进行线段树构建。直接递归构建即可，伪代码如下：

```
/*
变量声明
l,r,rt: 分别代表区间的左端，右端，以及其对应结点的编号
sum[]: 线段树中存储区间查询值的数组，这里是查询区间和
a[]: 初始数据
*/
```

```cpp
int tree_build(int l=1,int r=n,int rt=1){
    if(l==r)return sum[rt]=a[l];// 单个结点
    int mid=(l+r)>>1;
    tree_build(l,mid,rt<<1);// 左子区间
    tree_build(mid+1,r,rt<<1|1);// 右子区间
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];// 合并
}
```

## 区间查询

有了前面的树构建，区间查询的代码也类似，不过需要注意的是，区间查询要考虑是否有交集，如果没有交集就应停止递归。另一个比较难理解的地方是，该函数的递归终止条件是返回一个被包含在 [L,R] 的当前区间 [l,r] 的 sum 值。不过在看完伪代码以后，这个问题就比较好理解了。

```
/*
变量声明
L,R: 目标区间 [L,R] , 即要查询的区间
l,r,root: 当前区间 [l,r] 及其对应结点的编号
*/
```

```cpp
int Sum(int L,int R,int l=1,int r=n,int rt=1){
	if(r<L||R<l)return 0;// 不包含
    if(L<=l&&r<=R)return sum[rt];// 当前区间在目标区间内
    int mid=(l+r)>>1;
    return Sum(L,R,l,mid,rt<<1)+Sum(L,R,mid+1,r,rt<<1|1);
}
```

如果还没有理解它的运作方式的话，以序列 A 为例，调用 SUM(3,7,1,8,1)，即查询 [3,7] 的元素和，当前区间为 [1,8](整个序列），结点为 1（根结点)，运行情况如下：
![线段树.gif][1]

```
SUM(3,7,1,8,1)
SUM(3,7,1,4,2)
SUM(3,7,3,4,5) 发现包含，返回 sum[5]
SUM(3,7,5,8,3)
SUM(3,7,5,6,6) 发现包含，返回 sum[6]
SUM(3,7,7,8,7)
SUM(3,7,7,7,14) 发现包含，返回 sum[14]
```

## 区间修改

与 SUM 类似，不过在遇到包含的情况后不是返回 sum，而是调用另一个函数来递归完成修改。

```
/*
变量声明：
v: 要加上的值
*/
```
```cpp
int tree_add(int l=1,int r=n,int rt=1,int v){// 将整个 [l,r] 全部加 v
    if(l==r)return sum[rt]+=v;
	int mid=(l+r)>>1;
	tree_add(l,mid,rt<<1,v);
    tree_add(mid+1,r,rt<<1|1,v);
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
int add(int L,int R,int l=1,int r=n,int rt=1,int v){// 将目标区间加 v
	if(r<L||R<l)return 0;
    if(L<=l&&r<=R)return tree_add(l,r,rt,v);
    int mid=(l+r)>>1;
    add(L,R,l,mid,rt<<1,v);
    add(L,R,mid+1,r,rt<<1|1,v);
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];// 加完之后向上更新
}
```

## 线段树与树状数组

相对而言，树状数组的实现要简单于线段树，但线段树处理的问题更多更全面。

相比而言，树状数组适合处理**区间查询，点修改**或**区间修改，点查询（差分）**的问题，而线段树则能解决所有区间的修改查询问题。

# 线段树进阶

在进行区间修改时，上述代码实际上是到达两每一个点的，复杂度达到了 $O(n)$.

我们可以将这些修改操作攒起来，到了合适的时候一起修改。

## 懒惰标记 -Lazytag

对于线段树上的每一个结点，引入一个标记，记录这个结点对应的区间**需要加但还未加**的值。

等到这个结点的 sum 需要被查询的时候，再加上去。

## 懒惰标记的意义

首先搞清楚懒惰标记的意义

它不对所在结点生效，而是对该节点的子节点生效

也就是说，懒惰标记表达的是该节点的子节点所需要加的值，而该节点本身的 sum 已经被懒惰标记更新过，所以不属于标记的范畴。

说得程序一点，我们在更新 Lazytag 的时候，对该结点的值也会更新。至于为什么这样做，是因为在递归到单个元素的结点后，其本身没有子节点，为防止访问无效内存，所以这样设计。

## 懒惰标记的更新

线段树的结点是从下往上更新的，然而 Lazytag 是从上往下更新。

将原线段树的更新操作定义为`pushup()`函数：

```cpp
void pushup(ll rt){// 将下层数据向上更新
	sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
```
将 lazytag 的更新定义为`pushdown()`函数：
```
/*
变量声明：
s：保存线段树的和
add：lazytag 标记
*/
```
```cpp
void push_down(int l,int r,int rt){// 将当期标记下传
	int mid=(l+r)>>1;
	sum[rt<<1]+=(mid-l+1)*add[rt],sum[rt<<1|1]+=(r-mid)*add[rt];// 更新左右子的 sum
    add[rt<<1]+=add[rt],add[rt<<1|1]+=add[rt];// 更新左右子的标记
    add[rt]=0;// 当前标记清零
}
```

每次，在调用或经过这个结点的时候，首先 pushdown 以获取到这个结点的准确数据，并保证在下层结点修改的时候，是在准确数据的基础上修改；也就是说，在更新当前结点（比如区间加的时候），要保证它的祖先路径上的结点的 lazytag 全部下传清零

对于下层的子结点作修改之后，要在递归结尾 pushup 来把数据更新回来

因为不需要递归更新（只需要随着路径调用 pushdown），所以复杂度降至 $O(log_2n)$.

# [LuoguP3373] 线段树 2

对线段树的多重不同优先级的区间操作

维护一个区间加法和区间乘法的线段树

加法和乘法的优先级不同。因此简单的两个同级 lazytag 不能正确维护线段树。

考虑两个 lazytag：`add`和`mul`：
- 令 mul 比 add 优先。
- 区间加法时，直接更新 add 即可
- 区间乘法更新时，除了更新 mul，还要更新 add。根据乘法分配律 $(a+b)\times c=a\times c+b\times c$，所以 $(sum\times mul+add)\times v=sum\times mul\times v+add\times v$

```cpp
#include<bits/stdc++.h>
#define SIZE 262150
using namespace std;
typedef long long ll;
ll n,m,p;
ll a[100001];
ll s[SIZE],add[SIZE],mul[SIZE];
//tag_add&tag_mul
void push_down(ll l,ll r,ll rt){
	ll mid=(l+r)>>1;

	s[rt<<1]=(s[rt<<1]*mul[rt]%p+add[rt]*(mid-l+1)%p)%p;
	add[rt<<1]=(add[rt<<1]*mul[rt]%p+add[rt])%p;
	mul[rt<<1]=mul[rt<<1]*mul[rt]%p;

	s[rt<<1|1]=(s[rt<<1|1]*mul[rt]%p+add[rt]*(r-mid)%p)%p;
	add[rt<<1|1]=(add[rt<<1|1]*mul[rt]%p+add[rt])%p;
	mul[rt<<1|1]=mul[rt<<1|1]*mul[rt]%p;

	add[rt]=0,mul[rt]=1;// 注意 mul 的清零是 1 不是 0
}
void push_up(ll rt){
	s[rt]=(s[rt<<1]+s[rt<<1|1])%p;
}
ll lst_build(ll l,ll r,ll rt){
	mul[rt]=1;
	if(l==r)return s[rt]=a[l];
	ll mid=(l+r)>>1;
	lst_build(l,mid,rt<<1),lst_build(mid+1,r,rt<<1|1);
	push_up(rt);
}
ll lst_add(ll L,ll R,ll l,ll r,ll rt,ll v){
	if(R<l||r<L)return 0;
	else if(L<=l&&r<=R)return add[rt]=(add[rt]+v)%p,s[rt]=(s[rt]+v*(r-l+1)%p)%p;
	ll mid=(l+r)>>1;
	push_down(l,r,rt);
	lst_add(L,R,l,mid,rt<<1,v),lst_add(L,R,mid+1,r,rt<<1|1,v);
	push_up(rt);
}
ll lst_mul(ll L,ll R,ll l,ll r,ll rt,ll v){
	if(R<l||r<L)return 0;
	else if(L<=l&&r<=R)return mul[rt]=mul[rt]*v%p,add[rt]=add[rt]*v%p,s[rt]=s[rt]*v%p;
	ll mid=(l+r)>>1;
	push_down(l,r,rt);
	lst_mul(L,R,l,mid,rt<<1,v),lst_mul(L,R,mid+1,r,rt<<1|1,v);
	push_up(rt);
}
ll lst_sum(ll L,ll R,ll l,ll r,ll rt){
	if(R<l||r<L)return 0;
	else if(L<=l&&r<=R)return s[rt];
	ll mid=(l+r)>>1;
	push_down(l,r,rt);
	return (lst_sum(L,R,l,mid,rt<<1)+lst_sum(L,R,mid+1,r,rt<<1|1))%p;
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&p);
	for(ll i=1;i<=n;i++)scanf("%lld",&a[i]);
	lst_build(1,n,1);
	for(ll i=1,a,x,y,k;i<=m;i++){
		scanf("%lld%lld%lld",&a,&x,&y);
		if(a==1){
			scanf("%lld",&k);
			lst_mul(x,y,1,n,1,k);
		}
		else if(a==2){
			scanf("%lld",&k);
			lst_add(x,y,1,n,1,k);
		}
		else printf("%lld\n",lst_sum(x,y,1,n,1));
	}
	return 0;
}
```

# 维护段

给定长度为 n 的序列 A，Q 次操作，两种类型：

`1 x v` 将 A_x 变成 v.

`2 l r` 询问区间 [l,r] 有多少段不同的数。比如 2233224 有 4 段不同的数。

$n,Q \leq10^5$

## 思路

每个结点维护段数，区间左右端的数。

对于操作 1，根据变成的数以及左右两边的树数判断段数增减。合并时，根据左右端点的数判断增减。

对于操作 2，直接查询。

# 矩形面积并

平面上有 n 个矩形 $(U_i,D_i,L_i,R_i)$.

求矩形面积并。

n ≤ 10^5

![矩形面积并.png][2]

## 思路

将矩形拆分成上下界 $(U_i,L_i,R_i),(D_i,L_i,R_i)$，并排序。

从上往下遍历，遇到上界就添加区间覆盖，遇到下界就撤销区间覆盖。

每次查询全局被覆盖过的区间，高度为当前纵坐标与下一个界的距离。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,tot;
struct data{int x,l,r,v;};//row,l,r,up or down
data rtg[202];
bool cmp(data d1,data d2){return d1.x<d2.x;}

const int SZ=1<<18;
int s[SZ],tg[SZ];

void push_down(int l,int r,int rt){
	int mid=(l+r)>>1;
	s[rt<<1]+=tg[rt]*(mid-l+1),tg[rt<<1]+=tg[rt];
	s[rt<<1|1]+=tg[rt]*(r-mid),tg[rt<<1|1]+=tg[rt];
	tg[rt]=0;
}
void push_up(int rt){s[rt]=s[rt<<1]+s[rt<<1|1];}

int lst_add(int L,int R,int v,int l,int r,int rt){
	if(R<l||r<L)return 0;
	if(L<=l&&r<=R)return tg[rt]+=v,s[rt]+=v*(r-l+1);
	push_down(l,r,rt);
	int mid=(l+r)>>1;
	lst_add(L,R,v,l,mid,rt<<1),lst_add(L,R,v,mid+1,r,rt<<1|1);
	push_up(rt);
}
int lst_sum(int L,int R,int l,int r,int rt){
	if(R<l||r<L)return 0;
	if(L<=l&&r<=R)return s[rt];
	push_down(l,r,rt);
	int mid=(l+r)>>1;
	return lst_sum(L,R,l,mid,rt<<1)+lst_sum(L,R,mid+1,r,rt<<1|1);
}

int main(){
	scanf("%d",&n);
	for(int i=1,a,b,c,d;i<=n;i++){
		scanf("%d%d%d%d",&a,&b,&c,&d);
		rtg[++cnt]=(data){a,b,d,1};//up
		rtg[++cnt]=(data){c,b,d,-1};//down
	}
	sort(rtg+1,rtg+cnt+1,cmp);
	for(int i=1;i<=n;i++){
		lst_add(rtg[i].l,rtg[i].r,rtg[i].v,1,100000,1);
		tot+=lst_sum(1,100000,1,100000,1)*(rtg[i+1].x-rtg[i].x);
	}
	printf("%d",tot);
	return 0;
}
```
# [LuoguP4145] 花神游历各国 - 开平方

给定长度为 n 的序列 A，Q 次操作，两种类型：

`1 x v` 区间求和

`2 l r` 将区间内每个数开平方并向下取整。

n，Q ≤ 10^5, 0 ≤ A_i ≤ 10^9

## 思路

考虑到 $A_i$ 的范围以内，开 6 次方后就变成了 1。

因此维护区间最大值，当最大值是 1 时，就直接返回。

区间求和照常维护

复杂度 $O(6nlog_2n)$.

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100005;
ll n,m,a[N];
ll s[1<<18],mx[1<<18];

inline ll max(ll a,ll b){return a>b?a:b;}
inline void push_up(ll rt){
	s[rt]=s[rt<<1]+s[rt<<1|1];
	mx[rt]=max(mx[rt<<1],mx[rt<<1|1]);
}
ll lst_build(ll l,ll r,ll rt){
	if(l==r)return s[rt]=mx[rt]=a[l];
	ll mid=(l+r)>>1;
	lst_build(l,mid,rt<<1),lst_build(mid+1,r,rt<<1|1);
	push_up(rt);
}
ll vio_sqrt(ll l,ll r,ll rt){
	if(mx[rt]==1)return 0;
	if(l==r)return s[rt]=sqrt(s[rt]),mx[rt]=s[rt];
	ll mid=(l+r)>>1;
	vio_sqrt(l,mid,rt<<1),vio_sqrt(mid+1,r,rt<<1|1);
	push_up(rt);
}
ll lst_sqrt(ll L,ll R,ll l,ll r,ll rt){
	if(R<l||r<L)return 0;
	if(L<=l&&r<=R)return vio_sqrt(l,r,rt);
	ll mid=(l+r)>>1;
	lst_sqrt(L,R,l,mid,rt<<1),lst_sqrt(L,R,mid+1,r,rt<<1|1);
	push_up(rt);
}
ll lst_sum(ll L,ll R,ll l,ll r,ll rt){
	if(R<l||r<L)return 0;
	if(L<=l&&r<=R)return s[rt];
	ll mid=(l+r)>>1;
	return lst_sum(L,R,l,mid,rt<<1)+lst_sum(L,R,mid+1,r,rt<<1|1);
}
int main(){
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++)scanf("%lld",&a[i]);
	scanf("%lld",&m);
	lst_build(1,n,1);
	for(ll i=1,x,p,q;i<=m;i++){
		scanf("%lld%lld%lld",&x,&p,&q);
		if(p>q)p^=q^=p^=q;
		if(x==1)printf("%lld\n",lst_sum(p,q,1,n,1));
		else lst_sqrt(p,q,1,n,1);
	}
	return 0;
}
```

# [[HihoCoder1079] 离散化』(https://cn.vjudge.net/problem/505406/origin)

L 的范围较大，考虑离散化，区间长度降为 $10^5$.

线段树维护区间是否被**完全覆盖**。从后往前遍历海报，贴在面上的先更新。这样目前的每一张海报如果能覆盖到新的没被覆盖的区间，就说明它能被看到。每次更新时，判断是否有不完全覆盖的区间出现即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int SZ=500005;
int n,l,tot,pst[SZ][2];
int a[SZ],cnt,ans;

struct my_hash_map{
	struct data{int u,v,nex;};
	data e[SZ];
	int head[SZ],cnt;
	int hash(int u){return u%SZ;}
	int& operator[](int u){
		int hu=hash(u);
		for(int i=head[hu];i;i=e[i].nex)if(e[i].u==u)return e[i].v;
		e[++cnt]=(data){u,0,head[hu]};
		return head[hu]=cnt,e[cnt].v;
	}
};
my_hash_map h;

int s[1<<19],upd_f;
int vio_upd(int l,int r,int rt){
	s[rt]=1;
	if(l==r)return 0;
	int mid=(l+r)>>1;
	vio_upd(l,mid,rt<<1),vio_upd(mid+1,r,rt<<1|1);
}
int lst_upd(int L,int R,int l,int r,int rt){
	if(L<=l&&r<=R){
		if(s[rt]==0)upd_f=true,vio_upd(l,r,rt);
		return 0;
	}
	int mid=(l+r)>>1;
	if(!(R<l||mid<L))lst_upd(L,R,l,mid,rt<<1);
	if(!(R<mid+1||r<L))lst_upd(L,R,mid+1,r,rt<<1|1);
	s[rt]=(s[rt<<1]&&s[rt<<1|1]);
}


int main(){
	scanf("%d%d",&n,&l);
	a[cnt]=++l;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&pst[i][0],&pst[i][1]);
		a[++cnt]=++pst[i][0],a[++cnt]=++pst[i][1];
	}
	sort(a,a+cnt+1);
	for(int i=0;i<=cnt;i++)
		if(a[i]!=a[i-1])h[a[i]]=++tot;
	for(int i=n;i>=1;i--){
		upd_f=false;
		lst_upd(h[pst[i][0]],h[pst[i][1]]-1,1,h[l],1);
		ans+=upd_f;
	}
	printf("%d",ans);
	return 0;
}
```
# [JSOI2008] 最大数

裸线段树

注意初始化和标记队尾

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll M=200001;
ll m,d,t,tail;
ll mx[1<<19];

ll lst_upd(ll p,ll v,ll l,ll r,ll rt){
	if(p==l&&p==r)return mx[rt]=v;
	ll mid=(l+r)>>1;
	if(l<=p&&p<=mid)lst_upd(p,v,l,mid,rt<<1);
	else if(mid<p&&p<=r)lst_upd(p,v,mid+1,r,rt<<1|1);
	mx[rt]=max(mx[rt<<1],mx[rt<<1|1]);
}
ll lst_max(ll L,ll R,ll l,ll r,ll rt){
	if(L<=l&&r<=R)return mx[rt];
	ll mid=(l+r)>>1,mxx=1<<31;
	if(!(R<l||mid<L))mxx=max(mxx,lst_max(L,R,l,mid,rt<<1));
	if(!(R<mid+1||r<L))mxx=max(mxx,lst_max(L,R,mid+1,r,rt<<1|1));
	return mxx;
}

int main(){
	scanf("%lld%lld",&m,&d);
	memset(mx,0x80,sizeof(mx));
	for(ll i=1,x;i<=m;i++){
		char c;
		cin>>c;
		scanf("%lld",&x);
		if(c=='A'){
			++tail;
			lst_upd(tail,(x+t)%d,1,m,1);
		}
		else {
			t=lst_max(tail-x+1,tail,1,m,1);
			printf("%lld\n",t);
		}
	}
	return 0;
}
```

# [LuoguP1531]I Hate It

没读题系列......

这道题和杭电的 1754 神似，然而更新的条件不同......

杭电的至今未过。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,m,a[N],mx[1<<20];

int lst_build(int l,int r,int rt){
	if(l==r)return mx[rt]=a[l];
	int mid=(l+r)>>1;
	lst_build(l,mid,rt<<1),lst_build(mid+1,r,rt<<1|1);
	mx[rt]=max(mx[rt<<1],mx[rt<<1|1]);
}
int lst_upd(int p,int v,int l,int r,int rt){
	if(p<l||p>r)return 0;
	if(p==l&&p==r)return mx[rt]=max(mx[rt],v);
	int mid=(l+r)>>1;
	lst_upd(p,v,l,mid,rt<<1),lst_upd(p,v,mid+1,r,rt<<1|1);
	mx[rt]=max(mx[rt<<1],mx[rt<<1|1]);
}
int lst_max(int L,int R,int l,int r,int rt){
	if(R<l||r<L)return -999999999;
	if(L<=l&&r<=R)return mx[rt];
	int mid=(l+r)>>1;
	return max(lst_max(L,R,l,mid,rt<<1),lst_max(L,R,mid+1,r,rt<<1|1));
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	lst_build(1,n,1);
	for(int i=1,x,y;i<=m;i++){
		char c;
		cin>>c>>x>>y;
		if(c=='Q')printf("%d\n",lst_max(x,y,1,n,1));
		else if(c=='U') lst_upd(x,y,1,n,1);
	}
	return 0;
}
```

[1]: https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2018/08/2525998761.gif
[2]: https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2018/08/3069975259.png
