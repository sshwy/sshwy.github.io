---
title: '[POI2007]TET-Tetris Attack'
mathjax: true
abbrlink: 1237
categories:
  - 数据结构
date: 2019-04-05 12:52:27
updated: 2019-04-05 12:52:27
tags:
 - POI
keywords:
---


**摘要**

题意：给定一个长度为 $2n$ 的序列，$1\sim n$ 各出现两次，可以交换相邻两项，两个同样的数相邻会消失，求把所有数对消的最小交换次数，输出方案。$n\leq 5\times 10^5$.


<!--more-->

一看就是一个树状数组的问题，关键是代价的分析。对于两个数对的相对位置关系有 $a\cdots a\cdots b\cdots b$,$a\cdots b\cdots a\cdots b$,$a\cdots b\cdots b\cdots a$ 三种情况。第一种情况两个区间是相离的，因此合并的代价互不相关；第二种情况两区间相交，先合并 $a,b$ 的效果是等价的；第三种情况 $b$ 被包含，显然先合并 $b$ 更优.

因此我们只需要贪心地合并距离小的区间即可。每次合并完了，我们要把这两个数从原序列删除。这样的贪心策略同时可以保证不会出现第三种情况。考虑如何贪心，使用排序过于麻烦，事实上我们可以直接从左到右扫描序列，扫到一个区间的右端点就对这个区间进行合并。对于包含在内的区间一定会先被扫到，因此贪心策略的正确性得以保证。

最后考虑维护删除元素操作。我们只需要能迅速求出在下标 $1\sim i-1$ 中有多少个元素被删除，就能知道第 $i$ 个元素的确切位置。这个显然可以用树状数组维护. 找到确切位置后就可以记录方案了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;

int n,a[N*2];

int c[N*2];
void add(int p,int v){for(int i=p;i<=n*2;i+=(i&-i))c[i]+=v;}
int pre(int p,int v=0){for(int i=p;i>0;i-=(i&-i))v+=c[i];return v;}

int pos[N];//i 的左端点下标
int ans[N*2],ant;
int main(){scanf("%d",&n);
	for(int i=1;i<=n*2;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n*2;i++){if(pos[a[i]]){int l=pos[a[i]]-pre(pos[a[i]]),r=i-pre(i);// 真实坐标
			for(int j=l;j<r-1;j++)ans[++ant]=j;// 记录方案
			add(pos[a[i]],1),add(i,1);
		}
		else pos[a[i]]=i;// 第一次扫到
	}
	printf("%d\n",ant);
	for(int i=1;i<=ant;i++)printf("%d\n",ans[i]);
	return 0;
}
```

