---
title: 数据结构题的分治算法
mathjax: true
categories:
  - 数据结构
abbrlink: 52071
date: 2019-05-05 19:56:08
updated: 2019-05-09 21:08:08
tags:
keywords:
---

**摘要**

仍然是啃论文，这次啃一啃数据结构的部分

<!--more-->

# 修改与询问

我们常常遇到数据结构题，要求我们维护修改与询问的操作。这些题目的要求各不相同，而操作之间的关系也各不相同。在满足特定关系的操作中，我们利用条件的线性性与相关性，可以将一类动态问题转化为静态问题。本文就是总结这样一类思想不难，实现不难的算法。

# 动态与静态

本人大概口糊一下吧，动态问题指的是修改与询问交叉出现的，而静态问题是指，一开始把所有修改都给出，然后再给出若干询问。

# 时间分治

对于满足“修改独立，允许离线”的数据结构题，我们可以采用对操作序列分治的方式，将动态的问题转化为静态的问题求解。

修改独立，是指修改操作对询问的贡献独立，修改操作之间互不影响效果。

具体的分治方法如下。我们对操作序列（按时间排序）分治：

1. 后一半序列中的所有修改与前一半无关，也就是说前一半序列不受到后一半序列的影响，因此是一个规模更小的字问题，可以递归求解。
2. 考虑后一半的序列中的询问。这个询问只和两部分的贡献有关：前一半序列中的所有修改操作做出的贡献、后一半序列中在该询问之前的修改操作做出的贡献。我们发现第一部分对后半部分的所有询问的贡献是一样的，也就是说这是一个静态问题，做出了前一半序列中的所有修改后，回答后一半序列中的若干询问。而对于第二部分的贡献，这部分贡献只存在于后一半序列中，与前一半无关，因此是一个递归子问题。由于我们的前提是修改操作互不影响，因此第一部分和第二部分的贡献可以合并。

对于算法复杂度而言，设求解动态问题的复杂度是$T(n)$，求解静态问题的复杂度是$O(f(n))$.（包括合并的复杂度）
$$
T(n)=2T\left(\frac{n}{2}\right)+O(f(n))\\
T(n)\leq O(f(n)\log_2n)
$$
于是我们以一个log的代价，将动态的问题转化为静态的问题求解。

# 【例1】共点圆

> 在平面直角坐标系中，Wayne需要你完成n次操作，操作只有两种
>
> 1. `0 x y`，表示在坐标系中加入一个以(x, y)为圆心且过原点的圆。
> 2. `1 x y`，表示询问点(x, y)是否在所有已加入的圆的内部（含圆周），且至少在一个圆内部（含圆周）。
>
> 为了减少你的工作量，题目保证圆心严格在x轴上方（纵坐标为正），且横坐标非零。
>
> $n\leq 500000$ ，所有坐标绝对值不超过10000。

我们考虑点$(x_0,y_0)$在圆$(x,y)$中的情况
$$
(x-x_0)^2+(y-y_0)^2\leq x^2+y^2\\
2xx_0+2yy_0\geq x_0^2+y_0^2
$$
相当于对于半平面$2xx_0+2yy_0\geq x_0^2+y_0^2$ ，要求$(x,y)$在这个半平面内。因此问题转化为

1. 添加一个点
2. 给一个半平面，询问所有点是否在半平面内

做一下时间分治，问题转化为，给定一堆点，然后静态询问若干个半平面，问是否所有点都在半平面内。这个问题我们可以用凸包来做，显然只有凸包上的点最有可能跑到半平面外面，而这个点两边的斜率是“夹住”了半平面的斜率的，因此二分查找即可判定。复杂度$O(n\log_2n)$，算上时间分治的复杂度，总复杂度$O(n\log_2^2n)$. 

事实上，在分治的过程中，我们计算了前后两段的凸包后，可以直接线性合并凸包，类似归并排序。于是时间复杂度降为$O(n\log_2n)$.

# 二进制分组

对于满足“修改独立，允许离线”的数据结构题，我们可以时间分治；那如果强制在线呢？“修改独立，要求在线”的题目，我们可以通过二进制分组的方式来求解。

对一个整数二进制分组，大概是这样的
$$
\begin{split}
27&=16+8+2+1\\
28&=16+8+4\\
29&=16+8+4+1\\
30&=16+8+4+2\\
31&=16+8+4+2+1\\
32&=32
\end{split}
$$
这玩意儿怎么用在数据结构题上？我们把操作按二进制分组（比如前1-16个操作为一组，17-24个操作为一组，以此类推），在每个组内统计总贡献。在线处理当前询问，我们查询之前建立的$O(\log_2n)$个组的贡献即可。在线处理当前的修改操作，我们直接暴力重建末尾的分组，即可。比如对于前27个修改操作可以建出16+8+2+1的分组，那么对于第28个修改操作，我们把2,1的分组直接删掉，暴力重建一个4的分组，变成16+8+4.

考虑一下复杂度，每次我们重建$lowbit(k)$个分组，其中k是当前操作数，假设统计贡献的复杂度是$f(k)$，总复杂度是
$$
\sum_{k=1}^nO[f(lowbit(k))]\\
=\sum_{i=1}^{\log_2n}\left\lfloor\frac{n}{2^{i+1}}+0.5\right\rfloor\times f(2^i)\\
\leq \sum_{i=1}^{\log_2n}O(f(n))=O(f(n)\log_2n)
$$
因此我们仍是以一个$\log_2n$的复杂度将动态问题转化为静态问题。并且这种算法常数较小，实现简单。

# 【例2】在线共点圆

还是共点圆的问题，只不过要求在线。同样的，我们分出$\log_2k$个分组，每个组的点求凸包，对于半平面的询问就在log个组内查询，查询复杂度$\log_2n$.总复杂度$O(n\log_2^2n)$.

# 时间倒流

时间倒流是一种处理删除操作的小技巧。时间分治的方法处理的问题是不带撤消操作的，一个操作对其后面的所有询问都产生贡献。而有些问题是带有删除操作的，这时我们首先正常地时间分治，然后面对的是带有若干删除操作的静态问题，再将序列倒过来，把删除变成插入，从而又变成一个不带删除的动态问题，再套一个时间分治求解。

不过需要注意的是，时间倒流是倒着统计操作的贡献，处理询问的，因此仍然只能用于允许离线的问题。

# 【例3】动态共点圆问题

同样是共点圆问题的延伸

> 平面，n次操作：
>
> 1. 在坐标系中加入一个以(x, y)为圆心且过原点的圆。
> 2. 删除一个之前插入的圆。
> 3. 询问点(x, y)是否在所有已加入的圆的内部（含圆周），且至少在一个圆内部（含圆周）。

首先考虑时间分治，把操作序列分为前后两半。对于前半部分的操作是一个递归子问题，递归求解。对于在后半部分插入的圆，这些圆显然与前半部分无关，可以递归求解。而前半部分插入的圆在后半部分才删除，这些圆就对后半部分有影响。转化为半平面和凸包，因此我们的问题变成

1. 询问一个半平面是否包含所有点
2. 删除一个点

这个时侯，我们将操作序列翻转过来，删除变成插入，问题就变成了

1. 询问一个半平面是否包含所有点
2. 插入一个点

这个问题又可以用时间分治的方式求解，时间复杂度$O(n\log_2^2n)$ ，使用归并优化过程可以做到$O(n\log_2n)$.因此总复杂度$O(n\log_2^2n)$. 

# 整体二分

整体二分是一种离线算法，它将询问分别处理到不同的答案区间中，然后递归处理各个区间的询问。具体地说，整体二分要求题目满足以下性质： 

1. 询问的答案具有单调性（可二分）
2. 修改对答案的贡献独立，满足交换律结合律，具有可加性
3. 允许离线

这时，我们二分答案，计算对应的贡献。如果累积的贡献不够，就说明当前二分的答案小于要求的答案；如果贡献超了，就说明当前二分答案大于了真实答案。这样就可以把相近的答案归到同一类处理。处理的实际过程是一个分治。整体二分算法较为灵活，因此我们结合例题加以阐释。这里给出一个整体二分的伪代码，方便理解。

```pascal
Algorithm - Divide_And_Conquer( Q, L, R )
    //Q:当前处理的询问序列
    //[L,R]是当前答案区间

    if L = R then
        将Q中所有询问的答案设为L
        return
    end if

    Mid := ( L + R )/2
    Calculate( Q, L, Mid)
    //Calculate用于计算[L,Mid]对Q中询问的贡献
    //贡献存储早Contribution中，要求的答案是want
    //current是目前累积的贡献

    for i from 1 to Length(Q) do
        if Q[i].want <= Q[i].current + Contribution[i] then
            向数组QL末尾添加Q[i]
        else 
            Q[i].current = Q[i].current + Contribution[i]
            向数组QR末尾添加Q[i]
            //贡献不够，说明真实答案大于Mid
        end if
    end for

    //分治处理
    Divide_And_Conquer( QL, L, Mid )
    Divide_And_Conquer( QR, Mid+1, R )

```

# 【例4】动态区间第K小

> 一个长度为n初始值为$a_i$的序列，m个操作：
>
> 1. 单点修改序列的元素
> 2. 区间查询第k小

区间第k小是一个可以二分计算的答案，那么考虑整体二分。假设当前二分的答案为mid。二分将原问题转化为贡献计算，我们的任务变成

1. 单点修改
2. 区间查询比mid小的数的个数

我们发现，操作2的贡献是满足可加性的。因为比mid小的数等价于在区间$[1,mid)$中的数，等价于在若干个不相交且并集为$[1,mid)$的区间中的数的个数。如果贡献小于我们要求的k，说明当前询问的答案是大于mid，那么我们直接将k减掉贡献，下此不再统计$[1,mid)$的元素。如果贡献大于k，说明答案小于mid，那么不能累加贡献，就在$[l,mid]$的答案区间中继续二分即可。

那么，如何解决上述的任务呢？解决上述任务的复杂度不能关于n呈线性，因为我们的整体二分实际上会递归$O(n)$次（完全二叉树的结点个数是$O(n)$的），而不是二分答案的$O(\log_2n)$次。我们的复杂度只能和当前处理序列的长度有关。于是我们可以利用树状数组，将处在当前答案区间中的数的贡献设为1,其他数的贡献是0。对于修改操作，相当于我们把它拆成两个操作：在一个位置删除一个数、在一个位置插入一个数。这样就可以转化为贡献的修改，同样用树状数组维护。复杂度$O(k\log_2n)$.其中k是当前操作序列的长度。那么结合主定理易知，总复杂度为$O(n\log_2^2n)$.

## 参考程序

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=1e5+5;
int n,m;
int a[N];
struct data {
    int type,i,j,k,idx;
    /*
     * type==0 -> [Query]
     *   [i,j] k -th
     * type==1 -> [Modify]
     *   pos:i val(1/-1):j num:k
     */
};
typedef vector<data> qry;
qry que;
int ans[N];

namespace B{//树状数组
    int c[N];
    void add(int p,int v) {for(int i=p;i<=n;i+=i&-i)c[i]+=v;}
    int pre(int p,int res=0) {
        for(int i=p;i>=1;i-=i&-i)res+=c[i];
        return res;
    }
}
void solve(int l, int r, qry& q){//答案的区间为[l,r]
    if(q.empty())return;
    if(l==r) {
        for(int i=0;i<q.size();i++)
            if(q[i].type==0)ans[q[i].idx]=l;
        return; //答案全部设为l
    }
    int mid=(l+r)>>1;
    //处理贡献
    qry ql,qr;
    for(int i=0;i<q.size();i++){
        data& cur=q[i];
        if(cur.type==0){
            int k=B::pre(cur.j)-B::pre(cur.i-1);
            if(q[i].k>k){
                //从l~mid的数的个数小于我们要的
                //因此答案在r,mid中
                cur.k-=k;//减掉贡献
                qr.push_back(cur);
            }
            else ql.push_back(cur);
        }
        else {
            if(cur.k<=mid){
                B::add(cur.i,cur.j);
                ql.push_back(cur);
            }
            else qr.push_back(cur);
        }
    }
    //还原数组
    for(int i=0;i<ql.size();i++){
        if(ql[i].type==1)
            B::add(ql[i].i,-ql[i].j);
    }
    solve(l,mid,ql);
    solve(mid+1,r,qr);
}
void go(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) {
        scanf("%d",&a[i]);
        que.push_back((data){1,i,1,a[i]});
    }
    for(int i=1;i<=m;i++){
        char op[3];
        scanf("%s",op);
        int x,y,z;
        if(op[0]=='Q'){
            scanf("%d%d%d",&x,&y,&z);
            que.push_back((data){0,x,y,z,i});
        }
        else {
            scanf("%d%d%d",&x,&y);
            que.push_back((data){1,x,-1,a[x]});
            que.push_back((data){1,x,1,y});
            a[x]=y;
        }
    }
    memset(ans,-1,sizeof(ans));
    solve(0,(int)1e9,que);
    for(int i=0;i<que.size();i++)
        if(~ans[i])printf("%d\n",ans[i]);
}
int main(){
    int tot;
    scanf("%d",&tot);
    while(--tot>=0)go();
    return 0;
}
/*
 * 对于i t的修改操作，拆成两个操作：删除原来的数，插入现在的数
 * 
 */
```



# 参考文献

许昊然，《浅谈数据结构题的几个非经典解法》，2013信息学奥林匹克中国国家队候选队员论文