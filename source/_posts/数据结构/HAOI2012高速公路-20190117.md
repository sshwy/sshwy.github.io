---
title: '[HAOI2012]高速公路'
tags:
 - 期望
 - 线段树
categories:
  - 数据结构
mathjax: true
abbrlink: 42456
date: 2019-01-17 10:51:02
updated: 2019-01-17 10:51:02
---

# 题意

Y901高速公路是一条由$N-1$段路以及$N$个收费站组成的东西向的链，收费站依次编号为$1\sim N$，从收费站$i$行驶到$i+1$(或从$i+1$行驶到$i$)需要收取一定的费用，高速路刚建成时所有的路段都是免费的。

要求动态维护$m$个操作：

1. 将收费站$l,r(l<r)$之间的路上的收费加$v$（可能是负数）.
2. 求对于给定的$l,r(l<r)$，在第$l$到$r$个收费站里等概率随机取出两个不同的收费站$a$和$b$，那么从$a$行驶到$b$期望花费的费用. 

$n,m\leq 10^5,|v|\leq 10^4$.

<!--more-->

# 分析

这里的期望即平均值，那么
$$
Q(l,r)=\frac{\sum_{i=l}^r\sum_{j=l}^rdis[i,j]}{C_{r-l+1}^2}.
$$
考虑维护分子，把它改写为用边的贡献次数求和

假设第$i$个收费站后面的路的收费是$a_i$，那么从$l$到$r+1$的收费站的费用之和
$$
\begin{split}
\sum_{i=l}^{r+1}\sum_{j=l}^{r+1}dis[l,r]=&\sum_{i=l}^r(i-l+1)(r+1-i)a_i\\
=&-\sum_{i=l}^ri^2a_i+(r+l)\sum_{i=l}^ri\cdot a_i-(r+1)(l-1)\sum_{i=l}^ra_i\\
&\left(S_1(l,r)=\sum_{i=l}^ra_i,S_2(l,r)=\sum_{i=l}^ri\cdot a_i,S_3(l,r)=\sum_{i=l}^ri^2a_i\right)\\
=&-S_3(l,r)+(r+l)S_2(l,r)-(r+1)(l-1)S_1(l,r)\\
\end{split}
$$
考虑用线段树维护$S_1,S_2,S_3$，考虑区间加的时候

# 维护$S_1$

直接维护呢

# 维护$S_2$

$\sum_{i=l}^rval\times i=val\times \sum_{i=l}^ri$.

根据
$$
\sum_{i=1}^ni=\frac{n(n+1)}{2}
$$
那么
$$
val\times \sum_{i=l}^ri=val\left(\frac{r(r+1)-l(l-1)}{2}\right)
$$

# 维护$S_3$

区间加：$\sum_{i=l}^rval\times i^2=val\times \sum_{i=l}^ri^2$.

根据
$$
\sum_{i=1}^ni^2=\frac{n(n+1)(2n+1)}{6}
$$
那么
$$
val\times \sum_{i=l}^ri^2=val\left(\frac{r(r+1)(2r+1)-l(l-1)(2l-1)}{6}\right)
$$


最后再GCD一下就行

# 代码

```cpp
#include<cstdio>
#define int long long
using namespace std;
const int N=1e5+5,SGT=1<<18;
int n,m;

struct segment{int l,r;};
segment t[SGT];
int s1[SGT],s2[SGT],s3[SGT],tg[SGT];

int S2(int l,int r){return r*(r+1)/2-l*(l-1)/2;}
int S3(int l,int r){return r*(r+1)*(2*r+1)/6-l*(l-1)*(2*l-1)/6;}

void pushup(int rt){
	s1[rt]=s1[rt<<1]+s1[rt<<1|1];
	s2[rt]=s2[rt<<1]+s2[rt<<1|1];
	s3[rt]=s3[rt<<1]+s3[rt<<1|1];
}
void modify(int rt,int v){
	s1[rt]+=(t[rt].r-t[rt].l+1)*v;
	s2[rt]+=S2(t[rt].l,t[rt].r)*v;
	s3[rt]+=S3(t[rt].l,t[rt].r)*v;
	tg[rt]+=v;
}
void pushdown(int rt){
	modify(rt<<1,tg[rt]);
	modify(rt<<1|1,tg[rt]);
	tg[rt]=0;
}
void build(int l,int r,int rt){
	t[rt].l=l,t[rt].r=r;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(l,mid,rt<<1),build(mid+1,r,rt<<1|1);
}
void add(int L,int R,int v,int rt){
	if(L<=t[rt].l&&t[rt].r<=R){modify(rt,v);return;}
	if(tg[rt])pushdown(rt);
	if(L<=t[rt<<1].r)add(L,R,v,rt<<1);
	if(t[rt<<1].r<R)add(L,R,v,rt<<1|1);
	pushup(rt);
}
int sum1,sum2,sum3;
void query(int L,int R,int rt){
	if(L<=t[rt].l&&t[rt].r<=R){
		sum1+=s1[rt],sum2+=s2[rt],sum3+=s3[rt];
		return ;
	}
	if(tg[rt])pushdown(rt);
	if(L<=t[rt<<1].r)query(L,R,rt<<1);
	if(t[rt<<1].r<R)query(L,R,rt<<1|1);
}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
signed main(){
	scanf("%lld%lld",&n,&m);
	build(1,n,1);
	for(int i=1,l,r,v;i<=m;i++){
		char opt[5];
		scanf("%s%lld%lld",opt,&l,&r),--r;//点化线段！
		if(opt[0]=='C')scanf("%lld",&v),add(l,r,v,1);
		else {
			sum1=sum2=sum3=0;
			query(l,r,1);
			int a=-sum3+(l+r)*sum2-(r+1)*(l-1)*sum1,b=(r-l+2)*(r-l+1)/2,g=gcd(a,b);
			printf("%lld/%lld\n",a/g,b/g);
		}
	}
	return 0;
}
```

