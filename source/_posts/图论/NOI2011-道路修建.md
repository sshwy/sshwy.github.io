---
title: '[NOI2011]道路修建'
categories:
  - 图论
tags:
 - 题解
 - 拓扑
mathjax: true
abbrlink: 35848
date: 2018-10-01 20:22:00
updated: 2018-10-01 20:22:00
---

这道题要卡空间128M。。。

于是本来可以DFS的栈空间就爆了。。。

法一：玄学底层+DFS传参优化。。。

法二：直接拓扑。

<!--more-->

我们从叶结点开始拓扑，处理完之后删点，然后将新一轮的叶结点拓扑，逐渐逼近根节点，直
到队列为空。

因为是从叶结点开始遍历，所以可以自底向上处理子树大小，拓扑的过程中累加答案即可。
空间优化到40M

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1000006;

int n;
struct qxx{int nex,t;ll v;};//链式前向星
qxx e[N*2];
int head[N],cnt;
int dg[N],sz[N];//dgree,size
bool vis[N];
void add_path(int f,int t,int v){
    e[++cnt]=(qxx){head[f],t,v};
    head[f]=cnt;
}
queue<int> q;
ll ans;

int main(){
	scanf("%d",&n);
    for(int i=1,a,b,c;i<n;i++){
        scanf("%d%d%d",&a,&b,&c);
        add_path(a,b,c);
        add_path(b,a,c);
        ++dg[a],++dg[b];
    }
    for(int i=1;i<=n;i++){
    	sz[i]=1;
    	if(dg[i]==1)q.push(i);//度为1的结点即为根节点
    }
    while(!q.empty()){//队中都是度为1的点
    	int k=q.front();q.pop();
    	vis[k]=true;//已出队的标记为已访问
    	for(int i=head[k];i;i=e[i].nex){
    		if(!vis[e[i].t]){//这个点是唯一的
    			ans+=abs(n-sz[k]*2)*e[i].v;
    			sz[e[i].t]+=sz[k];
    			dg[e[i].t]--;//删点
    			if(dg[e[i].t]==1){
    				q.push(e[i].t);
    			}
    		}
    	}
    }
    printf("%lld",ans);
	return 0;
}
```
- 注意，这里的拓扑要等到结点出队的时候再标记访问，因为在队列里的结点仍可能被访问到。
