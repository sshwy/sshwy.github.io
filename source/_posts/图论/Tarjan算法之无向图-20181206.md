---
title: Tarjan算法之无向图
categories:
  - 图论
tags:
 - tarjan
 - 模板
abbrlink: 23395
mathjax: true
date: 2018-12-06 19:04:54
updated: 2018-12-06 19:04:54
---
# Tarjan要素

![p1.png][1]

DFS搜索树：即对图进行DFS遍历时所有递归到的边组成的树。<!--more-->

时间戳：对于每一个结点，我们用DFN[i]表示结点i被遍历时的次序。

追溯值：Tarjan算法引入了追溯值low[x].

设以x为根的子树为subtree(x).

low[x]定义为以下结点的DFN的最小值：（与Tarjan有向图中的low[x]区分）

1. subtree(x)中的结点
2. 通过一条不在搜索树上的边能到达subtree(x)的结点。

不难发现，low[i]按搜索树的递归遍历顺序是单调递增的，因此可以在回溯的过程中求出low[i].

# 无向图的割点与割边

对于无向图G中的结点x，如果删掉它以及与它相连的边后，整个图连通块数量增加，则结点x被称为无向图的割点。

对于无向图G中的边(x,y)，如果删掉它后，整个图连通块数量增加，则(x,y)被称为无向图的割边，也称作桥。

![p2.png][2]

## 判定割边(x,y)

1. 割边一定是DFS搜索树上的边.
1. 令x是y的父节点，则满足$DFN[x] < low[y]$。也就是说，从subtree(x)出发，不经过(x,y)的前提下无法走到更早访问的结点，则(x,y)作为subtree(x)与图G的唯一连接，即为割边。
```cpp
int dfn[N],low[N],dfn_cnt;
int ans[N],cnt;
void tarjan(int k,int p){//tarjan找桥
	dfn[k]=low[k]=++dfn_cnt;
	for(int i=h[k];i;i=e[i].nex){
		int u=e[i].t;
		if(!dfn[u]){
            tarjan(u,k);
			low[k]=min(low[k],low[u]);
			if(dfn[k]<low[u])ans[++cnt]=e[i].idx;//桥
		}
		else if(u!=p)low[k]=min(low[k],dfn[u]);
	}
}
```

## 判定割点x

1. 若x不为根节点，则要求，存在x的子节点y，满足$DFN[x]\leq low[y]$.即subtree(y)中的结点最多能走到结点x，那么将x删除就会导致subtree(y)与图G不连通.
1. 若x是根节点，则要求存在**至少2个**的子节点y，满足$DFN[x]\leq low[y]​$.

```cpp
void tarjan(int u,int p){
	low[u]=dfn[u]=++dcnt;
	int count=0;
	for(int i=h[u];i;i=e[i].nex){
		const int v=e[i].t;
		if(!dfn[v]){
            tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(dfn[u]<=low[v])count++;
		}
		else if(v!=p)low[u]=min(low[u],dfn[v]);
	}
	if(count-(u==p)>0)ans[++ant]=u;
}
```



# 无向图的双联通分量

![p3.png][3]
## 边双联通分量·E-DCC

无向图G的子图G'内不存在割边，则称G'是图G的边双联通分量。

对于图G，直接删掉所有割边，剩下分量的就是边双联通分量。

## 点双联通分量·V-DCC

无向图G的子图G'内不存在割点，则称G'是图G的点双联通分量。

对于图G，割点可能同时属于多个v-DCC，但每一条边一定只属于一个v-DCC.

图中通过边的不同颜色来标记v-DCC.

求v-DCC，需在Tarjan算法中维护一个栈：
1. 当结点x被第一次访问时，把该节点入栈。
1. 当割点判定条件$dfn[x]\leq low[y]$成立时，无论x是否为根：
  1. 从栈顶不断弹出结点，直到y被弹出。
  1. 刚才弹出的所有结点与结点x一起构成一个v-DCC.

# [POI2008]BLO

给定一张无向图，求每个点被封锁之后有多少个有序点对(x,y)(x!=y,1<=x,y<=n)满足x无法到达y

## 分析

对于非割点，只会减少和这个点有关的$2(n-1)$个点对

对于割点，则除上述之外，剩下的联通块之间也相应的有点对

![poi2008][2]

对于一个割点，将其连接的边删去后，剩余的联通块有三种情况（以上图4号点为例）

- 割点本身（4号点）
- 其搜索树上的子结点为根构成的联通块（3,8为根的搜索树构成的联通块）
- 除上述之外的结点构成一个联通块（1,2,5,6）

于是对于结点$u$，设其搜索树上的子结点为$v_i$，以$u$为根的搜索树的大小为$size[u]$，那么删除$u$后消失的点对为
$$
ans[u]=(n-1)+\left(\sum_{i=1}^ksize[v_i](n-size[v_i])\right)\\
+\left(n-1-\sum_{i=1}^ksize[v_i]\right)\left(1+\sum_{i=1}^ksize[v_i]\right)
$$


在tarjan的过程中统计即可

## 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100005,M=500005;
int n,m;

struct qxx{int nex,t;};
qxx e[M*2];
int h[N],cnt;
void add_path(int f,int t){e[++cnt]=(qxx){h[f],t},h[f]=cnt;}

int dfncnt;
int dfn[N],low[N],s[N],tp;
int sz[N];//以i为根的搜索树的大小
long long ans[N];
void tarjan(int u,int p){//p为u的父节点
	dfn[u]=low[u]=++dfncnt,s[++tp]=u,sz[u]=1;
	int count=0,sum=0;//当前u的子结点的子树和
	for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t;
		if(!dfn[v]){
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			sz[u]+=sz[v];
			if(dfn[u]<=low[v]){
				ans[u]+=(long long)sz[v]*(n-sz[v]);//统计答案
				sum+=sz[v],count++;//count:dfn[u]<=low[v]的个数
			}
		}
		else low[u]=min(low[u],dfn[v]);
	}
	if(count-(u==p)>0)ans[u]+=(long long)(n-1-sum)*(1+sum)+n-1;
	else ans[u]=2*(n-1);//不是割点，之前的计算无效
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){int a,b;
		scanf("%d%d",&a,&b);
		add_path(a,b);add_path(b,a);
	}
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i,i);
	for(int i=1;i<=n;i++)printf("%lld\n",ans[i]);
	return 0;
}
```





[1]: https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2018/09/3902810133.png
[2]: https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2018/09/3962146379.png

[3]: https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2018/09/1620780469.png