---
title: '[LuoguP1993] 小 K 的农场'
tags:
 - 图论
 - 差分约束
 - SPFA
categories:
  - 图论
mathjax: true
abbrlink: 13485
date: 2018-12-04 18:48:48
updated: 2018-12-04 18:48:48
---

# 题意

对于一组变量 $x_i$，给定 m 个如下三种条件：

- $x_a-x_b\geq c_k$
- $x_a-x_b\leq c_k$
- $x_a=x_b$

求是否存在满足所有条件的一组 $x_i=a_i$

# 分析

典型的差分约束

设农场 $i$ 的作物数为 $x_i$

对于 $x_a-x_b\leq c_k$，变形为 $x_a\leq x_b+c_k$，即最短路的三角不等式

因此，从 $b$ 向 $a$ 连一条长度为 $c$ 的边。对于这个差分约束图求最短路

如果有负环，则无解，否则有解

对于 $x_a-x_b\geq c_k$，转化为 $x_b-x_a\leq -c_k$ 即可

对于 $x_a = x_b$，建 0 边即可。

spfaDFS 判负环。设置一个结点 0，将所有点都建 0 边，使图联通

*空间要开够*

# 代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=10004;
int n,m;

struct qxx{int nex,t,v;};
qxx e[N*2];
int h[N],cnt;
void add_path(int f,int t,int v){e[++cnt]=(qxx){h[f],t,v},h[f]=cnt;}

int vis[N],d[N];//cnt 记录到 i 的最短路的边数
bool spfa(int u){
	vis[u]=1;
	for(int i=h[u];i;i=e[i].nex){
		if(d[e[i].t]>d[u]+e[i].v){
			d[e[i].t]=d[u]+e[i].v;
			if(vis[e[i].t])return 0;// 环
			if(!spfa(e[i].t))return 0;
		}
	}
	vis[u]=0;
	return 1;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){int o,a,b,c;
		scanf("%d%d%d",&o,&a,&b);
		if(o==1)scanf("%d",&c),add_path(a,b,-c);
		else if(o==2)scanf("%d",&c),add_path(b,a,c);
		else {add_path(a,b,0);add_path(b,a,0);}
	}
	for(int i=1;i<=n;i++)add_path(0,i,0),d[i]=0x3f3f3f3f;
	puts(spfa(0)?"Yes":"No");
	return 0;
}
```

