---
title: '[LuoguP2761] 软件补丁问题'
tags:
 - 最短路
categories:
  - 图论
mathjax: true
abbrlink: 15878
date: 2019-01-14 09:03:58
updated: 2019-01-14 09:03:58
---

# 题意

一个软件有 n 个错误，为该软件发放了 m 个补丁程序。

对于每一个补丁 i，都有 2 个与之相应的错误集合 B1[i] 和 B2[i]，使得仅当软件包含 B1[i] 中的所有错误，而不包含 B2[i] 中的任何错误时，才可以使用补丁 i。补丁 i 将修复软件中的某些错误 F1[i]，而同时加入另一些错误 F2[i]。另外，每个补丁都耗费一定的时间。

找到总耗时最少的软件修复方案。

<!--more-->

# 分析

网络流 24 题中隐藏的 SPFA

以软件错误的二进制状态为结点，$1$ 表示有错，$0$ 表示修复，从 $2^n-1$ 到 $0$ 跑一遍 SPFA 即可

讲一下位运算判断的部分

- 包含 B1[i] 的所有错误 $\Leftrightarrow$ 将当前结点和 B1[i] 做与运算，结果等于 B1[i].
- 不包含 B2[i] 的任何错误 $\Leftrightarrow$ 将 B2[i] 取反，和当前结点做与运算，结果等于当前结点。

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=(1<<20)+1,M=105;
int n,m;
int t[M],b1[M],b2[M],f1[M],f2[M];
char b[M],f[M];

struct qxx{int nex,t,v;};
qxx e[(int)2e6];
int h[N],cnt=1;
void add_path(int f,int t,int v){e[++cnt]=(qxx){h[f],t,v},h[f]=cnt;}

void make(int u){
	for(int i=1;i<=m;i++)if((u&b1[i])==b1[i]&&(u&b2[i])==u)
        add_path(u,(u&f1[i])|f2[i],t[i]);
}

int dis[N];
bool vis[N],make_edge[N];
void spfa(){
	memset(dis,0x3f,sizeof(dis));
	queue<int> 	q;
	int s=(1<<n)-1;
	q.push(s),dis[s]=0;
	while(q.size()){
		int u=q.front();q.pop();
		vis[u]=0;
		if(!make_edge[u])make((make_edge[u]=1,u));
		for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t,&w=e[i].v;
			if(dis[v]<=dis[u]+w)continue;
			dis[v]=dis[u]+w;
			if(!vis[v])q.push(v),vis[v]=1;
		}
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%s%s",&t[i],b+1,f+1);
		for(int j=1;j<=n;j++){
			if(b[j]=='0')b1[i]<<=1,b2[i]=b2[i]<<1|1;
			else if(b[j]=='+')b1[i]=b1[i]<<1|1,b2[i]=b2[i]<<1|1;
			else b1[i]<<=1,b2[i]<<=1;//b1:1 有，b2:0 有
			if(f[j]=='0')f1[i]=f1[i]<<1|1,f2[i]<<=1;
			else if(f[j]=='-')f1[i]<<=1,f2[i]<<=1;
			else f1[i]=f1[i]<<1|1,f2[i]=f2[i]<<1|1;//f1:0 有，f2:1 有
		}
	}//s:(1<<n)-1,t:0
	spfa();
	printf("%d",dis[0]==0x3f3f3f3f?0:dis[0]);
	return 0;
}
```

