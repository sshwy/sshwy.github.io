---
title: 网络流入门之费用流
mathjax: true
categories:
  - 图论
abbrlink: 9488
date: 2019-05-03 12:51:46
updated: 2019-06-15 08:44:46
tags:
  - 精选
keywords:
---

**摘要**

之前写的《网络流初步》内容太多，因此单独分一个费用流出来。本文的内容可能涉及到《网络流入门之最大流》的内容，建议先食用后者。

2019.6.15 编入精选文章

<!--more-->

# 费用流

给定一个网络 $G=(V,E)$，每条边除了有容量限制 $c(u,v)$，还有一个单位限制 $w(u,v)$.

当 $(u,v)$ 的流量为 $f(u,v)$ 时，需要花费 $f(u,v)\times w(u,v)$.

$w$ 也满足斜对称性，即 $w(u,v)=-w(v,u)$.

则该网络中总花费最小的最大流称为**最小费用最大流**，即在最大化 $\sum_{(s,v)\in E}f(s,v)$ 的前提下最小化 $\sum_{(u,v)\in E}f(u,v)\times w(u,v)$.

# Edmonds-Karp 算法

在 EK 算法求解最大流的基础上，把**用 BFS 求解任意增广路**改为**用 SPFA 求解单位费用之和最小的增广路**即可

相当于把 $w(u,v)$ 作为边权，在残存网络上求最短路

```cpp
struct qxx{int nex,t,v,c;};
qxx e[M];
int h[N],cnt=1;
void add_path(int f,int t,int v,int c){e[++cnt]=(qxx){h[f],t,v,c},h[f]=cnt;}
void add_flow(int f,int t,int v,int c){add_path(f,t,v,c);add_path(t,f,0,-c);}

int dis[N],pre[N],incf[N];
bool vis[N];
bool spfa(){
    memset(dis,0x3f,sizeof(dis));
	queue<int> q;
	q.push(s),dis[s]=0,incf[s]=INF,incf[t]=0;
	while(q.size()){
        int u=q.front();q.pop();
		vis[u]=0;
		for(int i=h[u];i;i=e[i].nex){
            const int &v=e[i].t,&w=e[i].v,&c=e[i].c;
			if(!w||dis[v]<=dis[u]+c)continue;
			dis[v]=dis[u]+c,incf[v]=min(w,incf[u]),pre[v]=i;
			if(!vis[v])q.push(v),vis[v]=1;
		}
	}
	return incf[t];
}
int maxflow,mincost;
void update(){
    maxflow+=incf[t];
	for(int u=t;u!=s;u=e[pre[u]^1].t){
        e[pre[u]].v-=incf[t],e[pre[u]^1].v+=incf[t];
		mincost+=incf[t]*e[pre[u]].c;
	}
}
// 调用：while(spfa())update();
```

# Dinic 算法

费用流也可以用类似 Dinic 的算法求解，其本质就是 DFS。这里我们不采用分层图的方式，而是重点利用 DFS 多路増广的方式求解费用流。

第一步和 EK 一样，要跑一遍 spfa，保证是最小费用。

有一个显然的结论，对于两个点 u,v，满足 $dist[v]=dist[u]+(u,v)$，那么 v 就在经过 u 的最短路上。那我们在增广时就可以走这条边，所以只要把 DFS 时的条件略作修改即可。

然后跑 DFS 进行增广，同时累加最大流，最小费用，同时正向边减流，反向边加流。

```cpp
const int N=1e6+6,INF=0x3f3f3f3f;

struct qxx{int nex,t,v,c;};
qxx e[N*5];
int h[N],cnt=1;
void add_path(int f,int t,int v,int c){
    e[++cnt]=(qxx){h[f],t,v,c}, h[f]=cnt;
}
void add_flow(int f,int t,int v,int c){
    add_path(f,t,v,c), add_path(t,f,0,-c);
}

int s, t, d[N];
bool spfa(){
    bool vising[N]={0};
    queue<int> q;
    memset(d,0x3f,sizeof(d));
    d[s]=0, q.push(s);
    while(q.size()){
        int u = q.front();
        q.pop(),vising[u] = 0;
        for(int i = h[u]; i; i = e[i].nex){
            const int &v= e[i].t, &w= e[i].v, &c= e[i].c;
            if(!w||d[v]<=d[u]+c)continue;
            d[v]=d[u]+c;
            if(!vising[v])q.push(v),vising[v]=1;
        }
    }
    return d[t]!=0x3f3f3f3f;
}
int mincost, maxflow;
bool vis[N];
int dfs(int u,int flow){
    vis[u]=1;
    if(u==t)return flow;
    int rest=flow;
    for(int i=h[u];i&&rest;i=e[i].nex){
        const int &v=e[i].t, &w=e[i].v, &c=e[i].c;
        if(vis[v]&&v!=t ||!w||d[v]!=d[u]+c)continue;// 这里的 v!=t 很重要！
        int k=dfs(v,min(rest,w));
        if(k)mincost+=k*c, e[i].v-=k, e[i^1].v+=k, rest-=k;
        else d[v]=0;// 増广完了
    }
    return flow-rest;
}
```

调用的时侯

```cpp
while(spfa()){
    vis[t]=1;
    while(vis[t]){
        memset(vis,0,sizeof(vis));
        maxflow+=dfs(s,0x3f3f3f3f);
    }
}
```

来一道~~卡 EK~~的费用流的题吧

# [清华集训 2017] 无限之环

> 曾经有一款流行的游戏，叫做 **Infinity Loop**，先来简单的介绍一下这个游戏:
>
> 游戏在一个 $n\times m$ 的网格状棋盘上进行，其中有些小方格中会有水管，水管可能在方格某些方向的边界的中点有接口，所有水管的粗细都相同，所以如果两个相邻方格的公共边界的中点都有接头，那么可以看作这两个接头互相连接。水管有以下 15 种形状：
>
> <span><img src="https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/05/03/131601.png" width=40%/></span><span><img src="https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/05/03/131605.png" width=40%/></span>
>
> 游戏开始时，棋盘中水管可能存在漏水的地方。
>
> 形式化地： 如果存在某个接头，没有和其它接头相连接，那么它就是一个漏水的地方。
>
> 玩家可以进行一种操作：选定一个含有**非直线型**水管的方格，将其中的水管绕方格中心顺时针或逆时针旋转 90 度。直线型水管是指绿图里中间一行的两种水管。现给出一个初始局面，请问最少进行多少次操作可以使棋盘上不存在漏水的地方。
>
> $n\times m\leq 2000$.

无限之环？无限毒瘤。

相当于我们要把所有的接口全部接上，并使费用最小。显然，费用指的就是旋转的次数。那么如何构造模型呢？

我们只需要考虑每个接口都被接上，而不需要考虑他们组成了一个什么图案。因此我们只考虑相邻两者。于是乎利用二分图的性质，黑点连源点，白点连汇点。接下来我们依此考虑每种水管的建模，以黑色点为例，将其**一分为五**，（中间的连源点 / 汇点）上下左右中：

![p1](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/05/03/134030.png)

这个形状，相当于从中间向上面连一条容量为 1 费用为 0 的边。旋转到左边，费用为 1，右边同理。所以緑色的边容量为 1 费用为 1. 同理，蓝色的边容量为 1 费用为 2。

![p4](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/05/03/134034.png)

这种情况，别的不说，当你顺时针旋转 90 度时，可以当作左边的跑到了右边，上面的不变，所以左边向右边连一条容量为 1 费用为 1 的边。同理，上下连一条容量为 1 费用为 1 的边。对于旋转 180 度的情况，你发现可以直接走刚才建的两条边，并且费用刚好就是 2, 因此不用再建边了。

![p5](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/05/03/134038.png)

这个也好理解，顺时针转 90 度相当于左边的移到下面，所以左边向下面连一条容量为 1 费用为 1 的边。其他的都同理。

其他方向的就同理了，然后白色的点的话边要全部反向。相邻点连边的时侯，直接对应接口相连即可。~~然后就可以做了吧~~.

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+6,INF=0x3f3f3f3f;
int n,m,tot;

struct qxx{int nex,t,v,c;};
qxx e[N*5];
int h[N],cnt=1;
void add_path(int f,int t,int v,int c){
    e[++cnt]=(qxx){h[f],t,v,c}, h[f]=cnt;
}
void add_flow(int f,int t,int v,int c){
    add_path(f,t,v,c), add_path(t,f,0,-c);
}

int s, t;
int d[N];
bool spfa(){
    bool vising[N]={0};
    queue<int> q;
    memset(d,0x3f,sizeof(int)*(tot*5+10));
    d[s]=0, q.push(s);
    while(q.size()){
        int u = q.front();
        q.pop(),vising[u] = 0;
        for(int i = h[u]; i; i = e[i].nex){
            const int &v= e[i].t, &w= e[i].v, &c= e[i].c;
            if(!w||d[v]<=d[u]+c)continue;
            d[v]=d[u]+c;
            if(!vising[v])q.push(v),vising[v]=1;
        }
    }
    return d[t]!=0x3f3f3f3f;
}
int mincost, maxflow, totflow;
bool vis[N];
int dfs(int u,int flow){
    vis[u]=1;
    if(u==t)return flow;
    int rest=flow;
    for(int i=h[u];i&&rest;i=e[i].nex){
        const int &v=e[i].t, &w=e[i].v, &c=e[i].c;
        if(vis[v]&&v!=t ||!w||d[v]!=d[u]+c)continue;
        int k=dfs(v,min(rest,w));
        if(k)mincost+=k*c, e[i].v-=k, e[i^1].v+=k, rest-=k;
        else d[v]=0;// 増广完了
    }
    return flow-rest;
}

void add(int sig,int f,int t,int v,int c){
    // 标记为 1 就是正向，0 就反向
    if(sig&1)add_flow(f,t,v,c);
    else add_flow(t,f,v,c);
}
void init_path(){
    for(int i=1;i<=tot;i++){//current node: i
        int a,b=(i-1)/m+(i-1)%m;
        scanf("%d", &a);
#define U(i) (i+tot*(x%4))
#define R(i) (i+tot*((x+1)%4))
#define D(i) (i+tot*((x+2)%4))
#define L(i) (i+tot*((x+3)%4))
#define M(i) (i+tot*4)
        int x=0;
        //connect with s or t
        if(b&1)add_flow(s,M(i),INF,0);
        else add_flow(M(i),t,INF,0);
        //printf("%d:%d, %d, %d, %d\n", M(i), U(i), R(i), D(i), L(i));
        if(i+m<=tot)add(b,D(i),U(i+m),1,0);
        if(i%m!=0)add(b,R(i),L(i+1),1,0);
        if(a&1)totflow++,add(b,M(i),U(i),1,0);
        if(a&2)totflow++,add(b,M(i),R(i),1,0);
        if(a&4)totflow++,add(b,M(i),D(i),1,0);
        if(a&8)totflow++,add(b,M(i),L(i),1,0);
        switch(a){
            // The first group
            case 8: ++x;
            case 4: ++x;
            case 2: ++x;
            case 1:
                add(b,U(i),L(i),1,1), add(b,U(i),R(i),1,1);
                add(b,U(i),D(i),1,2);
                break;
            // The second group
            case 12: ++x;
            case 6: ++x;
            case 3: ++x;
            case 9: 
                add(b,U(i),D(i),1,1), add(b,L(i),R(i),1,1);
                break;
            // The thrid group
            case 13: ++x;
            case 14: ++x;
            case 7: ++x;
            case 11:
                add(b,R(i),D(i),1,1), add(b,L(i),D(i),1,1);
                add(b,U(i),D(i),1,2);
                break;
        }
    }
}
int main(){
    scanf("%d%d", &n, &m);
    tot=n*m;
    s=0,t=tot*5+1;
    init_path();// 瑟瑟发抖地写一个函数来加边
    while(spfa()){
        vis[t]=1;
        while(vis[t]){
            memset(vis,0,sizeof(bool)*(tot*5+10));
            maxflow+=dfs(s,0x3f3f3f3f);
            //printf("%d %d\n", maxflow, mincost);
        }
    }
    //printf("%d %d %d\n", maxflow, mincost, totflow);
    if(maxflow*2==totflow)printf("%d", mincost);
    else printf("-1");
    return 0;
}
/*
 * BUG#1: &1 写成 %1
 * BUG#2: b=(i-1)/m+i%m 忘 -1
 * OPT#1: 改一下 memset 的 sizeof 就 30 分了
 * OPT#2: 在 47 行加一个 &&v!=t 的条件，然后就 NB 了
 * BUG#3: 改成 b=(i-1)/m+(i-1)/m
 */

```

# 参考文献

钱逸凡， [EK 不够快？再学个 Dinic 吧](https://www.luogu.org/blog/ONE-PIECE/wang-lao-liu-jiang-xie-zhi-dinic)