---
title: '[LuoguP2764]最小路径覆盖问题'
tags:
 - 二分图
 - 网络流
categories:
  - 图论
mathjax: true
abbrlink: 34904
date: 2019-01-05 10:37:53
updated: 2019-01-05 10:37:53
---

# DAG的最小路径点覆盖

给定有向图$G=(V,E)$。设$P$是$G$的一个简单路（顶点不相交的路）的集合。

如果$V$中每个顶点恰好在$P$的一条路上，则称$P$是$G$的一个路径覆盖。$P$中路径可以从$V$的任何一个顶点开始，长度也是任意的（可以为0）。

$G$的最小路径覆盖是$G$的所含路径条数最少的路径覆盖.

<!--more-->

# 分析

将每个点$u$拆成$u,u+n\in V'$两个点，将$(u,v)\in E$变成$(u,v+n)\in E'$.显然这是一个二分图

在这个二分图上的任意匹配都构成集合$P$，任意最大匹配都构成$G$的一个路径覆盖。

略证：原来$G$中的路径$\{(u_1,u_2),(u_2,u_3),\cdots,(u_{k-1},u_k)\}$在新的二分图$G'$中被拆成了$k$组互不相交的边，即$k$组匹配；同理，$G'$中的匹配也能反过来凑出若干条简单路径。证毕。

要求路径条数最少，等价于要求二分图中出度为0的点最少，等价于要求二分图中左部非匹配点最少，即最大匹配

因此，在$G'$上求最大匹配即可。我们根据匹配的结果记录后继（或者前驱），即可输出方案。

路径的条数=$|V|-$最大匹配数

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=500,M=20000,INF=0x3f3f3f3f;
int n,m,s,t;

struct qxx{int nex,t,v;};
qxx e[M];
int cnt=1,h[N],cur[N];
void add_path(int f,int t,int v){e[++cnt]=(qxx){h[f],t,v},h[f]=cnt;}
void add_flow(int f,int t,int v){add_path(f,t,v);add_path(t,f,0);}

int rk[N],pre[N];
bool bfs(){
	queue<int> q;
	memset(rk,0,sizeof(rk));
	memcpy(cur,h,sizeof(cur));
	q.push(s),rk[s]=1;
	while(q.size()){
		int u=q.front();q.pop();
		for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t,&w=e[i].v;
			if(w&&!rk[v])rk[v]=rk[u]+1,q.push(v);
		}
	}
	return rk[t];
}
int dinic(int u,int flow){
	if(u==t)return flow;
	int x,rest=flow;
	for(int i=h[u];i&&rest;i=e[i].nex){const int &v=e[i].t,&w=e[i].v;
		if(!w||rk[v]!=rk[u]+1)continue;
		x=dinic(v,min(w,rest));
		if(x)e[i].v-=x,e[i^1].v+=x,rest-=x;
		else rk[v]=0;
		if(!rest)cur[u]=i;
	}
	if(rest)cur[u]=0;
	return flow-rest;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		add_flow(u,v+n,1);
	}
	s=0,t=n+n+1;
	for(int i=1;i<=n;i++){
		add_flow(s,i,1);
		add_flow(i+n,t,1);
	}
	int maxflow=0,suf[N],id[N]={0};
	while(bfs())for(int i;i=dinic(s,INF);)maxflow+=i;
	for(int u=1;u<=n;u++){
		for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t,&w=e[i].v;
			if(v==s||v==t||w)continue;
			suf[u]=v-n,id[v-n]++;//对于每一条匹配边记录后继
		}
	}
	for(int u=1;u<=n;u++){
		if(id[u])continue;//入度为0的点即为一条路径的开头
		for(int i=u;i;i=suf[i])printf("%d ",i);
		puts("");
	}
	printf("%d",n-maxflow);
	return 0;
}
```

