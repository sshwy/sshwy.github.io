---
title: '[ZJOI2010]网络扩容'
tags:
 - 网络流
categories:
  - 图论
mathjax: true
abbrlink: 31242
date: 2019-01-14 15:27:25
updated: 2019-01-14 15:27:25
---

# 题意

给定一张有向图，每条边都有容量$C_i$和扩容费用$W_i$。这里扩容费用指将容量扩大1所需的费用。求：

1. 在不扩容的情况下，1到N的最大流.
2. 将1到N的最大流增加K所需的最小扩容费用.

<!--more-->

# Subtask1

EK或者Dinic跑一遍最大流，建图的时候把费用设成0.

# Subtask2

在Subtask1的残存网络的基础上，给每条边建一个副本，只是把容量改成INF，费用为$W_i$.

还要求最大流只增加K，那就再建一个源点连接1号点，容量设成K，费用为0，这就限制了流量

那么跑最小费用最大流就行

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e4,M=1e5,INF=0x3f3f3f3f;
int n,m,k,s,t;

struct qxx{int nex,t,v,c;};
qxx e[M];
int h[N],cnt=1;
void add_path(int f,int t,int v,int c){e[++cnt]=(qxx){h[f],t,v,c},h[f]=cnt;}
void add_flow(int f,int t,int v,int c){add_path(f,t,v,c),add_path(t,f,0,-c);}

int dis[N],pre[N],incf[N];
bool vis[N];
bool spfa(){
	memset(dis,0x3f,sizeof(dis));
	queue<int> q;
	q.push(s),dis[s]=0,incf[s]=INF,incf[t]=0;
	while(q.size()){
		int u=q.front();q.pop();
		vis[u]=0;
		for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t,&w=e[i].v,&c=e[i].c;
			if(!w||dis[v]<=dis[u]+c)continue;
			dis[v]=dis[u]+c,incf[v]=min(w,incf[u]),pre[v]=i;
			if(!vis[v])q.push(v),vis[v]=1;
		}
	}
	return incf[t];
}
int maxflow,mincost;
void update(){
	maxflow+=incf[t];
	for(int u=t;u!=s;u=e[pre[u]^1].t){
		e[pre[u]].v-=incf[t],e[pre[u]^1].v+=incf[t];
		mincost+=incf[t]*e[pre[u]].c;
	}
}
int u[M],v[M],c[M],w[M];
int main(){
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++)scanf("%d%d%d%d",&u[i],&v[i],&c[i],&w[i]),add_flow(u[i],v[i],c[i],0);
	s=1,t=n;
	while(spfa())update();
	printf("%d ",maxflow);//sbt1
	for(int i=1;i<=m;i++)add_flow(u[i],v[i],INF,w[i]);
	s=0,add_flow(s,1,k,0);
	while(spfa())update();
	printf("%d",mincost);//sbt2
	return 0;
}
```

