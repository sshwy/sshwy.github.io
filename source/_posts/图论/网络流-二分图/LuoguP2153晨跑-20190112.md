---
title: '[SDOI2009]晨跑'
tags:
 - 网络流
categories:
  - 图论
mathjax: true
abbrlink: 28968
date: 2019-01-12 16:48:36
updated: 2019-01-12 16:48:36
---

# 题意

在加权有向图中求一路径集合$(v_1,v_2,\cdots,v_k)\in S,v_i\in V,(v_i,v_{i+1})\in E$满足

- 起点为$1$，终点为$n$，即$v_1=1,v_k=n$.
- 集合内的路径除了起点终点，互不相交（即不经过相同的点）
- 对于从$1$到$n$直连的边，只能算一次

要求在最大化路径条数（即$|S|$）的前提下，最小化所有路径边权的和

$n\leq 200,m\leq 2\times 10^4$.

<!--more-->

# 分析

比较显然的费用流模型

把$1$作为源点，$n$作为汇点，$1\rightarrow n$的边特判

每个点只能被走一次$\Leftrightarrow$拆点建边，容量为1，费用为0

对于每一条边$(u,v)\in E$，连接$(u_{out},v_{in})$，并使得$c(u_{out},v_{in})=1,cost(u_{out},v_{in})=w(u,v)$.

从源点到汇点跑费用流，加上特判的部分就行了

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=1000,M=2e5,INF=0x3f3f3f3f;
int n,m,s,t;

struct qxx{int nex,t,v,c;};
qxx e[M];
int h[N],cnt=1;
void add_path(int f,int t,int v,int c){e[++cnt]=(qxx){h[f],t,v,c},h[f]=cnt;}
void add_flow(int f,int t,int v,int c){add_path(f,t,v,c);add_path(t,f,0,-c);}

int pre[N],incf[N],dis[N];
bool vis[N];
bool bfs(){
	memset(dis,0x3f,sizeof(dis));
	queue<int> q;
	q.push(s),incf[s]=INF,incf[t]=0,dis[s]=0;
	while(q.size()){
		int u=q.front();q.pop();
		vis[u]=0;
		for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t,&w=e[i].v,&c=e[i].c;
			if(!w||dis[v]<=dis[u]+c)continue;
			dis[v]=dis[u]+c,pre[v]=i,incf[v]=min(w,incf[u]);
			if(!vis[v])q.push(v),vis[v]=1;
		}
	}
	return incf[t];
}
int maxflow,mincost;
void update(){
	maxflow+=incf[t];
	for(int u=t;u!=s;u=e[pre[u]^1].t){
		e[pre[u]].v-=incf[t],e[pre[u]^1].v+=incf[t];
		mincost+=incf[t]*e[pre[u]].c;
	}
}
int flag,cost=INF;//对1->n的特判
int main(){
	scanf("%d%d",&n,&m);
	s=1<<1,t=n<<1;//必须*2不然会与其他结点冲突
	for(int i=1,a,b,c;i<=m;i++){
		scanf("%d%d%d",&a,&b,&c);
		if(a==1&&b==n)flag=1,cost=min(cost,c);
		else if(a==1)add_flow(s,b<<1,1,c);
		else if(b==n)add_flow(a<<1|1,t,1,c);
		else add_flow(a<<1|1,b<<1,1,c);
	}
	for(int i=2;i<n;i++){
		add_flow(i<<1,i<<1|1,1,0);
	}
	while(bfs())update();
	if(flag)maxflow++,mincost+=cost;
	printf("%d %d",maxflow,mincost);
	return 0;
}
//i->i<<1,i<<1|1
//源点为1，汇点为n(不拆点)。
//1->n的路径要特判
```

