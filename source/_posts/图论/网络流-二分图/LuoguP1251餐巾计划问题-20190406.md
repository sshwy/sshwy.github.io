---
title: '[LuoguP1251]餐巾计划问题'
mathjax: true
abbrlink: 40096
categories:
  - 图论
date: 2019-04-06 10:45:35
updated: 2019-04-06 10:45:35
tags:
keywords:
---


**摘要**

复习一下网络流


<!--more-->

> 一个餐厅在相继的 $N$ 天里，每天需用一些餐巾。第 $i$ 天需要 $r_i$ 块餐巾 $(i=1,2,\cdots,N)$。餐厅可以购买新的餐巾,每块餐巾的费用为 $p$ ；或者把旧餐巾送到快洗部，洗一块需 $m$ 天，其费用为 $f$ 分；或者送到慢洗部，洗一块需 $n$ 天 $(n>m)$，其费用为 $s$ 分 $(s<f)$。
>
> 每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。求最小总花费。

网络流的板子不容易写挂，最烦的就是建模和输入输出的过程，笔者就因为输入输出的问题调了好久～

看题面就知道大概是一个费用流。网络图中的流就是餐巾。对每一天我们拆点，形象地理解为早上和晚上。每天晚上会获得$r_i​$个脏餐巾且不花钱，而早上我们需要凑齐$r_i​$个干净的餐巾，这些餐巾可以买来，也可以是之前的脏餐巾洗干净后得来的。于是建模如下：

| 建边                                                         | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| $S\xrightarrow[Cost=0]{Cap=r_i}u_i^{evening}$                | 表示第$i$天晚上可以不花钱获得$r_i$张脏餐巾；                 |
| $S\xrightarrow[Cost=p]{Cap=INF}u_i^{morning}$                | 表示第$i$天早上可以花 $p$ 买任意数量的干净餐巾；             |
| $u_i^{morning}\xrightarrow[Cost=0]{Cap=r_i}T$                | 表示第$i$天早上把得到的干净餐巾投入使用（交给汇点）。为什么不给当天晚上的结点？因为当天晚上获得的脏餐巾由源点$S$直接派发。如果不把干净餐巾给汇点就不方便确定满流条件； |
| $u_i^{evening}\xrightarrow[Cost=0]{Cap=INF}u_{i+1}^{evening}$ | 表示可以对当天的脏餐巾不做操作，留到第二天晚上；             |
| $u_i^{evening}\xrightarrow[Cost=f]{Cap=INF}u_{i+m}^{morning}$ | 表示第$i$天晚上可以花钱快洗，给第$i+m$天增加干净餐巾；       |
| $u_i^{evening}\xrightarrow[Cost=s]{Cap=INF}u_{i+n}^{morning}$ | 表示第$i$天晚上可以花钱慢洗，给第$i+n$ 天增加干净餐巾；      |

跑最小费用最大流即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e3+5,M=2e6+5,INF=0x7fffffff;

struct qxx{int nex,t,v,c;};
qxx e[M];
int h[N],cnt=1;
void add_path(int f,int t,int v,int c){e[++cnt]=(qxx){h[f],t,v,c},h[f]=cnt;}
void add_flow(int f,int t,int v,int c){add_path(f,t,v,c),add_path(t,f,0,-c);}
//最小费用最大流
int s,t,mincost,maxflow;
int dis[N],incf[N],pre[N];
bool vis[N];
queue<int> q;
int spfa(){//以c为键值求最短路
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0,incf[s]=INF,incf[t]=0,q.push(s);
	while(q.size()){
		int u=q.front();q.pop();
		vis[u]=0;
		for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t,&w=e[i].v,&c=e[i].c;
			if(!w||dis[v]<=dis[u]+c)continue;
			dis[v]=dis[u]+c,incf[v]=min(incf[u],w),pre[v]=i;
			if(!vis[v])q.push(v),vis[v]=1;
		}
	}
	return incf[t];
}
void update(){//更新最小费用最大流
	maxflow+=incf[t],mincost+=incf[t]*dis[t];
	for(int u=t;u!=s;u=e[pre[u]^1].t){
		e[pre[u]].v-=incf[t],e[pre[u]^1].v+=incf[t];
	}
}
int n,r[N],p,m,f,x,y;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&r[i]);
	scanf("%lld%lld%lld%lld%lld",&p,&m,&f,&x,&y);

	s=0,t=n*2+1;//源点汇点
	for(int i=1;i<=n;i++){//i表示早上，i+n表示晚上
		add_flow(s,i+n,r[i],0);//晚上会0费用获得r[i]张脏餐巾
		add_flow(i,t,r[i],0);//干净的餐巾送往汇点
		add_flow(s,i,INF,p);//早上可以购买无限个费用为p的餐巾
		if(i+1<=n)add_flow(i+n,i+1+n,INF,0);//可以把当天晚上的脏餐巾留到第二天晚上
		if(i+m<=n)add_flow(i+n,i+m,INF,f);//快洗
		if(i+x<=n)add_flow(i+n,i+x,INF,y);//慢洗
	}
	while(spfa())update();
	printf("%lld",mincost);
	return 0;
}
```

