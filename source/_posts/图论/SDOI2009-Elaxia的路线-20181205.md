---
title: '[SDOI2009]Elaxia 的路线'
categories:
  - 图论
mathjax: true
abbrlink: 60042
date: 2018-12-05 19:49:23
updated: 2018-12-05 19:49:23
tags:
---

# 题意

求两点对之间最短路的最长公共链

# 分析

## 最短路边和点的判定

对于以 $a$ 为源点的最短路，假设所求的 $a$ 到 $x_i$ 的最短路为 $d[i]$.

对于以 $b$ 为源点的最短路，假设所求的 $b$ 到 $x_i$ 的最短路为 $g[i]$.

则在无向图中

$x$ 是从 a 到 b 最短路上的点，当且仅当 $d[x]+g[x]=d[b]\Leftrightarrow d[x]+g[x]=g[a]$.

$(x,y)$ 是从 a 到 b 上最短路上的边，当且仅当 $d[x]+g[y]+w(x,y)=d[b]\Leftrightarrow d[x]+g[y]+w(x,y)=g[a]$.

对于边的判定，这其实是有向的（即 a 到 x 的无向距离 $+w(x,y)+$ b 到 y 的无向距离）

也就是说，$d[x]+g[y]+w(x,y)$ 不一定等于 $d[y]+g[x]+w(x,y)$

利用这一点，可以进行拓扑等操作；有时对于两条起点终点相反的边，需要正反两次拓扑

## 解法

对那四个点分别跑最短路

对于**每条边**，检验是否是两个最短路图的公共边，并加入到拓扑图中

拓扑时；要对其中一个点对反向建边再跑一次，处理起点终点相反的边（这种边在有向图中不算重合，但在无向图中算同一条边）

拓扑排序即可

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define mk make_pair
#define fi first
#define se second
using namespace std;
typedef pair<int,int> pii;
const int N=1503,M=1000000;
int n,m,x1,y1,x2,y2,ans;
int dx1[N],dx2[N],dy1[N],dy2[N];

struct qxx{int nex,t,v;};
qxx e[M];
int h[N],ce;
void add_path(int f,int t,int v){e[++ce]=(qxx){h[f],t,v},h[f]=ce;}

priority_queue<pii,vector<pii>,greater<pii> > q;
void dijkstra(int st,int * d){// 最短路模板
	d[st]=0,q.push(mk(0,st));
	while(!q.empty()){
		pii u=q.top();q.pop();
		if(d[u.se]<u.fi)continue;
		for(int i=h[u.se];i;i=e[i].nex){const int &v=e[i].t,&w=e[i].v;
			if(d[v]>d[u.se]+w){
				d[v]=d[u.se]+w;
				q.push(mk(d[v],v));
			}
		}
	}
}
#define check1(a,b,c) (dx1[a]+dy1[b]+c==dx1[y1]&&dx2[a]+dy2[b]+c==dx2[y2])
#define check2(a,b,c) (dx1[a]+dy1[b]+c==dx1[y1]&&dx2[b]+dy2[a]+c==dx2[y2])
qxx te[M];
int ht[N],ct,dg[N],f[N];
void tp_add_path(int f,int idx){// 拓扑图加边
	te[++ct]=(qxx){ht[f],e[idx].t,e[idx].v},ht[f]=ct,dg[e[idx].t]++;
}
queue<int> qt;
void topu(){// 拓扑排序
	for(int i=1;i<=n;i++)if(!dg[i])qt.push(i);
	while(!qt.empty()){
		int u=qt.front();qt.pop();
		for(int i=ht[u];i;i=te[i].nex){const int &v=te[i].t,w=te[i].v;
			dg[v]--;
			f[v]=max(f[v],f[u]+w);
			if(!dg[v])qt.push(v);
		}
	}
}
int main(){
	scanf("%d%d%d%d%d%d",&n,&m,&x1,&y1,&x2,&y2);
	for(int i=1;i<=m;i++){int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add_path(u,v,w);
		add_path(v,u,w);
	}
	//dijkstra
	memset(dx1,0x3f,sizeof(dx1));
	memset(dx2,0x3f,sizeof(dx2));
	memset(dy1,0x3f,sizeof(dy1));
	memset(dy2,0x3f,sizeof(dy2));
	dijkstra(x1,dx1);
	dijkstra(y1,dy1);
	dijkstra(x2,dx2);
	dijkstra(y2,dy2);
	// 双拓扑
	for(int i=1;i<=n;i++)
		for(int j=h[i];j;j=e[j].nex)
			if(check1(i,e[j].t,e[j].v))tp_add_path(i,j);
	topu();// 正序
	for(int i=1;i<=n;i++)ans=max(f[i],ans);
	memset(ht,0,sizeof(ht));ct=0;
	memset(dg,0,sizeof(dg));
	memset(f,0,sizeof(f));
	for(int i=1;i<=n;i++)
		for(int j=h[i];j;j=e[j].nex)
			if(check2(i,e[j].t,e[j].v))tp_add_path(i,j);
	topu();// 反向边
	for(int i=1;i<=n;i++)ans=max(ans,f[i]);
	printf("%d",ans);
	return 0;
}
```

