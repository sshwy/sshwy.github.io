---
title: '[USACO13OPEN]照片Photo'
tags:
 - 差分约束
 - SPFA
categories:
  - 图论
abbrlink: 49363
date: 2018-12-13 21:41:52
updated: 2018-12-13 21:41:52
---

# 分析

梦想SFPA?（大写的滑稽）

https://fakesilhouette.blog.luogu.org/solution-p3084

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=2e5+5;
int n,m;

struct qxx{int nex,t,v;};
qxx e[N*4];
int h[N],cnt;
void add_path(int f,int t,int v){e[++cnt]=(qxx){h[f],t,v},h[f]=cnt;}

deque<int> q;
int d[N],tot,cn[N];
bool vis[N];
int spfa(int st){
	memset(d,0x3f,sizeof(d));
	d[st]=0,q.push_back(st);
	while(!q.empty()){
		int u=q.front();q.pop_front();
		vis[u]=0;
		for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t,&w=e[i].v;
			if(d[v]>d[u]+w){
				d[v]=d[u]+w,cn[v]=cn[u]+1;
				if(!vis[v]){
					if(++tot>1926817)return -1;
					vis[v]=1;
					if(cn[v]>n)return -1;
					if(q.size()&&d[v]>d[q.front()])q.push_back(v);
					else q.push_front(v);
				}
			}
		}
	}
	return d[n];
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){int a,b;
		scanf("%d%d",&a,&b);
		add_path(a-1,b,1);
		add_path(b,a-1,-1);
	}
	for(int i=1;i<=n;i++){
		add_path(i-1,i,1);
		add_path(i,i-1,0);
	}
	printf("%d",spfa(0));
	return 0;
}
```

