---
title: '[NOIP2013] 货车运输'
categories:
  - 图论
tags:
 - 题解
 - LCA
 - 生成树
mathjax: true
abbrlink: 12692
date: 2018-10-01 20:22:00
updated: 2018-10-01 20:22:00
---

- 本题关注路径上最小边权的值最大，则在图上生成一颗最大生成树，在树上跑 LCA 即可。
- 顺便练一下 Prim
- 用线段树维护最大值，树剖求 LCA.
- 注意非连通图的处理。<!--more-->
- 复杂度 $O(n^2+qlog_2n)$
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int N=100005,M=500005;
int n,m,Q;

int a[N],s[1<<18];// 维护最小值
void push_up(int rt){s[rt]=min(s[rt<<1],s[rt<<1|1]);}
int lst_build(int l=1,int r=n,int rt=1){// 线段树
	if(l==r)return s[rt]=a[l];
	int mid=(l+r)>>1;
	lst_build(l,mid,rt<<1),lst_build(mid+1,r,rt<<1|1);
	push_up(rt);
}
int lst_min(int L,int R,int l=1,int r=n,int rt=1){if(L<=l&&r<=R)return s[rt];
	int mid=(l+r)>>1,m1=0x3f3f3f3f,m2=0x3f3f3f3f;
	if(L<=mid)m1=lst_min(L,R,l,mid,rt<<1);
	if(mid<R)m2=lst_min(L,R,mid+1,r,rt<<1|1);
	return min(m1,m2);
}

struct qxx{int nex,t,v;};
qxx e[M*2];
int h[N],cnt;
void add_path(int f,int t,int v){e[++cnt]=(qxx){h[f],t,v},h[f]=cnt;
}

struct node{
	int p,s,b,v;
	int dp,sz,tp,hvs,idx;
};
node t[N];
void add_son(int p,int s,int v){t[s].p=p,t[s].b=t[p].s,t[p].s=s,t[s].v=v;
}
bool sz_vis[N];
int szdfs(int rt,int dp){t[rt].dp=dp,t[rt].sz=1,sz_vis[rt]=true;
	for(int i=t[rt].s;i;i=t[i].b)t[rt].sz+=szdfs(i,dp+1);
	return t[rt].sz;
}
int dfn;
void dedfs(int rt,int tp){t[rt].tp=tp,t[rt].idx=++dfn,a[dfn]=t[rt].v;
		// 存储的是到父结点的路径长度
	if(!t[rt].s)return;
	for(int mx=0,i=t[rt].s;i;i=t[i].b)
		if(mx<t[i].sz)mx=t[i].sz,t[rt].hvs=i;
	dedfs(t[rt].hvs,tp);
	for(int i=t[rt].s;i;i=t[i].b)
		if(i!=t[rt].hvs)dedfs(i,i);
}
int tree_query(int x,int y){
	int res=0x3f3f3f3f;
	while(t[x].tp!=t[y].tp){if(t[x].p==0&&t[y].p==0)return -1;// 不在同一连通块内
		if(t[t[x].tp].dp<t[t[y].tp].dp)x^=y^=x^=y;
		res=min(res,lst_min(t[t[x].tp].idx,t[x].idx));
		x=t[x].tp;
		if(t[x].p!=0)x=t[x].p;// 如果跳到根了，就留在根的位置
	}
	if(x==y)return res;
	else if(t[x].idx>t[y].idx)x^=y^=x^=y;
	return min(res,lst_min(t[x].idx+1,t[y].idx));
		//'t[x].idx+1'舍弃了 x 连接到父结点的边
}

struct data{
	int f,t,v;//v: 连接的边的权值
	bool operator<(data tht)const{return v<tht.v;// 边权越大，优先级越小 }
};

int main(){scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add_path(x,y,z);
		add_path(y,x,z);
	}
	//Prim
	bool vis[N]={0};
	vis[0]=1;
	priority_queue<data> q;
	for(int i=1;i<=n;i++){if(vis[i])continue;
		q.push((data){0,i,0});//addson(0,i,0), 不会对树剖有影响
		while(!q.empty()){data k=q.top();q.pop();
			if(vis[k.t])continue;
			vis[k.t]=1;
			add_son(k.f,k.t,k.v);
			for(int i=h[k.t];i;i=e[i].nex)if(!vis[e[i].t])
				q.push((data){k.t,e[i].t,e[i].v});
		}
	}
	//decomposition
	for(int i=1;i<=n;i++){if(!sz_vis[i]){szdfs(i,1);
			dedfs(i,i);
		}
	}
	lst_build();
	//query
	scanf("%d",&Q);
	for(int i=1;i<=Q;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		printf("%d\n",tree_query(x,y));
	}
	return 0;
}
```
