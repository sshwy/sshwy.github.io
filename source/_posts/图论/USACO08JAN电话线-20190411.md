---
title: '[USACO08JAN]电话线Telephone Lines'
mathjax: true
categories:
  - 图论
abbrlink: 5604
date: 2019-04-11 18:51:33
updated: 2019-04-11 18:51:33
tags:
keywords:
---


**摘要**

小清新的DP题

加权无向图，求1到n的路径中**第k+1大边权最小**的路径，输出这个第k+1大边权，$k\leq n\leq 1000$.


<!--more-->

令 $f[i,j]$ 表示到结点i的第j大边权的最小值，对于边$(u,v)$：
$$
f[u,j]\xrightarrow{\max(f[u,j],w(u,v))}f[v,j]\\
f[u,j]\xrightarrow{f[u,j]}f[v,j+j]
$$
其中箭头表示DP转移。既然是在图上的DP，顺便套一个最短路加速转移即可，复杂度$O(nk\log_2n)$.

好像还可以二分做。。。不管了

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005,M=N*N,INF=0x3f3f3f3f;
int n,p,k;

struct qxx{int nex,t,v;};
qxx e[M*2];
int h[N],cnt;
void add_path(int f,int t,int v){e[++cnt]=(qxx){h[f],t,v},h[f]=cnt;}

int tr(int x,int y){return x*(k+1)+y;}
void rt(int idx,int &x,int &y){x=idx/(k+1),y=idx%(k+1);}
int f[N][N];//f[i,j]表示到第i个点修j次的最小的第j+1大

typedef pair<int,int> pis;
priority_queue<pis,vector<pis>,greater<pis> > q;
void go(){
	memset(f,0x3f,sizeof(f));
	for(int j=0;j<=k;j++)f[1][j]=0,q.push(make_pair(0,tr(1,j)));
	while(q.size()){
		pis u=q.top();q.pop();
		int i,j;
		rt(u.second,i,j);
		if(f[i][j]<u.first)continue;
		for(int x=h[i];x;x=e[x].nex){const int &v=e[x].t,&w=e[x].v;
			if(j<k&&f[v][j+1]>f[i][j]){
				f[v][j+1]=f[i][j],q.push(make_pair(f[v][j+1],tr(v,j+1)));
			}
			if(f[v][j]>max(f[i][j],w)){
				f[v][j]=max(f[i][j],w),q.push(make_pair(f[v][j],tr(v,j)));
			}
		}
	}
}

int main(){
	scanf("%d%d%d",&n,&p,&k);
	for(int i=1;i<=p;i++){
		int a,b,l;
		scanf("%d%d%d",&a,&b,&l);
		add_path(a,b,l),add_path(b,a,l);
	}
	go();
	printf("%d",f[n][k]>=INF?-1:f[n][k]);
}

```

