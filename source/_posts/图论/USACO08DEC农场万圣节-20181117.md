---
title: '[USACO08DEC]Trick or Treat on the Farm'
tags:
 - 遍历
 - DFS
categories:
  - 图论
abbrlink: 31903
date: 2018-11-17 21:55:31
updated: 2018-11-17 21:55:31
---

一颗基环树，则先处理环，再 DFS 处理其他结点即可

不知为何是蓝题

```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int N=100005;
int n,nex[N],id[N],ans[N];
bool vis[N];
queue<int> q;
void dfs(int u){// 处理剩下的树边
	if(vis[u])return;
	dfs(nex[u]);
	vis[u]=1,ans[u]=ans[nex[u]]+1;
}
int main(){scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&nex[i]),id[nex[i]]++;
	for(int i=1;i<=n;i++)if(id[i]==0)q.push(i);
	while(!q.empty()){int k=q.front();q.pop();
		id[nex[k]]--;
		if(id[nex[k]]==0)q.push(nex[k]);
	}// 筛环
	for(int i=1;i<=n;i++)if(id[i]){// 处理每个环
		int len=1;
		for(int j=nex[i];j!=i;j=nex[j])len++;
		vis[i]=1,ans[i]=len,id[i]=0;
		for(int j=nex[i];j!=i;j=nex[j])vis[j]=1,ans[j]=len,id[j]=0;
	}
	for(int i=1;i<=n;i++)dfs(i);
	for(int i=1;i<=n;i++)printf("%d\n",ans[i]);
	return 0;
}
```

