---
title: 点分治入门
mathjax: true
abbrlink: 2120
categories:
  - 图论
date: 2019-03-07 16:16:54
updated: 2019-03-07 16:16:54
tags:
---


**摘要**

莫名其妙发现这几天遇到了很多点分治的题目，于是来系统整理一下点分治算法

点分治是一种树上分治算法。通常用于解决无根树上的统计问题。对于统计的问题，可以按照结点对其分类，分别统计后再组合成结果。而这类问题的求解复杂度往往和树的深度、大小有关，因此需要适当调整树的结构来使算法更加高效


<!--more-->

# 例题引入

> 给定一棵有n个点的（边）加权无根树，m次询问树上长度为k的简单路径是否存在.
>
> $n\leq 10000,m\leq 100,k\leq 10000000$.（来源：洛谷模板题）

朴素算法可以枚举端点然后计算长度，存到bool数组里，回答每个询问，复杂度$O(n^2)$.

## 初步构思

如果我们把这棵树变成一颗有根树，那么不难发现路径可以分类。我们按照路径上深度最小的结点来分类，把路径归到结点分类中。对于根节点而言，和它有关的路径就是经过根节点的路径（包括端点的情况）。对于结点$u$而言，和它有关的就是它的**子树内**经过它的路径。可见这种分类的方法能够保证**不重不漏**.

利用这种分类，我们尝试统计路径的信息。我们选定一个根节点$root$，然后统计和它有关的信息，统计完后，我们**将它从树中删除**，然后树就会变成若干个联通块（每个联通块是原树的子树）。我们可以对这些联通块递归进行相同的操作，统计对应的信息。

考虑这样的算法为什么是不重不漏的。对于一条路径，它要么经过根节点，要么就不经过根节点。如果经过根节点的话，我们就会在当前的递归状态下去统计；如果不经过根节点的话，就一定可以放在根节点的子树的联通块中处理。这就保证了**不重不漏**.

![sample](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/03/07/1821.png)

## 复杂度调整

上文保证了算法的正确性，但是算法的效率如何？这取决于当前**选择的根节点的位置**以及**统计一个结点的信息的复杂度**.我们会在每次选择当前子树的**重心**$(barycentre)$作为根节点，因为重心可以使得删除后最大的联通块最小.而统计一次信息的复杂度显然和当前子树的大小有关。稍后我们会简单证明，点分治的复杂度是$O(\theta\log_2n)$，其中$\theta$是对**整棵树的根节点**统计一次信息的复杂度.

我们考虑如何统计经过当前根节点的路径的存在性。在遍历$root$的子节点$v_i$的时候，我们统计$v_i$子树下的点到$root$的距离并记录下来，放在$dis$数组里。

同时我们维护bool数组$exist[k]$表示在$v_1\sim v_{i-1}$的子树下，长度为$k$的以$root$为端点的路径是否存在。然后我们双重循环遍历所有的$dis[i]$，判断它们的差是否在$exist$中存在，进而回答询问。然后把$dis$中出现的长度标记到$exist$中，然后清空$dis$.这样我们就完成了对当前根节点的信息统计。

复杂度$O(|T_{root}|m)$.算上点分治的复杂度，总复杂度$O(mn\log_2n)$.

# 算法框架

点分治算法的大致过程如下：

1. 对于当前联通子树的**根节点**统计信息
2. 把根节点从这棵树中删除，使得这个树分割为若干个联通子树
3. 对于每一个联通子树，把它的重心作为它的根节点，重复上述过程

初始的时候，我们选择整棵树的重心作为根节点。

# 复杂度略证

由于每次都是找数的重心，所以处理完一个大小为$n$的树后，它的每个子树，大小都是最大为$n^2$，所以最多分治$\log_2n$层，每层的问题空间都是$n$，故时间复杂度为$O(\theta\log_2n)$.

下面给出一种代码实现.

| 重要变量声明 | 含义                                                    |
| ------------ | ------------------------------------------------------- |
| vis[i]       | 表示结点i是否被删除了                                   |
| sz[i]        | 当前状态下子树i的大小                                   |
| mp[i]        | maxpart,当前情况下i的子结点中sz的最大值（用来确定重心） |
| cur          | 当前子树大小                                            |
| ctr          | 当前重心                                                |

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5,INF=0x3f3f3f3f,K=1e7+5;

struct qxx{int nex,t,v;};
qxx e[N*2];
int h[N],cnt;
void add_path(int f,int t,int v){e[++cnt]=(qxx){h[f],t,v},h[f]=cnt;}

int n,m;
int query[105];

bitset<N> vis;//记录该点是否已删除
int sz[N],mp[N],cur,ctr;//当前子树大小,最大的联通块大小,当前整个树的大小，当前重心
void getcenter(int u,int p){//计算sz
	sz[u]=1,mp[u]=0;
	for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t;
		if(v==p||vis[v])continue;
		getcenter(v,u),sz[u]+=sz[v];
		mp[u]=max(mp[u],sz[v]);
	}
	mp[u]=max(mp[u],cur-sz[u]);
	if(mp[u]<mp[ctr])ctr=u;	
}
bitset<K> curex;//当前点分治下的路径存在性统计
int dis[N];
int expath[N],expcnt;
void getdis(int u,int p){
	expath[++expcnt]=dis[u];//记录这次出现的路径
	for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t;
		if(v==p||vis[v])continue;
		dis[v]=dis[u]+e[i].v,getdis(v,u);
	}
}
void calc(int u){//计算和u有关的问题 
	curex[0]=1;//长度为0的路径
	for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t;
		if(vis[v])continue;
		expcnt=0,dis[v]=e[i].v,getdis(v,u);//对子树v计算到u结点的距离
		for(int j=1;j<=expcnt;j++)for(int k=1;k<=m;k++)
			if(query[k]>=expath[j]&&curex[query[k]-expath[j]])query[k]=-1;//达成询问
		for(int j=1;j<=expcnt;j++)curex[expath[j]]=1;//标记出现的以u为端点的路径
	}
	curex.reset();
}
void divid(int u){//对u所在的联通块做点分治，u不一定是根节点
	vis[u]=1;//标记
	calc(u);//计算和u有关的问题
	for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t;
		if(vis[v])continue;//已被点分
		cur=sz[v];//这个sz是建立在上一次u的点分的基础上的
		mp[ctr=0]=INF;//重心的maxpart初始化为无穷大
		getcenter(v,v),divid(ctr);//对v所在的联通块做点分治
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++){int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add_path(a,b,c),add_path(b,a,c);
	}
	for(int i=1;i<=m;i++)scanf("%d",&query[i]);
	cur=n,mp[ctr=0]=INF,getcenter(1,1),divid(ctr);
	for(int i=1;i<=m;i++)puts(query[i]==-1?"AYE":"NAY");
	return 0;
}
```

