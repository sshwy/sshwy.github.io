---
title: '[NOI2014] 动物园'
mathjax: true
categories:
  - 字符串
keywords: 'KMP, border, 字符串'
abbrlink: 9407
date: 2019-04-10 08:51:58
updated: 2019-04-10 08:51:58
tags:
---


**摘要**

题意：对字符串的每个前缀求长度小于等于一半的 $Border$ 的个数


<!--more-->

许多题解里都说可以在求 $Next$ 的时候顺便求，笔者没有想到这个思路。根据 $Border$ 的树形结构，其实相当于在树上找到根结点路径上编号小于等于一半的结点个数，这个可以用临界结点的深度来求，因此我们在树上暴力求即可。

因为 $Border$ 树的某些神奇性质，貌似复杂度不错

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int L=1e6+6,P=1e9+7;
int n;
char s[L];

namespace KMP{int nex[L],dep[L],num[L];//border 树上的结点深度
	bool vis[L];
	void getnext(char *s,int ls){nex[1]=0;
		for(int i=2,j=0;i<=ls;i++){while(j&&s[i]!=s[j+1])j=nex[j];
			if(s[i]==s[j+1])++j;
			nex[i]=j;
		}
	}
	void makedep(char *s,int ls){getnext(s,ls);
		dep[0]=1;
		for(int i=1;i<=ls;i++)dep[i]=dep[nex[i]]+1;
	}
	int calc(char *s,int ls){
		int res=1;
		makedep(s,ls);
		memset(vis,0,sizeof(vis));
		for(int i=ls;i>=1;i--){// 求 i 到根结点上的结点的 num
			for(int u=i,j=nex[u];u;u=nex[u]){// 当前结点为 u
				if(vis[u])break;
				while(j*2>u)j=nex[j];//j 为临界结点
				num[u]=dep[j],vis[u]=1,res=(ll)res*num[u]%P;
			}
		}
		return res;
	}
}
int main(){scanf("%d",&n);
	while(n--){scanf("%s",s+1);
		printf("%d\n",KMP::calc(s,strlen(s+1)));
	}
	return 0;
}
```

