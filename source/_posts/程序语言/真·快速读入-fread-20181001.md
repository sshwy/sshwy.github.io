---
title: 真·快速读入|fread
categories:
  - 程序语言
tags:
 - 快读
 - 模板
abbrlink: 19925
date: 2018-10-01 09:24:01
updated: 2018-10-01 09:24:01
---
C++程序除了算法的高效，数据读入的高效也是十分重要的。在面对大数据流时（尤其指10^6以上的数字），高效的读入能节省很多的时间。
## 原理
先来看知乎大佬翻译源代码为人类语言的`getchar()`：
<!--more-->
```cpp
作者：Pallad
链接：https://www.zhihu.com/question/39909689/answer/88523074
来源：知乎
```
```cpp
int 缓存初始化为空; // 缓存不会被清空，除非 main() 执行完.
char getchar(){
	if(缓存是空的){
		屏幕上跳出光标并且开始监听输入;
		if(回车键被按下){
			系统 (不是getchar函数) 命令光标跳至新行;
			将所有输入的字符末尾加上 '\n' 并存入缓存;
			读取缓存的第一个字符到temp; // 即使第一个字符是 '\n'
			将缓存左移一个字符;
			return temp; // 即使 temp 是 '\n'
		}
	} else {
		读取缓存的第一个字符到temp; // 即使第一个字符是 '\n'
		将缓存左移一个字符;
	}
	return temp; // 即使 temp 是 '\n'
}
```
相比之下，`scanf()`会涉及到将字符放回缓冲流，处理格式字符，判断文件尾等操作，运行时自然速度不那么快。

## 模板
快读绝大多数时候用于读数字。
利用getchar读取无符号int：
```cpp
int rd(){
	int res=0;
	char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
```
这里的`isdigit()`判断是否为数字，比你直接写`if`判断要快 [见知乎-常优](https://www.zhihu.com/question/49272859)
**其他快读在此模板上加判断即可，不赘述。**

## 真·快速读入
### fread()
fread()的声明如下
`size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)`
- `void *ptr` ：指向内存块的指针（比如字符串的名字）
- `size_t size` ：内存块中单个元素的大小（单位为字节）
- `size_t nmemb` ：读取次数（内存块中的元素数）
- `FILE *stream` ：指向 FILE 对象的指针
- `size_t` : 它是一种能够以字节为单位表示任何对象大小的类型：size_t是sizeof运算符返回的类型，在标准库中广泛用于表示大小和计数。
- `fread()`返回成功读取的元素总数。

### 应用fread写快读
使用`fread()`代替`getchar`：
```cpp
char nc(){//据传为Manchery大神所作
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
```
- 不得不说，这种压行代码是非常玄学的
- `static`表示静态变量，作用域在函数`nc()`里，存活时间为程序运行时间。
- `buf`为数组的首地址，为其分配100000字节的空间；p1,p2为指向字符的指针。
- 至于这一行`return`的操作分解如下：
  - 若`p1==p2`为真，则计算`(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)`的值：
    - 赋值表达式的值为其本身，所以`(p1=buf)`的值为buf；
    - 用`fread`从标准读入流读取了以1字节为单个元素大小的100000个元素并存储到buf数组中，`fread()`返回了读取字符的总数，加上buf，即为读取的最后一个字符的后一位的地址。因此`p2`是`p1`遍历数组的边界。
    - 逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值，因此经过上面的读取后，整个表达式的值仍为`p1==p2`的值，当然这时的`p1` `p2`是读取后的`p1` `p2`，如果仍然相等，说明没有字符了，返回`EOF`
  - 若`p1==p2`为假，则将不判断逻辑与（&&）后面的表达式，直接返回三目运算符最后一目的表达式，即p1指向的字符，然后p1指针后移一位。

因此，上述代码的正常版是这样的：
```cpp
char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    if(p1==p2)retrn *p1++;
    p1=buf;
    p2=buf+fread(buf,1,100000,stdin);
    if(p1==p2)return EOF;
    else return *p1++;
}
```
利用这个函数代替getchar，再来读入，效果显著。
当然，上述代码每次将100000个字符读到`buf`里面，显然不能再用`scanf`或`cin`了，因为都读到`buf`里面去了。不过，速度感人。
### 一个栗子
- BZOJ4195，用`scanf()`读入：
![TIM20180731154526.png](https://www.z4a.net/images/2018/07/31/TIM20180731154526.png)

- 用`getchar()`快读：
![TIM20180731154559.png](https://www.z4a.net/images/2018/07/31/TIM20180731154559.png)

- 用`nc()`代替`getchar()`：
![TIM20180731154613.png](https://www.z4a.net/images/2018/07/31/TIM20180731154613.png)

**总时间减少将近一半！**

## 总结
虽然快读的优化显著，但并不用每次都快读。读入的数据少，就不需要，否则就是增加代码长度，很累赘。读入的数据多，用快读，才能有效果。

任何优化，都要优化在有用的地方。
