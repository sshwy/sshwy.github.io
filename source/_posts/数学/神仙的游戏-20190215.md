---
title: '[BZOJ5372] 神仙的游戏'
tags:
 - FFT
categories:
  - 数学
mathjax: true
abbrlink: 61248
date: 2019-02-15 22:50:02
updated: 2019-02-15 22:50:02
---


**摘要**

一道综合生成函数和多项式乘法的题

这道题提醒我，空间一定要开够！（记得双倍，尤其是计算长度的时候）


<!--more-->

# 题意

定义字符串 $S[1\cdots n]$ 的 border 是满足以下条件的 $len$：
$$
\forall i\in\{1,2,\cdots,len\},\Rightarrow S[i]=S[|S|-len+i].
$$
字符串本身由 01? 组成，其中？可以同时匹配 01.

求所有 border 的 $len^2$ 的异或和。

# 分析

首先要知道 border 与循环节是一一对应的，因此需要我们找到合法的循环节长度。

对于长度为 $d$ 的循环节，将 $S$ 的字符按 $d$ 的剩余类分组，那么该循环节合法的充要条件就是，同一组内不能同时出现 01.

由于判断合法的循环节复杂度过高，我们想办法求不合法的循环节。

考虑 $i,j$，如果 $S[i],S[j]$ 一个为 0 一个为 1，那么显然 $d=|i-j|$ 的循环节是不合法的。除此之外，$d$ 的约数的循环节也是不合法的。

对于这样的关系，我们尝试构造生成函数：
$$
A(x)=\sum_{i=1}^{n}[s[i]=1]x^i,\\B(x)=\sum_{i=1}^{n}[s[i]=0]x^{-i}.
$$
上述生成函数分别表示当 $s[i]$ 为 $0/1$ 时，$A(x)$ 和 $B(x)$ 对 $x$ 的系数有 1 的贡献。而两者的卷积
$$
(A\ast B)=\sum_{i=1}^{n}[s[i]=1]x^i\sum_{j=1}^{n}[s[j]=0]x^{-j}\\
=\sum_{d=1-n}^{n-1}x^d\sum_{i=d+1}^{n}[s[i]=1][s[i-d]=0]
$$
$x^d$ 的系数显然表示当 $i-j=d$ 的时候不合法循环节的截点数。利用这个系数，我们就可以确定每一个循环节是否合法（判断是否为 0）

但是这个多项式并不是普通意义下的多项式乘法。因为 $B$ 的 $x$ 的指数是负数。这个好办，我们指数同时加一个 $n$ 即可。
$$
\begin{split}
A(x)&=\sum_{i=1}^{n}[s[i]=1]x^i,\\
B(x)&=\sum_{i=1}^{n}[s[i]=0]x^{n-i}=\sum_{i=0}^{n-1}[s[n-i]=0]x^{i}.\\
(A\ast B)&=\sum_{i=1}^{n}[s[i]=1]x^i\sum_{j=1}^{n}[s[j]=0]x^{n-j}\\
&=\sum_{d=1-n}^{n-1}x^{n+d}[sth]
\end{split}
$$


这里我们不关心 $x^{n+d}$ 的系数（因为这是我们要算的），只需要知道 $x^{n\pm d}$ 的系数都对应长度 $d$ 的截点数即可

那么 FFT 一下，现在我们知道每个循环节本身的合法性，又因为对于不合法的 $d$，其约数的循环节也是不合法的，那么我们 $n\log_2n$ 对整个序列筛一下倍数即可。

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define PI M_PI
using namespace std;
const int N=(1<<20)+5;
struct cpx{
	double a,b;
	cpx(double _a=0,double _b=0){a=_a,b=_b;}
	cpx operator+(cpx c){return cpx(a+c.a,b+c.b);}
	cpx operator-(cpx c){return cpx(a-c.a,b-c.b);}
	cpx operator*(cpx c){return cpx(a*c.a-b*c.b,a*c.b+b*c.a);}
};
int tr[N],dgl;
void trans(cpx *y,int len){for(int i=1;i<len;i++)if(i<tr[i])swap(y[i],y[tr[i]]);}
void fft(cpx *y,int len,int tag){
	trans(y,len);
	for(int j=1;j<len;j<<=1){cpx wn(cos(PI/j),tag*sin(PI/j));
		for(int i=0;i<len;i+=j<<1){cpx w(1,0),u,v;
			for(int k=i;k<i+j;k++)u=y[k],v=y[k+j]*w,y[k]=u+v,y[k+j]=u-v,w=w*wn;
		}
	}
	if(tag==-1)for(int i=0;i<len;i++)y[i].a/=len;
}

char s[N];
int ls,len=1;
cpx A[N],B[N];
int f[N],g[N];
int main(){
	scanf("%s",s+1);
	ls=strlen(s+1);
	while(len<(ls<<1))len<<=1,dgl++;
	for(int i=1;i<len;i++)tr[i]=(tr[i>>1]>>1)|(i&1)<<(dgl-1);
	for(int i=1;i<=ls;i++)A[i].a=(s[i]=='1'),B[ls-i].a=(s[i]=='0');
	fft(A,len,1),fft(B,len,1);
	for(int i=0;i<len;i++)A[i]=A[i]*B[i];
	fft(A,len,-1);
	for(int i=0;i<ls;i++)f[i]=(int)(A[ls+i].a+0.1)+(int)(A[ls-i].a+0.1);
	f[ls]=0;
	for(int i=1;i<=ls;i++){
		bool fl=1;
		for(int j=1;i*j<=ls;j++)if(f[i*j]){fl=0;break;}
		g[ls-i]=fl;
	}
	g[ls]=1;
	long long ans=0;
	for(int i=0;i<=ls;i++)if(g[i])ans=ans^((long long)i*i);
	printf("%lld",ans);
	return 0;
}

```

