---
title: 博弈论
tags:
 - 博弈论
 - SG
categories:
  - 数学
mathjax: true
abbrlink: 52500
keywords: '博弈论,博弈,nim,icg'
date: 2018-12-13 20:51:02
updated: 2019-03-04 08:31:02
---


**摘要**

dls 讲博弈论啦

“我掉线，你随意”


<!--more-->

# NIM 博弈

> 给定 $n$ 堆物品，第 $i$ 堆物品有 $A_i$ 个。
>
> 两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取
>
> 取走最后一件物品的人获胜。若两人都采取最佳策略，问能否获胜

这类游戏被称为 $NIM$ 博弈，游戏过程中面临的状态称为局面。

## 定理

$NIM$ 博弈（双方均采取最佳策略时）先手必胜，当且仅当 $A_1 \text{ xor } A_2\text{ xor }\cdots\text{ xor }A_n\neq 0$.

证明：

所有物品被取光显然是必败局面，此时 $A_1 \text{ xor } A_2\text{ xor }\cdots\text{ xor }A_n=0$.

对于任意一个 $A_1 \text{ xor } A_2\text{ xor }\cdots\text{ xor }A_n=x\neq 0​$ 的局面，设 x 的最高位的 1 在第 $k​$ 位，显然存在一个 $A_i​$ 的第 $k​$ 位为 1。又因为 $A_i\text{ xor }x<A_i​$，因此我们把 $A_i​$ 变成 $A_i\text{ xor }x​$，即给对手一个 $A_1 \text{ xor } A_2\text{ xor }\cdots\text{ xor }A_n=0​$ 的局面

而对于 $A_1 \text{ xor } A_2\text{ xor }\cdots\text{ xor }A_n=0$ 的局面，无论怎么取石子，剩下的异或和都不可能为 0（不能不取）

于是用数学归纳法，$A_1 \text{ xor } A_2\text{ xor }\cdots\text{ xor }A_n\neq 0$ 为必胜局面，反之必败。



# ICG 公平组合游戏

一个游戏满足

1. 两名玩家交替行动
2. 每一个玩家的行动方式相同
3. 不能行动的玩家判负

则该游戏被称作一个公平组合游戏

# 有向图游戏

给定一个 DAG，从起点，两个人轮流沿边行动，无法移动者负

显然出度为 0 的点必败

任何 ICG 都可以转化为有向图游戏：把每一个局面看作点，把合法行动作为有向边

## Mex

对于非负整数集合 $S$，定义
$$
mes(S)=\min_{i=\mathbb{N},i\notin S}\{i\}.
$$

## SG 函数

在有向图游戏中，对于结点 x 以及其到达的结点 $\{y_i\}$，定义
$$
SG(x)=mex\left(\left\{SG(y_i)|i\in[1,k]\right\}\right)
$$
对于整个有向图游戏 G，若初始局面为 $s$，有 $SG(G)=SG(s)$.

## 有向图游戏的和

对于 $NIM$ 博弈，将对象换成

> 给定 $n$ 个有向图游戏 $G_i$，两名玩家轮流行动，每次可以任选一个游戏，行动一步
>
> 无法操作者为负

则整个游戏的 SG 值为
$$
SG(G)=SG(G_1)\text{ xor }SG(G_2)\text{ xor }\cdots\text{ xor }SG(G_k)
$$

## 定理

有向图游戏的某个局面 $x$ 必胜，当且仅当 $SG(x)>0$.

有向图游戏的某个局面 $x$ 必败，当且仅当 $SG(x)=0$.

证明略

# SG 函数博弈

## 一组小练习

### 练习 1

> 有⼀堆⽯⼦，两个⼈轮流取，每次可以取 $l\sim r$ 个，谁不能动就算输，问谁会获胜。

遇到 SG 函数的题，通常可以打表找规律

⽐如 $l=3, r=7,sg=[0,0,0,1,1,1,2,2,2,3,0,\cdots]$.
$$
sg[i]=\left\lfloor\frac{i\bmod (l+r)}{l}\right\rfloor
$$

### 练习 2

> 有 $n$ 堆⽯⼦。两个⼈轮流取，每次可以在⼀堆⽯⼦⾥⾯选取任意多的⽯头，或者把⼀堆⽯头分裂成两堆。谁不能操作算输。

分裂相当于变成两个独立的游戏，那么这个游戏的 sg 值就是其子游戏的异或值
$$
sg[i]=mex(sg[j],sg[j][text{ xor }sg[i-j])
$$

打表完发现有规律，大概是 $1,2,4,3,5,6,8,7\cdots$.

### 练习 3

> $NIM$ 博弈，每次能拿掉总数量的⼀个因⼦，不能拿本身。

打表代码

```cpp
#include<bits/stdc++.h>
#include<bitset>
using namespace std;

int sg[1000];
bool vis[1000];
int SG(int k){
	if(vis[k])return sg[k];
	vis[k]=1;
	if(k==1)return sg[k]=0;
	bool bit[1000]={0};
	for(int i=1;i<k;i++)if(k%i==0)bit[SG(k-i)]=1;
	for(int i=0;i<1000;i++)if(!bit[i])return sg[k]=i;
}
int main(){
	for(int i=1;i<=20;i++)cout<<SG(i)<<' ';
	return 0;
}

```

打表找规律，发现 $sg$ 是 $i$ 的二进制末尾的 $0$ 的个数

### 练习 4

> $NIM$ 博弈，每次能拿掉与总数量互质的数。

打表代码

```cpp
#include<bits/stdc++.h>
#include<bitset>
using namespace std;

int gcd(int a,int b){return b?gcd(b,a%b):a;}
int sg[1000];
bool vis[1000];
int SG(int k){
	if(vis[k])return sg[k];
	vis[k]=1;
	bool bit[1000]={0};
	for(int i=1;i<=k;i++)if(gcd(i,k)==1)bit[SG(i)]=1;
	for(int i=0;i<1000;i++)if(!bit[i])return sg[k]=i;
}
int main(){
	for(int i=1;i<=20;i++)cout<<SG(i)<<' ';
	return 0;
}
```

规律：偶数是 $0$，$1$ 是 $1$，其他数的 $sg$ 就是最小**质因子**在质数表中的编号。

### 练习 5

> 有⼀个 $1\times n$ 的纸条，两个⼈轮流在格⼦⾥画 $\times$，谁画了连续的三个 $\times$ 获胜。

放了一个后，左右各延伸的两格都放不了，那么左右两边的纸条就是独立的游戏，于是 SG 异或一下就行了（中间的是一个必胜局面，也要作为一个游戏，也就是说一共有 3 个子游戏）

## CF 某题

> 有 $n$ 个数 $1\sim n$, 两个轮流选择数字删除，如果 $x$ 被删除了，那么 $x^2, x^3,\cdots$ 也要被⼀起删除，不能操作的算输。问先⼿必胜还是后⼿必胜。
>
> $n\leq 10^9$.

把每个底数的幂拿出来，就会变成若干独立的游戏，每个游戏只和序列长度有关

例如 $1\sim 40$ 的分组是这样的
$$
\begin{split}
&\{1\},\\
&\{2,2^2,2^3,2^4,2^5\},\{3,3^2,3^3\},\\
&\{5,5^2\},\{6,6^2\},\{7\},\\
&\{10\},\{11\},\{12\},\{13\},\{14\},\{15\},\\
&\{17\},\{18\},\{19\},\{20\},\{21\},\{22\},\\
&\{23\},\{24\},\{26\},\{28\},\{29\},\{30\},\\
&\{31\},\{33\},\{34\},\{35\},\{37\},\{38\},\\
&\{39\},\{40\}\\
\end{split}
$$
每个组内的数删除后，只会影响组内的数，不会影响别的组的数；而每个组又是等比数列，不用考虑底数，所以每个游戏只和序列长度有关。所以计算每个游戏的 sg，记忆化搜索 / 状压打个表就行（根据 $n$ 的范围，只需要把 30 的表打出来）

## PE306

> $1\times n$ 的⻓条，每个⼈轮流拿连续的两个格子，不能拿的算输，求 $sg$ 值。

打表代码如下

```cpp
#include<bits/stdc++.h>
#include<bitset>
using namespace std;

int gcd(int a,int b){return b?gcd(b,a%b):a;}
int sg[1000];
bool vis[1000];
int SG(int k){
	if(k==1)return 0;
	if(k==2)return 1;
	if(vis[k])return sg[k];
	vis[k]=1;
	bool bit[1000]={0};
	for(int i=1;i+2<=k;i++){
		bit[SG(i)^SG(k-i-2)]=1;
	}
	for(int i=0;i<1000;i++)if(!bit[i])return sg[k]=i;
}
int main(){
	for(int i=1;i<=1000;i++)cout<<' '<<SG(i);
	return 0;
}

```

记事本的正确打开方式——拖动找循环节

前几个有 bug，后面的就是循环节（可以在 OEIS 上找到这个序列）

## CF 新年睿智题

> 两个⼩⽼弟玩游戏，有若干⾏，每⾏有三个棋⼦。
>
> Alice 可以选择⼀⾏将左边的 1 或 2 个棋⼦往右移 d 步。Bob 可以将右边的 1 或 2 个棋⼦往左移 d 步，移完之后棋⼦的相对顺序不变，要求 d 是素数或者两个素数的乘积。不能操作算输，问谁能赢。
>
> $10^5$⾏，每⾏棋⼦坐标范围在 $10^5$ 之内。

不同行的游戏是独立的，考虑一行的游戏。表面上两个人的决策集不等，但由于我们不必关系棋子间的具体坐标，我们只关心三个棋子的间距。我们可以把游戏的过程看做三颗棋子往中间靠，直到靠在一起。

因此将右边的 1 枚棋子往左移 d 步等价于右边的间距减少 d；右边 2 枚棋子左移 d 步等价于左边间距减少 d。左边的操作同理。因此这是一个平等博弈。而对两个间距的操作也是独立的，因此我们只需要考虑对一个间距操作的情况：
$$
sg[i]=mex\{sg[i-d]\},d\in S
$$
$S$ 表示可选的 d 的集合。直接计算这个式子，复杂度是 $O(n^2)$.

用 bitset 存 $f[i,j]$ 表示 j 这个位置是否有 sg 值为 $i$ 的后继，or 一下就行

算完异或起来就行（待补）

## SPOJ COT3

> 有⼀个有根树，每次可以选择⼀个节点，然后把它到根的路径全部删除。问谁会赢。
>
> $n<=10^5$.

每次删边后，会分割为若干子树，这样暴力算 $SG[subtree]$ 是 $n^3$ 的。

可以 $O(n^2)$ 实现，即不重复计算 SG 值，删某个点 u 的路径，u 的某个儿子 v 的路径，两者所需要计算的额外的 sg 值都在 v 子树部分，均摊是 $O(1)$ 的，所以可以 $O(n^2)$.

线段树合并、权值线段树可以 $O(n\log_2n)$.（待补）

## [取火柴游戏](https://www.luogu.org/problemnew/show/P1247)

> 输入 $n$ 及 $n$ 个整数 $a_1,a_2,\cdots,a_n$，表示有 n 堆火柴棒，第 i 堆火柴棒的根数为 $a_i$；接着便是你和计算机取火柴棒的对弈游戏。取的规则如下：每次可以从一堆中取走若干根火柴，也可以一堆全部取走，但不允许跨堆取，也不允许不取。不能操作的一方判输。
>
> 判断先手的是否必胜。如果是先取必胜，请输出第一次该如何取。如果是先取必败，则输出“lose”

相当于 n 个独立游戏的和，那么每个游戏算 SG 值（$SG[i]=i$），然后异或即可。对于走的方案，相当于给后手构造一个异或值为 0 的局面即可

```cpp
#include<cstdio>
using namespace std;
const int N=500005;
int k,a[N],tot;
int main(){
	scanf("%d",&k);
	for(int i=1;i<=k;i++)scanf("%d",&a[i]),tot^=a[i];
	if(!tot)return puts("lose"),0;
	for(int i=1;i<=k;i++){
		if((a[i]^tot)<=a[i]){
			printf("%d %d\n",a[i]-(a[i]^tot),i);
			a[i]^=tot;
			for(int i=1;i<=k;i++)printf("%d ",a[i]);
			return 0;
		}
	}
	return 0;
}
```

## [POJ2311]Cutting Game

> 初始时，给出一个 $W\times H$ 的网格，每次可以选择一个网格，沿网格线水平或者垂直切割，将其分为两个更小的网格。谁切出了 $1\times 1$ 的网格谁获胜。问先手是否必胜
>
> $2\leq W,H\leq 200$.

由于 ICG 游戏是以必败局面收尾的，因此思考哪些局面是必败局面。

对于任何一个人，都不会先剪出 $1\times n$ 或者 $n\times 1$，这样必败；同时 $2\times 2$ 的局面也是必败的。SG 函数如下
$$
\begin{split}
SG(m,n)=mex(&\left\{SG(i,m)\text{ xor }SG(n-i,m)\right|2\leq i\leq m-1\}\\
\cup &\left\{SG(n,i)\text{ xor }SG(n,m-i)\right|2\leq i\leq m-2\})
\end{split}
$$

```cpp
#include<cstdio>
#include<cstring>
#include<bitset>
using namespace std;
const int N=505;
int n,m,c[N][N];

int sg(int a,int b){
	if(~c[a][b])return c[a][b];
	bool bit[N]={0};
	for(int i=2;i<=a-i;i++)bit[sg(i,b)^sg(a-i,b)]=1;
	for(int i=2;i<=b-i;i++)bit[sg(a,i)^sg(a,b-i)]=1;
	for(int i=0;i<N;i++)if(!bit[i])return c[a][b]=i;
}
int main(){
	memset(c,-1,sizeof(c));
	while(~scanf("%d%d",&n,&m))puts(sg(n,m)?"WIN":"LOSE");
	return 0;
}
```

## [欧几里德的游戏](https://www.luogu.org/problemnew/show/P1290)

> 给定两个正整数 M 和 N，每次选择其中较大的数，减去较小数的正整数倍，要求得到的数不能小于 0。得到了 0 的人取得胜利。问胜负情况

暴力 SG：
$$
SG(m,n)=mex\{SG(m,n-m),SG(m,n-2m),\cdots,SG(m,n\bmod m)\}
$$
想办法简化计算过程。我们发现
$$
\begin{split}
SG(m,n)=&mex\{SG(m,n-m),SG(m,n-2m),\cdots,SG(m,n\bmod m)\}\\
SG(m,n-m)=&mex\{SG(m,n-2m),\cdots,SG(m,n\bmod m)\}\\
\end{split}
$$
因此，$SG(m,n)$ 可以由 $SG(m,n-m)$ 推导。

对于 $SG(m,n\bmod m+m)=mex\{SG(m,n\bmod m)\}$

当 $SG(m,n\bmod m)=0$，则

$$
SG(m,n\bmod m+m)=1\\
SG(m,n\bmod m+2m)=2\\
SG(m,n\bmod m+3m)=3\\
\cdots
$$

往上依次递增，直到 $SG(m,n)$. 此时为必胜局

当 $SG(m,n\bmod m)\neq 0$，则

$$
SG(m,n\bmod m+m)=0\\
SG(m,n\bmod m+2m)=1\\
SG(m,n\bmod m+2m)=2\\
\cdots
$$

往上依次递增，直到 $SG(m,n)$. 此时视 $n-m=n\bmod m$ 的情况而定。

因此，只需计算 $SG(m,n\bmod m)$ 再加以讨论即可

复杂度 $O(\log_2(n+m))$.

```cpp
#include<cstdio>
using namespace std;
typedef long long ll;
ll t,m,n;
bool sg(ll m,ll n){//m<n
	if(!m)return 0;// 面对 m=0 的局面为负
	if(n-m<m)return !sg(n%m,m);// 如果 sg!=0，则 sg(n,n%m +m)=0
	else return 1;// 不管 sg(n,n%m) 的值，之后都不为 0
}
int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld%lld",&m,&n);
		if(m>n)m^=n^=m^=n;
		puts(sg(m,n)?"Stan wins":"Ollie wins");
	}
	return 0;
}
```

## [SDOI2009] E&D

> 有 $2n$ 堆石子，编号为 $1\sim 2n$。我们将第 $2k-1$ 堆与第 $2k$ 堆 （$1 \leq k \leq n$）视为同一组。第 $i$ 堆的石子个数用一个正整数 $S_i$ 表示。 一次分割操作指的是，从桌子上任取一堆石子，将其移走。然后分割它同一组的另一堆石子，从中取出若干个石子放在被移走的位置，组成新的一堆。操作完成后，所有堆的石子数必须保证大于 0。不能操作的人输掉比赛。问先手是否必胜。

这是多个 ICG 游戏，对于单个游戏 $(a,b)$，相当于有 $(a,b)\Rightarrow (c,d)|c+d=a\vee c+d=b $.

设计 SG 函数如下

```cpp
const int N=100;
int sg[N][N];
bool vis[N][N];
int mex(bitset<N> bit){
	int res=0;
	while(bit[res])res++;
	return res;
}
int SG(int a,int b){
	if(a==1&&b==1)return 0;
	if(vis[a][b])return sg[a][b];
	bitset<N> bit;
	for(int i=1;i<a;i++)bit[SG(i,a-i)]=1;
	for(int i=1;i<b;i++)bit[SG(i,b-i)]=1;
	return mex(bit);
}
```

复杂度 $\sum S_i^2$

利用上述函数打表。因为我们只关心每一个 ICG$(a,b)$ 中，$mex\{SG(c,d)|c+d=a,SG(c,d)|c+d=b\}$，因此对于 $c+d=a$ 的所有 $a$，考虑其对应的 $a-1$ 个 $(c,d)$ 的 SG 值的取值集合（用二进制数表示，右边第一位为 0，往左依次为 0,1,2...）

```cpp
a=1	:00000000000
a=2	:00000000001
a=3	:00000000010
a=4	:00000000011
a=5	:00000000100
a=6	:00000000101
a=7	:00000000110
a=8	:00000000111
a=9	:00000001000
a=10:00000001001
```

发现，关于 a 的 $SG(c,d)$ 集合即为 $a-1$ 的二进制表示中，值为 1 的位，如
$$
\{SG(c,d)|c+d=6\}=\{0,2\}
$$
则
$$
mex\{SG(c,d)|c+d=6\}=1
$$
即二进制下最低位的 0

那么回到一个 ICG 游戏 $(a,b)$ 的初始局面，则利用上述结论，我们取 $(a-1)|(b-1)$ 在二进制表示下最低位的 0 即为 $SG(a,b)$.
$$
\begin{split}
&\{SG(c,d)|c+d=a\}=(a-1)_2\\
&\{SG(c,d)|c+d=b\}=(a-1)_b\\
SG(a,b)&=mex\{SG(c,d)|c+d=a,SG(c,d)|c+d=b\}\}\\
&=mex((a-1)_2,(b-1)_2)\\
&=mex(((a-1)\vee(b-1))_2)
\end{split}
$$
最后异或和一下即可

复杂度 $O(n\log_2S_i)$.

```cpp
#include<cstdio>
#include<bitset>
using namespace std;
int t,n;
int mex(int x){
	int res=0;
	while(x&1)x>>=1,res++;
	return res;
}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		int ans=0;
		for(int i=1,a,b;i<=n;i+=2){
			scanf("%d%d",&a,&b);
			ans^=mex((a-1)|(b-1));
		}
		puts(ans?"YES":"NO");
	}
	return 0;
}
```

# 博弈 DP

## 练习 1

> 给你 $n\times m$ 的⽹格，$(1,x), (x,1)$ 的位置标着移到这个位置的胜负情况，初始时有⼀个在 $(a,b)$ 位置的棋⼦，Alice 和 Bob 轮流移动，每次可以往左或者往上。Alice 先手，求是否有必胜策略
>
> $n,m\leq 10^5$.

考虑 DP，$f[i,j]$ 表示走到 $(i,j)$ 的胜负情况
$$
f[i,j]=not(f[i,j-1][text{ and }f[i-1,j])
$$
方程的含义是，如果 $f[i,j-1]$ 与 $f[i-1,j]$ 都是必胜态的话，那么当前的 $(i,j)$ 对于当前的执行者就是必败态；反之当任意一个不是必胜态时亦然。最后状态取反。

打表找规律，发现除了前三行前三列的 DP 值，其他的主对角线上的胜负状态是一样的

## AGC 002E

> 有 $n$ 堆糖，Alice 和 Bob 轮流操作。可以吃完最⼤的⼀堆，也可以每堆吃⼀个。问谁能赢。
>
> $n<=10^5, a_i<=10^9$.

放在二维方格上表示，相当于每次可以横着切一片或者竖着切一片，可以看做往右走和往上走

![p1](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/03/07/1428.png)

那么同样可以用二维 dp 来做
$$
dp[i,j]=not (dp[i+1,j] \text{ and } dp[i,j+1])
$$

把每一列的**顶上**两三个的 DP 值求出来，发现剩下的主对角线上的状态相等

## K 倍动态减法游戏

> 有⼀个整数 $S(S\geq 2)$，先⾏者在 S 上减掉⼀个数 x，⾄少是 1，但⼩于 S。
>
> 之后双⽅轮流把 S 减掉⼀个正整数，但都不能超过先前⼀回合对⽅减掉的数的 k 倍，减到 0 的⼀⽅获胜。问先手是否必胜
>
> $S<=10^6$.

考虑暴力 $DP$.

$f[i,j]$ 表示当前数字是 $i$，能减的数字是 $1\sim j$：
$$
f[i,j]=not(\text{and }_{a=1}^jf[i-a,ka])
$$
暴力是 $O(n^3)$ 的

这东西在第二维上是单调递增（非严格）的（$j$ 能赢，$j+1$ 也能赢），那么令 $g[i]$ 表示在 $i$ 的情况下什么时候开始赢（最后一个输位置）

由于 $f[i,g[i]]\leftarrow not(\text{ and }_{a=1}^{g[i]}f[i-a,ka])$. 即这些状态必胜，它才会输。那么可以暴力枚举判断

而决策点集 $(i-a,ka)$ 其实是在斜率 $\frac{1}{k}$ 的直线上的决策点（注意纵轴是第一关键字，所以斜率为倒数），相当于从下往上发射激光一样，碰到 0 就结束。那么单调栈扫一遍即可？

![p1](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/03/09/2023.png)

# 阶梯 NIM

> 有 $n$ 堆⽯⼦。两个⼈轮流取，每次可以在第 $i$ 堆⽯⼦⾥⾯选取若⼲⽯头放到 $i-1$ 堆⾥⾯。谁不能操作（即只剩一堆）算输。

移动奇数编号第 $x$ 堆的石子到 $x-1$ 堆，下一个人可以模仿他的行为，把他动的那些石子从 $x-1$ 继续移到 $x-2$ 上（因为是奇数，保证存在 $x-2$），且先后手关系不变

因此只用考虑偶数堆的异或和是否为 $0$.（为 0 则必败）

# 博弈杂题

## 经典题

> 你有⼀个⽆向图，Alice 和 Bob 轮流移棋⼦，不能移到走过的点上。
> 问先⼿是否必胜。

在点 u 上，先手必败当且仅当存在最大匹配的方案，不包含结点 u。

略证如下：如果存在最大匹配的方案且该方案不包含结点 u，那么先手从 u 出发，一定会走到一个匹配点 v（如果 v 不是匹配点的话，那么 $(u,v)$ 可以形成一个匹配，则与最大匹配矛盾），于是后手沿着匹配边走，先手只能沿非匹配边走。最后一定会以匹配边结束，使得先手没有非匹配边可走（如果仍存在可走的非匹配点的话，那么 $(u,v)$ 和这条边都是非匹配边，可以构成增广路，与最大匹配的条件矛盾），于是先手必败。

反之亦然，必胜的条件即该图的**任意最大匹配**都包含 u，那么先手可以走匹配边，后手走非匹配边，最后一定以匹配边结束（如果以非匹配边结束，那么我们可以把走的路径上的匹配边移到与它紧邻的下一个非匹配边，于是可以构造一个最大匹配，不包含结点 u。与条件矛盾），于是后手必败。

那么跑图的最大匹配即可（不一定是二分图，这里只是一个算法思路，重点在于博弈胜负的判定证明）

## [NOIP2010] 三国游戏

人选的一定 max（每一行的次大的默契值）.

### 证明

我们先选 max（每一行的次大的默契值）对应的那一行的武将

这时，计算机会把**这一行最大的默契值（记为 max）**对应的另一个武将选走，**双方都不能拿到**最大的默契值

然后人把**max（每一行的次大的默契值）**对应的另一个武将选择，配出**max（每一行的次大的默契值）**，记为 x

注意，人已经配出了**max（每一行的次大的默契值）**，这是事实。显然 $x<max$

那么接下来，计算机选择的武将将会配出一对默契值（记为 y）。而 $y<x$。使用反证法：

- 如果 $max<y$，那么有 $x<max<y$，而 $max,y$ 都与计算机选的第一个武将有关，两者在同一列（行），因此**max（每一行的次大的默契值）**就应该为 $max$ 而不是 $x$，矛盾
- 如果 $x<y<max$，则**max（每一行的次大的默契值）**为 $y$，矛盾

同样的，既然计算机的先手拆散没有意义 $(y<x)$，则人转变为先手，继续按上述策略配出每行次大的默契值，同时把每行最大的默契值拆掉即可

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=502;
int n,a[N][N],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++)scanf("%d",&a[i][j]),a[j][i]=a[i][j];
	}
	for(int i=1;i<=n;i++){
		sort(a[i]+1,a[i]+n+1);
		ans=max(ans,a[i][n-1]);
	}
	printf("1\n%d",ans);
	return 0;
}
```
