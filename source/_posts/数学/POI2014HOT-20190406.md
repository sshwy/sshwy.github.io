---
title: '[POI2014]HOT-Hotels'
mathjax: true
abbrlink: 33897
categories:
  - 数学
date: 2019-04-06 08:27:42
updated: 2019-04-06 08:27:42
tags:
 - POI
keywords:
---


**摘要**

题意：一颗无根树，每条边长度相同。选3个点两两距离相等，有多少种方案？$n\leq 5000$.


<!--more-->

不难证明三条路径交汇于一个中心点。以这个中心点为根的话，那么这三个结点深度相同。于是我们枚举根节点，并统计每一个深度的结点数（注意，这三个点要分布在不同的根节点下的一级子树中），然后统计一下即可.

统计的关键过程是，对于$a_1,a_2,\cdots,a_n$统计
$$
\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=j+1}^na_ia_ja_k
$$

考虑我们已经完成了$a_1,a_2,\cdots,a_{n-1}$的统计，那么对于$a_n$就会累加
$$
a_n\cdot\sum_{i=1}^n\sum_{j=i+1}^na_ia_j
=a_n\cdot\frac{1}{2}\left[\left(\sum_{i=1}^na_i\right)^2-\sum_{i=1}^na_i^2\right]
$$

于是维护一下前缀和和平方和即可，总复杂度$O(n^2)$.

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e3+5;
int n,ans,c[N];
vector<int> a[N];

struct qxx{int nex,t;};
qxx e[N*2];
int h[N],cnt=1;
void add_path(int f,int t){e[++cnt]=(qxx){h[f],t},h[f]=cnt;}

void calc(int u,int p,int dep,int* a){
	++a[dep];
	for(int i=h[u];i;i=e[i].nex)if(e[i].t!=p)calc(e[i].t,u,dep+1,a);
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%lld%lld",&u,&v);
		add_path(u,v),add_path(v,u);
	}
	for(int u=1;u<=n;u++){//以u为中心点
		for(int i=1;a[i].size();i++)a[i].clear();
		for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t;
			memset(c,0,sizeof(c));
			calc(v,u,1,c);//v的深度为1,结果记录在c中
			for(int i=1;c[i];i++)a[i].push_back(c[i]);
		}
		for(int i=1;a[i].size();i++){
			if(a[i].size()<3)continue;//没有贡献
			int s=a[i][0]+a[i][1],s2=a[i][0]*a[i][0]+a[i][1]*a[i][1];
			for(int j=2;j<a[i].size();j++){
				ans+=a[i][j]*(s*s-s2)/2;
				s+=a[i][j],s2+=a[i][j]*a[i][j];
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

extra:加强版用长链剖分做？？？