---
title: 组合数漫谈
categories:
  - 数学
tags:
 - 数论
 - 组合数
mathjax: true
abbrlink: 53520
date: 2018-12-21 13:56:00
updated: 2019-06-25 22:00:00
---

# 排列与组合

在考虑一类计数问题的过程中，我们常常会遇到讨论排列或者组合的问题。

## 排列数

从 n 个不同元素中，任取 m 个元素按照一定的顺序排成一列，叫做从 n 个不同元素中取出 m 个元素的一个排列；从 n 个不同元素中取出 m 个元素的所有排列的个数，叫做从 n 个不同元素中取出 m 个元素的排列数，用符号 A(n,m）表示。
$$
A_n^m=\frac{n!}{m!(n-m)!}
$$

## 组合数

从 n 个不同元素中，任取 m 个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个组合；从 n 个不同元素中取出 m 个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。
$$
C_n^m=\frac{A_n^m}{m!}=\frac{n!}{m!(n-m)!}\\
C_n^m=C_{n-1}^{m-1}+C_{n-1}^m
$$

组合数也常用 $\binom{n}{m}$ 表示，即 $C_n^m=\binom{n}{m}$（注意他们是上下颠倒的）这个符号其实称作二项式系数的符号，与下文二项式定理有关。

另外，我们认为当 $m>n$ 时，$A_n^m=C_n^m=0$。

## 多重集的排列数

多重集是指包含重复元素的广义集合。设 $S=\{n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k,\}$ 表示由 $n_1$ 个 $a_1$，$n_2$ 个 $a_2$，…，$n_k$ 个 $a_k$ 组成的多重集，S 是全排列个数为
$$
\frac{n!}{\prod_{i=1}^kn_i!}
$$
相当于把相同元素的排列数除掉了。

## 多重集的组合数 1

设 $S=\{n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k,\}$ 表示由 $n_1$ 个 $a_1$，$n_2$ 个 $a_2$，…，$n_k$ 个 $a_k$ 组成的多重集。那么对于整数 $r(r<n_i,\forall i\in[1,k])$，从 S 中选择 r 个元素组成一个多重集的数量是
$$
C_{k+r-1}^{k-1}=\binom{k+r-1}{k-1}
$$
这其实是一个超级弱化版的多重集组合数。证明就是插板法。

## 多重集的组合数 2

上述推论的 r 的范围太过局限。而我们知道对于所取的数是有限制的。假设我们取 $x_i$ 个 $a_i$，那么显然有
$$
\forall i\in [1,k],\ x_i\le n_i
$$
而我们总共取 r 个，意味着
$$
\sum_{i=1}^kx_i=r
$$
本质上我们要求这个方程的非负整数解的个数。于是很自然地想到了容斥原理。容斥的模型如下：

1. 全集：$\sum_{i=1}^kx_i=r$ 的非负整数解
2. 属性：$x_i\le n_i$。

于是设满足属性 i 的集合是 $S_i$，$\overline{S_i}$ 表示不满足属性 i 的集合，即满足 $x_i\ge n_i+1$ 的集合。那么答案即为
$$
\left|\bigcap_{i=1}^kS_i\right|=|U|-\left|\bigcup_{i=1}^k\overline{S_i}\right|
$$
一个赤裸裸的容斥！于是得到
$$
\begin{array}{l}
\left|\bigcup_{i=1}^k\overline{S_i}\right|

&=&\sum_i\left|\overline{S_i}\right|
-\sum_{i,j}\left|\overline{S_i}\cap\overline{S_j}\right|
+\sum_{i,j,k}\left|\overline{S_i}\cap\overline{S_j}\cap\overline{S_k}\right|
-\cdots
+(-1)^{k-1}\left|\bigcap_{i=1}^k\overline{S_i}\right|\\

&=&\sum_i\binom{k+r-n_i-2}{k-1}
-\sum_{i,j}\binom{k+r-n_i-n_j-3}{k-1}+\sum_{i,j,k}\binom{k+r-n_i-n_j-n_k-4}{k-1}
-\cdots\\
&&+(-1)^{k-1}\binom{k+r-\sum_{i=1}^kn_i-k-1}{k-1}
\end{array}
$$
于是拿全集 $|U|=\binom{k+r-1}{k-1}$ 减去上式，得到多重集的组合数为
$$
\sum_{p=0}^k(-1)^p\sum_{A}\binom{k+r-1-\sum_{A} n_{A_i}-p}{k-1}
$$
其中 A 是充当枚举子集的作用，满足 $|A|=p,\ A_i<A_{i+1}$。

# 二项式定理

好吧，多重集组合数扯得有点远了。来讲一个家喻户晓的东西。二项式定理就是一个展开式：
$$
(a+b)^n=\sum_{i=0}^n\binom{n}{i}a^{n-i}b^i
$$

证明？数学归纳法。本质就是利用了 $\binom{n}{k}+\binom{n}{k-1}=\binom{n+1}{k}$ 做归纳。

# 一些推论

接下来介绍一些和组合数相关的推论与扩展。

## 关于二项式定理的扩展

取 $a=b=1$，得到
$$
\sum_{i=0}^n\binom{n}{i}=2^n
$$
取 $a=1,b=-1$ 得到
$$
\sum_{i=0}^n\binom{n}{i}(-1)^i=0
$$

## 关于组合数的推论

我们知道 $\binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}$，那么可以推出这样两个结论：
$$
\sum_{i=0}^k\binom{n+i-1}{i}=\binom{n+k}{k} \\
\sum_{i=0}^k\binom{n-1+i}{n-1}=\binom{n+k}{n}
$$

简单来说，底数与顶数同时递增，或者底数递增的组合数求和式子是可以合并的。

怎么证明？差分。也叫裂项。

由 $\binom{n-1}{m}=\binom{n}{m}-\binom{n-1}{m-1}$，于是推出
$$
\binom{n+i-1}{i}=\binom{n+i}{i}-\binom{n+i-1}{i-1}
$$
于是这就变成了与 i 和 i-1 有关的式子。算一下求和式子就发现中间的都抵消了。

对于第而个式子，我们有 $\binom{n-1}{m-1}=\binom{n}{m}-\binom{n-1}{m}$，于是得到
$$
\binom{n-1+i}{n-1}=\binom{n+i}{n}-\binom{n+i-1}{n}
$$
于是这又是一个裂项相消的式子。
$$
\binom{-b}{n}=\frac{-b(-b-1)(-b-2)\cdots(-b-n+1)}{n!}\\
=\binom{b+n-1}{n}(-1)^n\\
\binom{a+b}{n}=\sum_{i=0}^n\binom{a}{i}\binom{b}{n-i}\\
\binom{2n}{n}=\sum_{i=0}^n\binom{n}{i}^2
$$

# 计算组合数 $\binom{n}{m}\bmod p$

## Subtask1

$n,m\leq 5000$。
$$
\binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}
$$
时间复杂度 $O(n^2)$。

## Subtask2

$n,m\leq 10^7,p$ 是质数。

费马小定理求逆元，将除法转化为乘法即可。

时间复杂度 $O(n+\log_2p)$。

## Subtask3

$n,m\leq 10^{18},p\leq 10^6$, 是质数。

lucas 定理：p 为质数时，

$$
\binom{n}{m}\equiv  \binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor\frac{m}{p}\right\rfloor}\binom{n\bmod p}{m\bmod p} \mod p
$$

转化为 Subtask2，时间复杂度 $O(p+log_2p)$。

## Subtask4

$n,m\leq 10^6,p\leq 10^9$。

分解质因数：
$$
\binom{n}{m}=\frac{n!}{m!(n-m)!}=\prod_{i=1}^k{p_i}^{c_i}
$$

在 $n!$ 中，质因子 p 的出现次数为：

$$
f(n)=\left\lfloor\frac{n}{p}\right\rfloor+\left\lfloor\frac{n}{p^2}\right\rfloor+...+\left\lfloor\frac{n}{p^\infty}\right\rfloor
$$

则在 $\binom{n}{m}$ 中 p 出现的次数为 $f(n)-f(m)-f(n-m)$。最后剩下的质数相乘即可。

复杂度
$$
O\left(\sum_{p\le n,\ p\text{ is a prime}}\log_pn\right)\le O\left(\frac{n}{\ln n}\times \ln n\right)=O(n)
$$

## Subtask5

$n,m\le 10^9,p^e\le 10^6$，求$\binom{n}{m}\bmod p^e$。



## Subtask6

$n,m\le 10^{18},p\leq 10^9$，$p$是质数。

先Lucas，然后分块打表。
$$
\binom{n}{m}=\frac{n!}{m!(n-m)!}
$$

设块大小为T，大力打个表计算 $T!,(2T)!,(3T)!,\dots$，打完表后，计算$n!$的复杂度就是$O(T)$的。空间复杂度$O\left(\frac{N}{T}\right)$。

令 $T=\sqrt{n}$, 则时空复杂度为 $O(\sqrt{n})$。

# LG2822 组合数问题

> 分解质因数 $k=\prod{p_i}^{c_i}$ 
>
> 对于一个 $C_i^j=\frac{i!}{j!(i-j)!}$，统计 $p_i$ 在 $i!$ 中的幂次数。

同理，求出分子分母的 $p_i$ 幂次差，可判断能否被 ${p_i}^{c_i}$ 整除。因此对于一个组合数的判断，复杂度 $O(log_2k)$。

然后矩阵前缀和从 $C_{i-1}^j$ 和 $C_i^{J-1}$ 推到 $C_I^j$ 即可

总复杂度 $O(nm)$.

```cpp
#include<cstdio>
#include<algorithm>
#define FOR(a,b,c) for(int a=b;a<=c;a++)
using namespace std;
const int N=2003,M=2003;
int t,k,ans,n,m;
int p[20],c[20],cnt;// 分解质因数
int sum[N][M];//sum[i,j]:n=i,m=j 时的解
bool v[N][M];
int f(int x,int p){//x! 含有 p 的幂次数
	int res=0;
	while(x)res+=x/p,x/=p;
	return res;
}
int F(int a,int b){
    if(a*b==0)return 0;//1%k!=0
	if(a<b)return F(a,a);
	if(v[a][b])return sum[a][b];
	sum[a][b]=v[a][b]=1;
	FOR(i,1,cnt)sum[a][b]&=(f(b,p[i])+f(a-b,p[i])+c[i]<=f(a,p[i]));
	sum[a][b]+=F(a,b-1)+F(a-1,b)-F(a-1,b-1);// 矩阵前缀和
	return sum[a][b];
}
int main(){
    scanf("%d%d",&t,&k);
	for(int i=2;i*i<=k;i++){
        if(k%i==0)cnt++,p[cnt]=i;
		while(k%i==0)c[cnt]++,k/=i;
	}
	if(k!=1)p[++cnt]=k,c[cnt]++;// 分解质因数
	while(t--){
        scanf("%d%d",&n,&m);
		printf("%d\n",F(n,m));
	}
	return 0;
}
```

# Lucas 定理

用于求解 $C_n^m\bmod p$（p 是质数）的问题。
$$
\binom{n}{m}\equiv \binom{\left\lfloor x/p\right\rfloor}{\left\lfloor y/p\right\rfloor}\cdot\binom{x\bmod p}{y\bmod p}\ (\bmod p)
$$

# LG3807 卢卡斯定理

就这道题的数据范围还用不到 Lucas

不过鉴于是模板，姑且用一用。

原理是
$$
C_n^m=\frac{n!}{m!(n-m)!}=\frac{\prod_{i=n-m+1}^ni}{(n-m)!}=(n-m)!^{-1}\cdot \prod_{i=n-m+1}^ni
$$
费马小定理求逆元即可

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100005;
int n,m,p;
int ksm(int a,int x){
	int res=1;
	while(x){
        if(x&1)res=(long long)res*a%p;
		a=(long long)a*a%p,x>>=1;
	}
	return res;
}
int c(int a,int b){
    if(a>p||b>p)return c(a/p,b/p)*c(a%p,b%p)%p;
	if(a<b)return 0;
	if(b==0)return 1;
	b=min(b,a-b);
	int ps=1,qs=1;
	for(int i=a;i>a-b;i--)ps=(long long)ps*i%p;
	for(int i=1;i<=b;i++)qs=(long long)qs*i%p;
	qs=ksm(qs,p-2);
	return (long long)ps*qs%p;
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
        scanf("%d%d%d",&n,&m,&p);
		printf("%d\n",c(n+m,m));
	}
	return 0;
}
```
# NOIP2011 计算系数

$$
ans=a^nb^mC_k^n
$$

组合数可以 $O(n^2)$ 递推

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int P=10007;
int a,b,k,m,n,ans=1;
int C[1003][1003];
int c(int x,int y){
    return y>x?0:(y==0?1:(C[x][y]?C[x][y]:(C[x][y]=(c(x-1,y-1)+c(x-1,y))%P)));
}
signed main(){
    scanf("%lld%lld%lld%lld%lld",&a,&b,&k,&n,&m);
	a%=P,b%=P;
	for(int i=1;i<=n;i++)ans=ans*a%P;
	for(int i=1;i<=m;i++)ans=ans*b%P;
	printf("%lld",c(k,n)*ans%P);
	return 0;
}
```

# SP5973 SELTEAM - Selecting Teams

n 个人里面选 k 个人的方案数为 $C_n^k$，则 k 个人中选一个做队长，剩下的人有 $2^{k-1}$ 种选法，答案即为
$$
k\cdot 2^{k-1}\cdot C_n^k
$$
而 $8388608=2^{23}$，进一步简化代码；

```cpp
#include<bits/stdc++.h>
#define P 8388608
using namespace std;
typedef long long ll;
ll T,n,k,c[100001][30];
ll C(ll a,ll b){
    if(a<b)return 0;
	if(b==0)return 1;
	if(c[a][b])return c[a][b];
	return c[a][b]=(C(a-1,b-1)%P+C(a-1,b)%P)%P;
}
int main(){
    scanf("%d",&T);
	while(T--){
        scanf("%d%d",&n,&k);
		if(k>24)k=24;
		ll sum=0;
		for(ll m=1;m<=k;m++){
            sum+=(C(n,m)*m%P)*((1<<(m-1))%P)%P;
			sum%=P;
		}
		printf("%d\n",sum);
	}
	return 0;
} 
```

# SCOI2010 生成字符串

在坐标系中，把 1 当做向右 1 单位，0 当作像上 1 单位

如果一个字符串中 0 的个数多余 1 的个数，则有 $n_k<m_k$，则 $(n_k,m_k)$ 必在 $y=x$ 的上方

即题目要求从 $(0,0)$ 走到 $(n,m)$，不走到 $y=x$ 上方的情况下的方案数

如果不考虑 01 的个数，则从 $(0,0)$ 走到 $(n,m)$ 的方案数为 $C_{n+m}^m=C_{n+m}^n$.

接下来考虑走到 $y=x$ 上方的方案数

我们将 $(n,m)$ 沿 $y=x+1$ 翻折到 $(m-1,n+1)$，如果你走到了 $(m-1,n+1)$，那么你必然走到了 $y=x$ 的上方；把路径翻折回去，就是走到 $y=x$ 上方的一条路径；方案数为 $C_{m+n}^{m-1}=C_{m+n}^{n+1}$.

于是答案即为 $C_{n+m}^m-C_{n+m}^{m-1}$.

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int P=20100403;
int n,m;
int ksm(int a,int m){
	int res=1;
	while(m){
        if(m&1)res=(long long)res*a%P;
		a=(long long)a*a%P,m>>=1;
	}
	return res;
}
int c(int a,int b){
    if(b>a)return 0;
	b=min(b,a-b);
	int res=1,p=1;
	for(int i=a-b+1;i<=a;i++)res=(long long)res*i%P;
	for(int i=1;i<=b;i++)p=(long long)p*i%P;
	res=(long long)res*ksm(p,P-2)%P;
	return res;
}
int main(){
    scanf("%d%d",&n,&m);
	printf("%d",((c(n+m,m)-c(n+m,m-1))%P+P)%P);
	return 0;
}
```

