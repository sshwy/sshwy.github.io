---
title: 初等数论小结
categories:
  - 数学
mathjax: true
abbrlink: 52170
date: 2019-01-26 12:32:15
updated: 2019-05-01 15:29:15
tags:
---


**摘要**

复习一下数论


<!--more-->

# 复杂度符号的说明

## 大 $\text{O}$ 符号

当且仅当存在正实数 $M$ 和实数 $x_0$，使得
$$
\forall x\geq x_0,\\|f(x)|\leq M|g(x)|
$$
我们就可以认为，$f(x)=O(g(x))$.

## 大 $\Omega$ 符号

当且仅当存在正实数 $M$ 和实数 $x_0$，使得
$$
\forall x\geq  x_0,\\f(x)\geq Mg(x)
$$
我们就可以认为，$f(x)=\Omega (g(x))$.

大 $\text{O}$ 与大 $\Omega$ 恰好相反，即 $f(x)=\text{O}(g(x))\Leftrightarrow g(x)=\Omega(f(x))$.

## 大 $\Theta$ 符号

大 $\Theta$ 符号是大 $\text{O}$ 和大 $\Omega$ 的结合，即
$$
\left.\begin{split}
f(x)=\text{O}(g(x))\\
f(x)=\Omega(g(x))
\end{split}\right\}
\Rightarrow f(x)=\Theta(g(x)).
$$

# 质数相关

## 质数的分布

$n$ 以内质数的个数为 $\pi(n)$.
$$
\pi(n)\approx \frac{n}{\ln n}
$$

## 质数的判定

从 $2\sim \sqrt{n}$ 枚举判断，复杂度 $\Theta(\sqrt{n})$.

枚举了 $2$ 以后，就只用枚举之后的奇数了，复杂度 $\Theta\left(\frac{\sqrt n}{2}\right)$.

### 引理

关于质数分布的规律：大于等于 5 的质数一定和 6 的倍数相邻

### 证明

将大于等于 5 的自然数表示为 $6k,6k+1,6k+2,6k+3,6k+4,6k+5,k\in\mathbb{Z}$.

那么 $2|6k+2,6k+4$，$3|6k,6k+3$，则只用判断 $6k+1,6k+5$.

因此复杂度为 $\Theta\left(\frac{\sqrt n}{3}\right)$.

# 整数唯一分解定理

任何正整数都能被唯一表示成一些素数的幂的乘积：
$$
\exists!c_i>0,x=\prod_{i=1}^\infty {p_i}^{c_i}
$$


Pollard-Rho 分解质因数，$O(n^\frac{1}{4})$.，Floyd，Blent 找环算法

同余的定义，剩余类的定义；最小剩余系，简化剩余系

# 乘法逆元

如果 $gcd(b,m)=1$，那么存在 $b^{-1}$，使得 $b^{-1}b\equiv 1 (\bmod m)$，则 $b^{-1}$ 是 $b$ 的乘法逆元。

即：$gcd(b, m)=1$ 时 $\frac{a}{b}\equiv ab^{-1}(\bmod m)$。在模 p 的意义下，每一个整数 a 有唯一乘法逆元。

## 扩欧求逆元

因为 $gcd(b,m)=1,b^{-1}b\equiv 1 (\bmod m)$，即 $b^{-1}b=mk+1$，$b^{-1}b-mk=1=gcd(b,m)$。于是 EXGCD 算法即可，时间复杂度 $O(\log_2n)$.

```cpp
int inv(int a,int p){
	int b,t;
	int g=exgcd(a,p,b,t);
	if(g!=1)return -1;
	return b;
}
```

## 线性递推 $n^{-1}$

**有关线性求区间逆元的算法通常需要 p 为质数**

**在模 p 意义下**

$1^{-1}=1$

假定已知 $\left\{1^{-1},2^{-1},3^{-1}\cdots ,(k-1)^{-1}\right\}$ 求 $k^{-1}$，利用数学归纳法：

$$
\begin{split}
&p=ak+b(0\leq b<k),b\cdot b^{-1}=1\\
&b\cdot b^{-1}=(p-ak)b^{-1}=-akb^{-1}=1\\
&k(-ab^{-1})=1\\
&k^{-1}=-ab^{-1}=- \left\lfloor\frac{p}{k}\right\rfloor {(p\bmod k)}^{-1}
\end{split}
$$

以此递推即可

```cpp
int inv[N];
void inv2(int n,int p){
	inv[1]=1;
	for(int i=2;i<=n;i++){
		inv[i]=-(p/i)*inv[p%i];
		inv[i]=(inv[i]+p)%p;
	}
}
```

## 线性递推求 $1!^{-1}\sim n!^{-1}$

逆元被称为模意义下的倒数（模倒数），所以在模意义下，$(i-1)!^{-1}=\frac{1}{(i-1)!}=\frac{i}{i!}=i!^{-1}i$

```cpp
int inv[N];
void inv3(int n,int p){//1!-n! p is primeNum
	int fac[N];
	fac[0]=1;
	for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%p;
	inv[n]=ksm(fac[n],p-2,p);
	for(int i=n;i>1;i--)inv[i-1]=inv[i]*i%p;
}
```
费马小定理，欧拉定理

# 线性同余方程组求解

$$
\left\{\begin{matrix}
x \equiv a_1(\bmod m_1)\\
x \equiv a_2(\bmod m_2)\\
\vdots \\
x \equiv a_n(\bmod m_n)\\
\end{matrix}\right.
$$

如果 $m_i$ 两两互质的话可以考虑中国剩余定理。更通用的方法是两两合并
$$
\begin{split}
&\left\{\begin{matrix}
x \equiv a_1(\bmod m_1)\\
x \equiv a_2(\bmod m_2)\\
\end{matrix}\right.
\Leftrightarrow
\left\{\begin{matrix}
x = a_1+pm_1\\
x = a_2+qm_2\\
\end{matrix}\right.
\\
&\Leftrightarrow a_1+pm_1= a_2+qm_2\\
&\Leftrightarrow pm_1-qm_2= a_2-a_1\\
\end{split}
$$
扩欧求解 $p,q$，反解出 $x$ 即可

# BSGS

即 Baby-Step-Giant-Step 算法，可以高效求解线性同余方程

$$
a^x≡b (\bmod p)
$$

（$a,b$ 和 $p$ 互质）.

令 $x=i\cdot m-j$，得到

$$
a^{i\cdot m-j}\equiv b(\bmod p)\\
a^{im}\equiv b\cdot a^j (\bmod p)
$$

通过枚举 $j(0\leq j<m)$ 的值，可用快速幂求出 $(b\cdot a^j)\bmod p$ 的值。

建立一个哈希表 h，$h[(b\cdot a^j)\bmod p]=j$，用于 $O(1)$ 的查询。继续，从小到大枚举 $i$ 的值 $(1\leq i\leq m)$，计算出的 $a^{im}$ 在哈希表中查询到的第一个数即可组成答案。

显然，在枚举 $i,j$ 的时候，都以 $m$ 的值为限定。如何界定 $m$ 的值呢？先考虑 $x$ 的取值范围。

当 $gcd(a,p)=1$. 由欧拉定理，有 $a^\varphi(p)\equiv 1 (mod p)$.
- 所以对 $im$ 取 $\varphi(p)$ 的模，得 $im<\varphi(p)$，所以 $x<\varphi(p)$.
- 所以 $im-j<\varphi(p)$, 可得 m 的最合适值为 $\left\lceil \sqrt{\varphi(p)} \right\rceil$. 于是枚举 $i,j$ 即可。

## exBSGS

当 $a,b$ 与 $p$ 不互质？

设 $d_1=gcd(a,p)$，若 $d_1\nmid b$，显然原方程无解；否则两边同时除以 $d_1$：
$$
\frac{a}{d_1}a^{x-1}≡\frac{b}{d_1} \left(\bmod \frac{p}{d_1}\right)
$$

如果 $a$ 和 $\frac{p}{d_1}$ 仍不互质就再除
$$
d_2=gcd\left( a,\frac{p}{d_1} \right)\\
\frac{a^2}{d_1d_2}a^{x-2}≡\frac{b}{d_1d_2} \left(\bmod \frac{p}{d_1d_2}\right)
$$
直到 $a$ 和 $\frac{p}{\prod_{i=1}^kd_k}$ 互质，那么式子长这样
$$
\frac{a^k}{\prod_{i=1}^kd_k}a^{x-k}\equiv\frac{b}{\prod_{i=1}^kd_k} \left(\bmod \frac{p}{\prod_{i=1}^kd_k}\right)
$$
因为 $gcd\left (a,\frac{p}{\prod_{i=1}^kd_k}\right)=1$，所以易证
$$
gcd\left(\frac{a^k}{\prod_{i=1}^kd_k},\frac{p}{\prod_{i=1}^kd_k}\right)=1
$$
那么前者有逆元，所以 $a^{x-k}$ 的系数消掉了，直接 BSGS 即可

## BZOJ3239

测试数据比较水，不保证 exbsgs 的正确性，不过 bsgs 的正确性可以保证

```cpp
//BZOJ3239
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int exgcd(int a,int b,int &x,int &y){
	if(!b)return x=1,y=0,a;
	int g=exgcd(b,a%b,y,x);
	return y=y-x*(a/b),g;
}
int inv(int a,int p){// 求逆元
	int b,t;
    int g=exgcd(a,p,b,t);
	if(g!=1)return -1;
	return ((b%p)+p)%p;
}
const int SZ=2e6;
struct hash_map{// 哈希表模板
	struct data{int u,v,nex;};
	data e[SZ<<1];
	int h[SZ],cnt;
	int hash(int u){return u%SZ;}
	int & operator[](int u){
		int hu=hash(u);
		for(int i=h[hu];i;i=e[i].nex)if(e[i].u==u)return e[i].v;
		return e[++cnt]=(data){u,-1,h[hu]},h[hu]=cnt,e[cnt].v;
	}
	void init(){cnt=0;memset(h,0,sizeof(h));}
};
int pow(int a,int m,int p){// 快速幂
	int res=1;
	while(m){
		if(m&1)res=(long long)res*a%p;
		a=(long long)a*a%p,m>>=1;
	}
	return res;
}
hash_map h;
int bsgs(int a,int b,int p){
	int t=sqrt(p),cur=b;// 分块大小
	h.init();
	for(int i=0;i<t;i++)h[cur]=i,cur=(long long)cur*a%p;
	cur=pow(a,t,p);
	int tot=1;
	for(int i=0;i<=t;i++){
		if(h[tot]!=-1&&i*t>=h[tot])return i*t-h[tot];
		tot=(long long)tot*cur%p;
	}
	return -1;
}
int exbsgs(int a,int b,int p){
	int g=gcd(a,p),k=0;
	long long cq=1,ia;//a 的分母系数，a 的逆元
	while(g!=1){
		if(b%g)return -1;// 无解
		cq=cq*g%p,k++;// 迭代次数 +1
		b/=g,p/=g,g=gcd(a,p);
	}
	ia=inv(a,p);
	for(int i=1;i<=k;i++)cq=cq*ia%p;// 系数的逆元
	b=b*cq%p;
	return bsgs(a,b,p)+k;
}
signed main(){
	int a,b,p;
	while(~scanf("%d%d%d",&p,&a,&b)){
		int ans=exbsgs(a,b,p);
		if(ans==-1)puts("no solution");
		else printf("%d\n",ans);
	}
	return 0;
}
```



# 二次剩余

对于模数 $n$, 整数 $a$, 若存在整数 $x$, 满足 $x^2 \equiv a (\bmod n)$，则称 $a$ 是模 $n$ 意义下的二次剩余，否则是非二次剩余。一个模奇素数 $p$ 意义下的二次剩余 $n$, 有 $2$ 个不同的 $x$ 满足 $x^2 \equiv a(\bmod p)$.

## 欧拉判别法

对于奇素数 $p,a$ 是模 $p$ 意义下的二次剩余当且仅当
$$
a^{\frac{p-1}{2}}\equiv1(\bmod p)
$$

## Cipolla 算法

CIpolla 算法用于求具体的 $x$.

首先随机一个 $a$ 满足 $(a^2-n)^{\frac{p-1}{2}}\equiv-1(\bmod p)$. 期望次数为 2.

设 $\omega=\sqrt{a^2-n}$，由于不存在，扩域设其为虚根

则 $(a+\omega)^{\frac{p-1}{2}}$ 是一个符合条件的 $x$.

## 例题 1

> 给一个大数 n, 问 n 是否是一个完全平方数。$n\leq10^{100000}$.

随机一些质数判是否存在二次剩余

# 阶与原根

## 阶

如果 $(a,m)=1$，记 $x$ 为最小的正整数使得 $a^x\equiv 1(\bmod m)$.

那么 $x$ 称为 $a\bmod m$ 的阶。

根据欧拉定理，$a^{\varphi(m)}\equiv 1(\bmod m)$.

因此 $x|\varphi(m)$.

## 原根

如果 $g\bmod m$ 的阶是 $\varphi(m)$，那么 $g$ 是 $\bmod m$ 的原根

$\bmod m$ 有原根的充要条件是 $m=2,4,p^n,2p^n$，其中 $p$ 是奇素数，$n$ 是任意正整数

$\bmod m$ 有原根时，它有 $\varphi(\varphi(m))$ 个原根

