---
title: 莫比乌斯反演小结
categories:
  - 数学
mathjax: true
tags:
 - 数论
abbrlink: 5040
top: true
date: 2019-01-10 19:49:19
updated: 2019-04-11 10:22:19
---


**摘要**

复习莫比乌斯反演～


<!--more-->

# 前言

OI 的数论涉及求和的部分，一般采用 $O(n)$ 暴力计算；但是当上界过大的时候就需要考虑数论求和法。

常用的技巧有前缀和、差分、组合计数、等差数列求和、矩阵快速幂等，这些技巧都建立在数学原理的基础上

如果这些仍不能解决问题，比如对于具有线性空间的嵌套求和，就要考虑到莫比乌斯反演了

# 数论分块与整除相关

先补一下数学小 trick

## 引理 1

$$
\forall a,b,c\in\mathbb{Z},\left\lfloor\frac{a}{bc}\right\rfloor=\left\lfloor\frac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor
$$

略证：

$$
\begin{split}
&\frac{a}{b}=\left\lfloor\frac{a}{b}\right\rfloor+r(0\leq r<1)\\
\Rightarrow
&\left\lfloor\frac{a}{bc}\right\rfloor
=\left\lfloor\frac{a}{b}\cdot\frac{1}{c}\right\rfloor
=\left\lfloor \frac{1}{c}\left(\left\lfloor\frac{a}{b}\right\rfloor+r\right)\right\rfloor
=\left\lfloor \frac{\left\lfloor\frac{a}{b}\right\rfloor}{c} +\frac{r}{c}\right\rfloor
=\left\lfloor \frac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor\\
&&\square
\end{split}
$$

## 引理 2

$$
\forall n,d\in\mathbb{N},\left|\left\{\left\lfloor\frac{n}{d}\right\rfloor\right\}\right|\leq\left\lfloor2\sqrt{n}\right\rfloor
$$

$|V|$ 表示集合 $V$ 的元素个数

略证：

对于 $d\leq \left\lfloor\sqrt{n}\right\rfloor$，$\left\lfloor\frac{n}{d}\right\rfloor$ 有 $\left\lfloor\sqrt{n}\right\rfloor$ 种取值

对于 $d> \left\lfloor\sqrt{n}\right\rfloor$，有 $\left\lfloor\frac{n}{d}\right\rfloor\leq\left\lfloor\sqrt{n}\right\rfloor$，也只有 $\left\lfloor\sqrt{n}\right\rfloor$ 种取值

综上，得证

## 数论分块

数论分块的过程大概如下：考虑含有 $\left\lfloor\frac{n}{i}\right\rfloor$ 的求和式子（$n$ 为常数）

对于任意一个 $i(i\leq n)$，我们需要找到一个最大的 $j(i\leq j\leq n)$，使得 $\left\lfloor\frac{n}{i}\right\rfloor = \left\lfloor\frac{n}{j}\right\rfloor$.

而 $j=\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$.

略证：

$$
\begin{split}
&\left\lfloor\frac{n}{i}\right\rfloor \leq \frac{n}{i}\\
\Rightarrow
&\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor }\right\rfloor
\geq \left\lfloor\frac{n}{\frac{n}{i} }\right\rfloor
= \left\lfloor i \right\rfloor=i \\
\Rightarrow
&i\leq \left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor }\right\rfloor\\
&&\square
\end{split}
$$

即 $j=\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$.

利用上述结论，我们每次以 $[i,j]$ 为一块，分块求和即可

# 狄利克雷卷积

狄利克雷卷积是建立在群 $(G,\ast)$ 上的运算，其中 $G$ 是数论函数集合，定义如下
$$
(f\ast g)(n)=\sum_{d|n}f(d)g\left(\frac{n}{d}\right)
$$

## 运算律与性质

交换律：$f\ast g=g\ast f$.

结合律：$f\ast(g\ast h)=(f\ast g)\ast h$.

分配律：$f\ast(g+h)=f\ast g+f\ast h$.

积性函数的卷积仍为积性函数

## 单位元

狄利克雷卷积的单位元为函数 $\varepsilon(n)=[n=1]$，即 $n=1$ 时表达式为 1，否则为 0.

## 常用卷积

$$
\begin{split}
&\mu\ast 1=\varepsilon &(\varepsilon(n)=[n=1])\\
&1\ast 1=d &(d(n)=\sum_{i|n}1) \\
&ID\ast 1=\sigma &(\sigma(n)=\sum_{i|n}i ) \\
&\mu\ast ID=\varphi &(\varphi(n)=\sum_{i=1}^n[gcd(i,n)=1] )
\end{split}.
$$

# 莫比乌斯函数

提到莫比乌斯反演就不得不提到的函数



## 定义

莫比乌斯函数 $\mu(n)$ 是一个数论函数，其定义如下
$$
\mu(n)=\left\{\begin{split}
& 1&,n=1\\
& (-1)^k&,\prod_{i=1}^kc_i=1\\
& 0&,\prod_{i=1}^kc_i>1
\end{split}\right.
$$

其中 $n=\prod_{i=1}^k{p_i}^{c_i}$.

## 性质

$\mu$ 是一个积性函数

在狄利克雷卷积的意义下，$\mu\ast 1=\varepsilon $，即 $\mu$ 和 $1$ 互为逆元

使用莫比乌斯反演解题，主要使用的就是这两个性质

# 莫比乌斯反演

蛤？反演？

其实就是狄利克雷卷积运算不停推式子啦

许多 dalao 的博客都会给一个莫比乌斯反演的公式：
$$
\begin{split}
&\forall f(n),g(n),f(n)=\sum_{d|n}g(d)\\
&\exists g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})
\end{split}.
$$
但就笔者而言，这个公式是多余的。这其实就是狄利克雷卷积运算的展开，我们可以如下描述：
$$
\begin{split}
&\forall f(n),g(n),f=g\ast 1\\
&\exists g=\mu\ast f
\end{split}
$$
所以这就是两边同时卷一个 $1$ 的逆元 $\mu$ 的结果啊

那么莫比乌斯反演一般怎么用啊

其实用的最多的是性质二的演化

# 【例 1】GCD 定值统计

> [HAOI2011]Problem b
>
> 多组数据，求
> $$
> \sum_{x=a}^b\sum_{y=c}^d[gcd(x,y)=k].\\
> a,b,c,d,k\leq 10^5
> $$
> 中括号表达式意思是：当里面的布尔表达式为真时，整个表达式的值为 1，否则整个表达式为 0.

利用前缀和的思想，把下界统一为 1，再做一次矩阵上的差即可
$$
solve(m,n,k)=\sum_{x=1}^m\sum_{y=1}^n[gcd(x,y)=k].
$$
那么答案即为
$$
solve(b,d,k)-solve(a-1,d,k)-solve(b,c-1,k)+solve(a-1,c-1,k)
$$
开始变形

显然我们只需枚举 $k$ 的倍数，那么同时除以 $k$
$$
\sum_{x=1}^{\left\lfloor\frac{m}{k}\right\rfloor}\sum_{y=1}^{\left\lfloor\frac{n}{k}\right\rfloor}[gcd(x,y)=1]
$$
考虑到 $\varepsilon(n)=[n=1]$ 的定义
$$
\sum_{x=1}^{\left\lfloor\frac{m}{k}\right\rfloor}\sum_{y=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\varepsilon(gcd(x,y)=1)
$$
根据 $\mu\ast 1=\varepsilon$ 反演
$$
\sum_{x=1}^{\left\lfloor\frac{m}{k}\right\rfloor}\sum_{y=1}^{\left\lfloor\frac{n}{k}\right\rfloor}
\sum_{d|gcd(x,y)}\mu(d)
$$
变换枚举顺序，我们先枚举 $d$，再枚举 $x,y$
$$
\sum_{d=1}^{\min\left(\left\lfloor\frac{m}{k}\right\rfloor,\left\lfloor\frac{n}{k}\right\rfloor\right)}
\sum_{x=1}^{\left\lfloor\frac{m}{k}\right\rfloor}
\sum_{y=1}^{\left\lfloor\frac{n}{k}\right\rfloor}
[d|gcd(x,y)]\cdot\mu(d)
$$
也就是说，我们将关于 $d$ 的求和符号提前，并把原来的位置的求和符号变成布尔条件，以达到等效的求和效果

这算是一个比较通用的技巧

那么，既然 $d|gcd(x,y)$，就只需要枚举 $d$ 的倍数即可，那么同除 $d$
$$
\sum_{d=1}^{\min\left(\left\lfloor\frac{m}{k}\right\rfloor,\left\lfloor\frac{n}{k}\right\rfloor\right)}
\sum_{x=1}^{\left\lfloor\frac{m}{kd}\right\rfloor}
\sum_{y=1}^{\left\lfloor\frac{n}{kd}\right\rfloor}
[gcd(x,y)\in\mathbb{Z}]\cdot\mu(d)
$$
发现中括号表达式的值始终为 1，可以忽略
$$
\sum_{d=1}^{\min\left(\left\lfloor\frac{m}{k}\right\rfloor,\left\lfloor\frac{n}{k}\right\rfloor\right)}
\sum_{x=1}^{\left\lfloor\frac{m}{kd}\right\rfloor}
\sum_{y=1}^{\left\lfloor\frac{n}{kd}\right\rfloor}
\mu(d)
$$
再根据乘法分配律
$$
\sum_{d=1}^{\min\left(\left\lfloor\frac{m}{k}\right\rfloor,\left\lfloor\frac{n}{k}\right\rfloor\right)}
\left\lfloor\frac{m}{kd}\right\rfloor\left\lfloor\frac{n}{kd}\right\rfloor\mu(d)
$$
非常友好的式子对吧

于是利用 $\mu$ 是积性函数的性质，我们可以 $O(n)$ 求和

不过题目要求多组数据，那么我们计算 $\mu$ 的前缀和，即可数论分块 $O(\sqrt{\frac{m}{k}}+\sqrt{\frac{n}{k}})$ 求和。

总复杂度 $O\left(n\left(\sqrt{\frac{m}{k}}+\sqrt{\frac{n}{k}}\right)\right)$.

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int N=5e5+5;
int n,a,b,c,d,k;
bool bp[N];
int p[N],cnt,u[N];
void pre_work(){// 线性筛 mu
	u[1]=bp[0]=bp[1]=1;
	for(int i=2;i<N;i++){if(!bp[i])p[++cnt]=i,u[i]=-1;
		for(int j=1;j<=cnt&&i*p[j]<N;j++){bp[i*p[j]]=1;
			if(i%p[j]==0){u[i*p[j]]=0;break;}
			else u[i*p[j]]=-u[i];
		}
	}
	for(int i=2;i<N;i++)u[i]+=u[i-1];// 前缀和处理
}
int solve(int m,int n,int g){
	m/=g,n/=g;
	int mxp=min(m,n),p=0,q,ans=0;
	while(p<mxp){++p,q=min(m/(m/p),n/(n/p));// 两个并列的分块
		ans+=(m/p)*(n/p)*(u[q]-u[p-1]);// 统计 [p,q]
		p=q;
	}
	return ans;
}
signed main(){scanf("%lld",&n);
	pre_work();
	while(n--){scanf("%lld%lld%lld%lld%lld",&a,&b,&c,&d,&k);
		printf("%lld\n",solve(b,d,k)-solve(a-1,d,k)-solve(b,c-1,k)+solve(a-1,c-1,k));
	}
	return 0;
}
```

这道题和 [POI2007]ZAP-Queries 是差不多的，有需要的可以双倍经验哦

# 【例 2】GCD 常数幂

> $$
> \sum_{i=1}^n\sum_{j=1}^mgcd(i,j)^k\bmod(10^9+7).
> $$
>

有幂的形式难以演化，就变换枚举顺序
$$
\sum_{d=1}^{min(n,m)}\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]\cdot d^k\\
\sum_{d=1}^{min(n,m)}d^k\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]\\
$$
按照之前的套路处理后半部分，得到
$$
\sum_{d=1}^{min(n,m)}d^k
\sum_{p=1}^{min(\left\lfloor\frac{n}{d}\right\rfloor,\left\lfloor\frac{m}{d}\right\rfloor)}
{\left\lfloor\frac{n}{dp}\right\rfloor}
{\left\lfloor\frac{m}{dp}\right\rfloor}
\mu(p)
$$
我们可以 $O(n+nlog_2k)$，统计答案。不过有多组 $(n,m)$ 询问呢？

我们知道 $\sum_{p=1}^{min(\left\lfloor\frac{n}{d}\right\rfloor,\left\lfloor\frac{m}{d}\right\rfloor)}{\left\lfloor\frac{n}{dp}\right\rfloor}{\left\lfloor\frac{m}{dp}\right\rfloor}\mu(p)$ 是可以 $O(\sqrt{n})$ 分块计算的，但是由于它的外面套了一个求和，还带有 $d^k$ 的系数，无法分块做

那么我们再次变换枚举顺序，我们先枚举 $dp$ 再枚举 $d$ 和 $p$：
$$
\begin{split}
&\sum_{T=1}^{min(n,m)}
\sum_{d=1}^{min(n,m)}d^k\cdot[d|T]
{\left\lfloor\frac{n}{T}\right\rfloor}
{\left\lfloor\frac{m}{T}\right\rfloor}
\mu\left(\frac{T}{d}\right)\\

&\sum_{T=1}^{min(n,m)}
\sum_{d|T}d^k
{\left\lfloor\frac{n}{T}\right\rfloor}
{\left\lfloor\frac{m}{T}\right\rfloor}
\mu\left(\frac{T}{d}\right)\\

&\sum_{T=1}^{min(n,m)}
{\left\lfloor\frac{n}{T}\right\rfloor}
{\left\lfloor\frac{m}{T}\right\rfloor}
\sum_{d|T}d^k
\mu\left(\frac{T}{d}\right)\\
\end{split}
$$
这样，我们就把向下取整的部分提到外面来了。

后半部分的求和其实就是 $ID^k\ast\mu$，是一个积性函数

于是预处理后半部分的前缀和，做数论分块即可

# 【例 3】对称 LCM

> $$
> \sum_{i=1}^n\sum_{j=1}^nlcm(i,j)
> $$
>

先变成 $gcd$ 的形式
$$
\sum_{i=1}^n\sum_{j=1}^n\frac{ij}{gcd(i,j)}
$$
开始变形
$$
\begin{split}
&\sum_{d=1}^{n}
\sum_{i=1}^n\sum_{j=1}^n
[gcd(i,j)=d]\frac{ij}{d}\\
\end{split}
$$

式子里有 i,j 作为系数，所以在同时除以 d 的时候，里面的要乘回来
$$
\begin{split}
&\sum_{d=1}^{n}
\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
[gcd(i,j)=1]\cdot ijd\\

&\sum_{d=1}^{n}
\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
\sum_{p|gcd(i,j)}\mu(p)\cdot ijd\\
\end{split}
$$

再次变换枚举顺序，枚举 gcd

$$
\begin{split}
&\sum_{d=1}^{n}
\sum_{p=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
ijd\cdot[p|gcd(i,j)]\cdot\mu(p)\\

&\sum_{d=1}^{n}
\sum_{p=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
\sum_{i=1}^{\left\lfloor\frac{n}{dp}\right\rfloor}
\sum_{j=1}^{\left\lfloor\frac{n}{dp}\right\rfloor}
ijd\cdot p^2\mu(p)\\

&\sum_{d=1}^{n}d
\sum_{p=1}^{\left\lfloor\frac{n}{d}\right\rfloor}p^2\mu(p)
\sum_{i=1}^{\left\lfloor\frac{n}{dp}\right\rfloor}i
\sum_{j=1}^{\left\lfloor\frac{n}{dp}\right\rfloor}j\\
\end{split}
$$

根据等差数列求和公式，令 $f(n)=\frac{n(n+1)}{2}$. 同时变换枚举顺序，令 $T=dp$.
$$
\begin{split}
&\sum_{d=1}^{n}d
\sum_{p=1}^{\left\lfloor\frac{n}{d}\right\rfloor}p^2\mu(p)\cdot
\left[f\left(\left\lfloor\frac{n}{dp}\right\rfloor\right)\right]^2 \\

&\sum_{T=1}^{n}
\sum_{p|T}\frac{T}{p}\cdot p^2 \cdot\mu(p)\cdot
\left[f\left(\left\lfloor\frac{n}{T}\right\rfloor\right)\right]^2\\

&\sum_{T=1}^{n}\left[f\left(\left\lfloor\frac{n}{T}\right\rfloor\right)\right]^2\cdot T
\sum_{p|T}p \cdot\mu(p)\\
\end{split}
$$

同样的，前半分块，后半是一个 $(ID\cdot\mu)\ast 1$ 的积性函数，预处理前缀和即可

# 【例 4】非对称 LCM

> $$
> \sum_{i=1}^nlcm(i,n)
> $$
>

化成 $gcd$ 的形式
$$
\sum_{i=1}^n\frac{i\cdot n}{gcd(i,n)}\\
$$
有一个显然的结论：$gcd(a,b)=gcd(b-a,b)(a\leq b)$，于是我们可以模仿等差数列公式的原理两两配对
$$
\begin{split}
&\frac{1}{2}\left(\sum_{i=1}^{n-1}\frac{i\cdot n}{gcd(i,n)}+\sum_{i=n-1}^1\frac{i\cdot n}{gcd(i,n)}
\right) +n\\

&\frac{1}{2}\left(\sum_{i=1}^{n-1}\frac{i\cdot n}{gcd(i,n)}+\sum_{i=n-1}^1\frac{i\cdot n}{gcd(n-i,n)}
\right) +n\\

&\frac{1}{2}\left(\sum_{i=1}^{n-1}\frac{n^2}{gcd(i,n)}
\right) +n\\
\end{split}
$$

处理括号里面的部分
$$
\begin{split}
&\sum_{i=1}^{n-1}\frac{n^2}{gcd(i,n)}\\

=&\sum_{d=1}^{n-1}
\sum_{i=1}^{n-1}[gcd(i,n)=d]\frac{n^2}{d}\\

=&\sum_{d|n,d\neq n}
\sum_{i=1}^{n-1}[gcd(i,n)=d]\frac{n^2}{d}\\

=&\sum_{d|n,d\neq n}\frac{n^2}{d}
\sum_{i=1}^{\frac{n}{d}-1}[gcd(i,\frac{n}{d})=1]\\

=&\sum_{d|n,d\neq n}\frac{n^2}{d}\cdot
\varphi(\frac{n}{d})\\

=&n\sum_{d|n,d\neq 1}d\cdot\varphi(d)\\

\end{split}
$$
原式即为
$$
\begin{split}
&\frac{1}{2}\left(n\sum_{d|n,d\neq 1}d\cdot\varphi(d)
\right) +n\\

=&\frac{1}{2}n\left[\left(\sum_{d|n}d\cdot\varphi(d)
\right)-1\right] +n\\
\end{split}
$$

## 线性筛

考虑具体的线性筛的过程，令 $f(n)=\sum_{d|n}d\cdot\varphi(d)$. 根据卷积的性质可知 $f$ 是积性函数

对于质数 $p$ ，$f(p)=p\cdot\varphi(p)+1$；

$f\left(p^k\right)=\sum_{i=0}^kp^i\cdot\varphi\left(p^i\right)=f\left(p^{k-1}\right)+p^k\cdot\varphi\left(p^k\right)$.

因此在线性筛的过程中，如果互质就直接利用积性函数的性质，如果不互质就把自变量除掉它的最小质因子的幂，这样就转化成了互质的数

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+6;
int pn[N],cnt;
bool vis[N];
int phi[N],f[N],t[N];//t[i] 表示 i 的最小质因子 p 的最大幂次 p^k
void sieve(int n){vis[0]=vis[1]=1,phi[0]=0,phi[1]=1,f[1]=1,t[1]=1;
	for(int i=2;i<=n;i++){if(!vis[i])pn[++cnt]=i,phi[i]=i-1,f[i]=i*phi[i]+1,t[i]=i;
		for(int j=1;j<=cnt;j++){const int pk=t[i]*pn[j],x=i*pn[j];
			if(i*pn[j]>n)break;
			vis[i*pn[j]]=1;
			if(i%pn[j]){phi[x]=phi[i]*phi[pn[j]];
				f[x]=f[i]*f[pn[j]];
				t[x]=pn[j];
			}
			else {phi[x]=phi[i]*pn[j];
				f[x]=f[i/t[i]]*(f[t[i]]+pk*phi[pk]);
				t[x]=pk;
				break;
			}
		}
	}
}
int T,n;
signed main(){scanf("%lld",&T);
	sieve(1000000);
	while(T--){scanf("%lld",&n);
		printf("%lld\n",n*(f[n]-1)/2+n);
	}
	return 0;
}
```

# 【例 5】带有系数的 GCD 统计

> [LuoguP3768] 简单的数学题，求
> $$
> \sum_{i=1}^n\sum_{j=1}^ni\cdot j\cdot gcd(i,j)\bmod p\\
> n\leq10^{10},5\times10^8\leq p\leq1.1\times10^9
> $$
> $p$ 是质数。

看似是一道和 $gcd$ 有关的题，不过由于带有系数，并不容易化简

我们利用 $\varphi\ast1=ID$ 反演
$$
\begin{split}
&\sum_{i=1}^n\sum_{j=1}^ni\cdot j
\sum_{d|i,d|j}\varphi(d)\\

&\sum_{d=1}^n\sum_{i=1}^n
\sum_{j=1}^n[d|i,d|j]\cdot i\cdot j
\cdot\varphi(d)\\

&\sum_{d=1}^n
\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
d^2\cdot i\cdot j\cdot\varphi(d)\\

&\sum_{d=1}^nd^2\cdot\varphi(d)
\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}i
\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}j\\

&\sum_{d=1}^nF^2\left(\left\lfloor\frac{n}{d}\right\rfloor\right)\cdot d^2\varphi(d)
\left(F(n)=\frac{1}{2}n\left(n+1\right)\right)\\
\end{split}
$$
对 $\sum_{d=1}^nF\left(\left\lfloor\frac{n}{d}\right\rfloor\right)^2$ 做数论分块，$d^2\varphi(d)$ 的前缀和用杜教筛处理：
$$
\begin{split}
&f(n)=n^2\varphi(n)=(ID^2\varphi)(n)\\
&S(n)=\sum_{i=1}^nf(i)=\sum_{i=1}^n(ID^2\varphi)(i)
\end{split}
$$

杜教筛（见 [杜教筛 - 例 3](/2019/01/11/5071/)）完了是这样的

$$
S(n)=\left(\frac{1}{2}n(n+1)\right)^2-\sum_{i=2}^ni^2S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
$$

分块递归求解即可，复杂度 $O(n^{\frac{2}{3}})$.

# 【例 6】约数个数统计

> [SDOI2015] 约数个数和，多组数据，求
> $$
> \sum_{i=1}^n\sum_{j=1}^md(i\cdot j)\\
> d(n)=\sum_{i|n}1,n,m,T\leq5\times10^4
> $$
>

$d$ 表示约数个数

要推这道题首先要了解 $d$ 函数的一个特殊性质
$$
d(i\cdot j)=\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]
$$
再化一下这个式子
$$
\begin{split}
d(i\cdot j)=&\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]\\
=&\sum_{x|i}\sum_{y|j}\sum_{p|gcd(x,y)}\mu(p)\\
=&\sum_{p=1}^{min(i,j)}\sum_{x|i}\sum_{y|j}[p|gcd(x,y)]\cdot\mu(p)\\
=&\sum_{p|i,p|j}\mu(p)\sum_{x|i}\sum_{y|j}[p|gcd(x,y)]\\
=&\sum_{p|i,p|j}\mu(p)\sum_{x|\frac{i}{p}}\sum_{y|\frac{j}{p}}1\\
=&\sum_{p|i,p|j}\mu(p)d\left(\frac{i}{p}\right)d\left(\frac{j}{p}\right)\\
\end{split}
$$
将上述式子代回原式
$$
\begin{split}
&\sum_{i=1}^n\sum_{j=1}^md(i\cdot j)\\
=&\sum_{i=1}^n\sum_{j=1}^m\sum_{p|i,p|j}\mu(p)d\left(\frac{i}{p}\right)d\left(\frac{j}{p}\right)\\

=&\sum_{p=1}^{min(n,m)}
\sum_{i=1}^n\sum_{j=1}^m
[p|i,p|j]\cdot\mu(p)d\left(\frac{i}{p}\right)d\left(\frac{j}{p}\right)\\

=&\sum_{p=1}^{min(n,m)}
\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor}
\mu(p)d(i)d(j)\\

=&\sum_{p=1}^{min(n,m)}\mu(p)
\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}d(i)
\sum_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor}d(j)\\

=&\sum_{p=1}^{min(n,m)}\mu(p)
S\left(\left\lfloor\frac{n}{p}\right\rfloor\right)
S\left(\left\lfloor\frac{m}{p}\right\rfloor\right)
\left(S(n)=\sum_{i=1}^{n}d(i)\right)\\

\end{split}
$$
那么 $O(n)$ 预处理 $\mu,d$ 的前缀和，$O(\sqrt{n})$ 分块处理询问，总复杂度 $O(n\sqrt{n})$.

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int N=5e4+5;
int n,m,T,pr[N],mu[N],d[N],t[N],cnt;//t 表示 i 的最小质因子出现的次数
bool bp[N];
void prime_work(int k){bp[0]=bp[1]=1,mu[1]=1,d[1]=1;
	for(int i=2;i<=k;i++){if(!bp[i])pr[++cnt]=i,mu[i]=-1,d[i]=2,t[i]=1;
		for(int j=1;j<=cnt&&i*pr[j]<=k;j++){bp[i*pr[j]]=1;
			if(i%pr[j]==0){mu[i*pr[j]]=0,d[i*pr[j]]=d[i]/(t[i]+1)*(t[i]+2),t[i*pr[j]]=t[i]+1;break;}
			else mu[i*pr[j]]=-mu[i],d[i*pr[j]]=d[i]<<1,t[i*pr[j]]=1;
		}
	}
	for(int i=2;i<=k;i++)mu[i]+=mu[i-1],d[i]+=d[i-1];
}
int solve(){int res=0,mxi=min(n,m);
	for(int i=1,j;i<=mxi;i=j+1)
		j=min(n/(n/i),m/(m/i)),res+=d[n/i]*d[m/i]*(mu[j]-mu[i-1]);
	return res;
}
signed main(){scanf("%lld",&T);
	prime_work(50000);
	while(T--){scanf("%lld%lld",&n,&m);
		printf("%lld\n",solve());
	}
	return 0;
}
```

# 【例 7】无平方因子的数统计

> 求
> $$
> \sum_{i=1}^n\mu^2(i)
> $$
>

我们考虑 $\mu^2(i)$ 的贡献。当且仅当 $i$ 不含平方及以上的因子时，$\mu^2(i)=1$，否则 $\mu^2(i)=0$.

因此我们要求 $1\sim n$ 中无平方因子的数的个数。那么考虑容斥，用整体减掉含有平方因子的数：
$$
\sum_{i=1}^n\mu^2(i)=n+\sum_{i=2}^n\mu(i)\left\lfloor \frac{n}{i^2} \right\rfloor\\
=\sum_{i=1}^n\mu(i)\left\lfloor \frac{n}{i^2} \right\rfloor=\sum_{i=1}^\sqrt{n}\mu(i)\left\lfloor \frac{n}{i^2} \right\rfloor
$$
$\mu(i)$ 是容斥系数。

# 小结

举了 4 个例子，接下来总结一下

1. 莫比乌斯反演反演其实也不是什么复杂的算法，就是在和式变形的时候偶尔辅助变换一下
2. 对于布尔一类的求和一般考虑 $\varepsilon(n)=[n=1]$ 来变形
3. 对于直接贡献的可以考虑变换枚举顺序使之变成系数，或者用 $\varphi\ast1=ID$ 来变形
4. 处在分母位置上的一定要变换枚举顺序，不要尝试在分母上变换求和，而要在全局下变换
5. 要灵活变换枚举的条件（比如 $\sum_{i=1}^n$ 和 $\sum_{i|n}$），灵活观察式子的形态以转化成常见的积性函数（例 4）
6. 对于含有向下取整的式子要变换枚举顺序提到前面来，方便数论分块
7. 利用积性函数的性质考虑线性筛，范围较大的考虑杜教筛

# 莫比乌斯反演扩展

结尾补一个不常用的

放一个莫比乌斯反演非卷积形式的公式

对于数论函数 $f,g$ 和**完全积性**函数 $t$ 且 $t(1)=1$：
$$
f(n)=\sum_{i=1}^nt(i)g\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
\Leftrightarrow g(n)=\sum_{i=1}^n\mu(i)t(i)f\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
$$
我们证明一下
$$
\begin{split}
&g(n)=\sum_{i=1}^n\mu(i)t(i)f\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\

=&\sum_{i=1}^n\mu(i)t(i)
\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}t(j)
g\left(\left\lfloor\frac{\left\lfloor\frac{n}{i}\right\rfloor}{j}\right\rfloor\right)\\

=&\sum_{i=1}^n\mu(i)t(i)
\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}t(j)
g\left(\left\lfloor\frac{n}{ij}\right\rfloor\right)\\

=&\sum_{T=1}^n
\sum_{i=1}^n\mu(i)t(i)
\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}[ij=T]
t(j)g\left(\left\lfloor\frac{n}{T}\right\rfloor\right)

\end{split}
$$
枚举 ij 的乘积 T
$$
\begin{split}
=&\sum_{T=1}^n
\sum_{i|T}\mu(i)t(i)
t\left(\frac{T}{i}\right)g\left(\left\lfloor\frac{n}{T}\right\rfloor\right)
=\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)
\sum_{i|T}\mu(i)t(i)t\left(\frac{T}{i}\right)\\

=&\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)
\sum_{i|T}\mu(i)t(T)

=\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)t(T)
\sum_{i|T}\mu(i)\\

=&\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)t(T)
\varepsilon(T)=g(n)t(1)=g(n)

&&& \square
\end{split}
$$

# 参考文献

https://blog.sengxian.com/algorithms/mobius-inversion-formula , Sengxian s Blog

https://oi-wiki.org//math/mobius/ , OI-WIKI
