---
title: 组合数漫谈
categories:
  - 数学
tags:
 - 数论
 - 组合数
mathjax: true
abbrlink: 53520
date: 2018-12-21 13:56:00
updated: 2018-12-21 13:56:00
---

# 排列组合

排列：从n个不同元素中，任取m(m≤n,m与n均为自然数,下同）个元素按照一定的顺序排成一列，叫做从n个不同元素中取出m个元素的一个排列；从n个不同元素中取出m(m≤n）个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数，用符号 A(n,m）表示。
$$
A_n^m=\frac{n!}{m!(n-m)!}
$$

组合：从n个不同元素中，任取m(m≤n）个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n）个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。用符号 C(n,m) 表示。
$$
C_n^m=\frac{A_n^m}{m!}=\frac{n!}{m!(n-m)!}\\
C_n^m=C_{n-1}^{m-1}+C_{n-1}^m
$$

# 二项式定理

$$
(a+b)^n=\sum_{i=0}^nC_n^ia^{n-1}b^i=\sum_{i=0}^n\binom{n}{i}a^{n-i}b^i
$$

## 扩展定理

取$a=b=1$，得
$$
\sum_{i=0}^n\binom{n}{i}=2^n
$$
取$a=1,b=-1$得
$$
\sum_{i=0}^nC_n^i(-1)^i=0
$$

$$
\sum_{i=0}^k\binom{n+i-1}{i}=\binom{n+k}{k} \\
\sum_{i=0}^k\binom{n-1+i}{n-1}=\binom{n+k}{n}
$$

# 计算组合数 $\binom{n}{m}\bmod p$

## Subtask1

$n,m\leq 2000$
$$
\binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}
$$
时间复杂度$O(n^2)$.

## Subtask2

$n,m\leq 10^7,p$是质数

费马小定理求逆元，将除法转化为乘法即可。

时间复杂度$O(n+log_2p)$.

## Subtask3

$n,m\leq 10^{18},p\leq 10^6$,是质数

lucas定理：p为质数时，

$$
\binom{n}{m}\equiv  \binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor\frac{m}{p}\right\rfloor}\binom{n\bmod p}{m\bmod p} (\bmod p)
$$

转化为Subtask2，时间复杂度$O(p+log_2p)$.

## Subtask4

$n,m\leq 10^6,p\leq 10^9$
分解质因数：

$$
\binom{n}{m}=\frac{n!}{m!(n-m)!}=\prod_{i=1}^k{p_i}^{c_i}
$$

在$n!$中，质因子p的出现次数为 :

$$
cnt(n!)=\left\lfloor\frac{n}{p}\right\rfloor+\left\lfloor\frac{n}{p^2}\right\rfloor+...+\left\lfloor\frac{n}{p^k}\right\rfloor
$$

则在 $\binom{n}{m}$ 中p出现的次数为$cnt(n!)-cnt(m!)-cnt((n-m)!)$

最后剩下的质数相乘即可。

均摊复杂度$O(n)$.

## Subtask5

$n,m,p\leq 10^9$
分块打表

$$
\binom{n}{m}=\frac{n!}{m!(n-m)!}
$$

计算Q!,2Q!,3Q!...n!,分块打表，则计算n!的复杂度为Q.

令$Q=\sqrt{n}$,则复杂度为$ O(\sqrt{n}) $

$$
f(x)=(x+1)(x+2)(x+3)..(x+\sqrt{n})
$$

计算$f(0,\sqrt{n},2\sqrt{n},3\sqrt{n}...)$，打表

## Extask

求 $\binom{n}{m}\bmod p^c$ .  $n,m\leq 10^9 ,p^c\leq 10^6$

$n!=p^{c_1}\cdot k_1$

$m!=p^{c_2}\cdot k_2$

$(n-m)!=p^{c_3}\cdot k_3$

$$
\binom{n}{m}=\frac{n!}{m!(n-m)!}=p^{c_1-c_2-c_3}\cdot \frac{k_1}{k_2k_3}.
$$

则要求我们将阶乘转化为$p^c*k$(p,k互质)的形式。


$n!=1\cdot 2\cdot 3\cdot 4...\cdot (n-1)\cdot n\cdot (p\cdot 2p\cdot 3p\cdot 4p...\cdot n/p\cdot p)$

$(p\cdot 2p\cdot 3p\cdot 4p...\cdot n/p\cdot p)=p^{n/p}\cdot 1\cdot 2\cdot 3..\cdot (n/p)$

$1\cdot2\cdot3\cdots \cdot(n/p)$是递归子问题，继续求解即可。

# [LuoguP2822]组合数问题

分解质因数$k=\prod{p_i}^{c_i}$ 

对于一个$C_i^j=\frac{i!}{j!(i-j)!}$，统计$p_i$在$i!$中的幂次数。

同理，求出分子分母的$p_i$幂次差，可判断能否被${p_i}^{c_i}$整除。因此对于一个组合数的判断，复杂度$O(log_2k)$。

然后矩阵前缀和从$C_{i-1}^j$和$C_i^{J-1}$推到$C_I^j$即可

总复杂度$O(nm)$.

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#define FOR(a,b,c) for(int a=b;a<=c;a++)
using namespace std;
const int N=2003,M=2003;
int t,k,ans,n,m;
int p[20],c[20],cnt;//分解质因数
int sum[N][M];//sum[i,j]:n=i,m=j时的解
bool v[N][M];
int f(int x,int p){//x!含有p的幂次数
	int res=0;
	while(x)res+=x/p,x/=p;
	return res;
}
int F(int a,int b){
	if(a*b==0)return 0;//1%k!=0
	if(a<b)return F(a,a);
	if(v[a][b])return sum[a][b];
	sum[a][b]=v[a][b]=1;
	FOR(i,1,cnt)sum[a][b]&=(f(b,p[i])+f(a-b,p[i])+c[i]<=f(a,p[i]));
	sum[a][b]+=F(a,b-1)+F(a-1,b)-F(a-1,b-1);//矩阵前缀和
	return sum[a][b];
}
int main(){
	scanf("%d%d",&t,&k);
	for(int i=2;i*i<=k;i++){
		if(k%i==0)cnt++,p[cnt]=i;
		while(k%i==0)c[cnt]++,k/=i;
	}
	if(k!=1)p[++cnt]=k,c[cnt]++;//分解质因数
	while(t--){
		scanf("%d%d",&n,&m);
		printf("%d\n",F(n,m));
	}
	return 0;
}
```

# Lucas定理

用于求解$C_n^m\bmod p$（p是质数）的问题。
$$
\binom{n}{m}\equiv \binom{\left\lfloor x/p\right\rfloor}{\left\lfloor y/p\right\rfloor}\cdot\binom{x\bmod p}{y\bmod p}\ (\bmod p)
$$

# [LuoguP3807]卢卡斯定理

就这道题的数据范围还用不到Lucas

不过鉴于是模板，姑且用一用。

原理是
$$
C_n^m=\frac{n!}{m!(n-m)!}=\frac{\prod_{i=n-m+1}^ni}{(n-m)!}=(n-m)!^{-1}\cdot \prod_{i=n-m+1}^ni
$$
费马小定理求逆元即可

## 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100005;
int n,m,p;
int ksm(int a,int x){
	int res=1;
	while(x){
		if(x&1)res=(long long)res*a%p;
		a=(long long)a*a%p,x>>=1;
	}
	return res;
}
int c(int a,int b){
	if(a>p||b>p)return c(a/p,b/p)*c(a%p,b%p)%p;
	if(a<b)return 0;
	if(b==0)return 1;
	b=min(b,a-b);
	int ps=1,qs=1;
	for(int i=a;i>a-b;i--)ps=(long long)ps*i%p;
	for(int i=1;i<=b;i++)qs=(long long)qs*i%p;
	qs=ksm(qs,p-2);
	return (long long)ps*qs%p;
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d",&n,&m,&p);
		printf("%d\n",c(n+m,m));
	}
	return 0;
}
```
# [NOIP2011]计算系数

$$
ans=a^nb^mC_k^n
$$

组合数可以$O(n^2)$递推

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int P=10007;
int a,b,k,m,n,ans=1;
int C[1003][1003];
int c(int x,int y){
    return y>x?0:(y==0?1:(C[x][y]?C[x][y]:(C[x][y]=(c(x-1,y-1)+c(x-1,y))%P)));
}
signed main(){
	scanf("%lld%lld%lld%lld%lld",&a,&b,&k,&n,&m);
	a%=P,b%=P;
	for(int i=1;i<=n;i++)ans=ans*a%P;
	for(int i=1;i<=m;i++)ans=ans*b%P;
	printf("%lld",c(k,n)*ans%P);
	return 0;
}
```

# [SP5973]SELTEAM - Selecting Teams

n个人里面选k个人的方案数为$C_n^k$，则k个人中选一个做队长，剩下的人有$2^{k-1}$种选法，答案即为
$$
k\cdot 2^{k-1}\cdot C_n^k
$$
而$8388608=2^{23}$，进一步简化代码；

## 代码

```cpp
#include<bits/stdc++.h>
#define P 8388608
using namespace std;
typedef long long ll;
ll T,n,k,c[100001][30];
ll C(ll a,ll b){
	if(a<b)return 0;
	if(b==0)return 1;
	if(c[a][b])return c[a][b];
	return c[a][b]=(C(a-1,b-1)%P+C(a-1,b)%P)%P;
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&k);
		if(k>24)k=24;
		ll sum=0;
		for(ll m=1;m<=k;m++){
			sum+=(C(n,m)*m%P)*((1<<(m-1))%P)%P;
			sum%=P;
		}
		printf("%d\n",sum);
	}
	return 0;
} 
```

# [SCOI2010]生成字符串

在坐标系中，把1当做向右1单位，0当作像上1单位

如果一个字符串中0的个数多余1的个数，则有$n_k<m_k$，则$(n_k,m_k)$必在$y=x$的上方

即题目要求从$(0,0)$走到$(n,m)$，不走到$y=x$上方的情况下的方案数

如果不考虑01的个数，则从$(0,0)$走到$(n,m)$的方案数为$C_{n+m}^m=C_{n+m}^n$.

接下来考虑走到$y=x$上方的方案数

我们将$(n,m)$沿$y=x+1$翻折到$(m-1,n+1)$，如果你走到了$(m-1,n+1)$，那么你必然走到了$y=x$的上方；把路径翻折回去，就是走到$y=x$上方的一条路径；方案数为$C_{m+n}^{m-1}=C_{m+n}^{n+1}$.

于是答案即为$C_{n+m}^m-C_{n+m}^{m-1}$.

## 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int P=20100403;
int n,m;
int ksm(int a,int m){
	int res=1;
	while(m){
		if(m&1)res=(long long)res*a%P;
		a=(long long)a*a%P,m>>=1;
	}
	return res;
}
int c(int a,int b){
	if(b>a)return 0;
	b=min(b,a-b);
	int res=1,p=1;
	for(int i=a-b+1;i<=a;i++)res=(long long)res*i%P;
	for(int i=1;i<=b;i++)p=(long long)p*i%P;
	res=(long long)res*ksm(p,P-2)%P;
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	printf("%d",((c(n+m,m)-c(n+m,m-1))%P+P)%P);
	return 0;
}
```

