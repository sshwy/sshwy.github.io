---
title: 线性筛|欧拉筛
categories:
  - 数学
tags:
 - 数论
 - 欧拉函数
 - 筛
 - 质数
 - 模板
abbrlink: 27265
mathjax: true
date: 2018-11-16 23:56:12
updated: 2018-11-16 23:56:12
---
# 线性筛质数

每个数被最小的质因子筛一次。
<!--more-->
```cpp
int pn[N],cnt;
bool vis[N];
void pri(int n){
	vis[0]=vis[1]=1;
	for(int i=1;i<=n;i++){
		if(!vis[i])pn[++cnt]=i;
		for(int j=1;j<=cnt;j++){
			if(i*pn[j]>n)break;
			vis[i*pn[j]]=1;
			if(i%pn[j]==0)break;
		}
	}
}
```

- 每次筛去$i\times p[j]$时，$p[j]$是这个数的最小质因子
- 如果$p[j]|i$说明$i\times p[j]$有两个$p[j]$的质因子，则再往后，i中会有$p[j]$的因子，而后面的$p[k]$是大于$p[j]$，不是最小质因子，所以筛$p[j]$一次就break
- 这三行代码顺序不能换。

# 积性函数

积性函数：对于任意**互质**的整数a和b有性质$f(ab)=f(a)f(b)$的数论函数。

完全积性函数：对于任意整数a和b有性质$f(ab)=f(a)f(b)$的数论函数。

# 常见积性函数

- $\varphi(n)$ －[欧拉函数](/2018/11/16/55226/)
- $\mu(n)$ －莫比乌斯函数
- $gcd(n,k)$ －最大公因子，当k固定的情况
- $d(n)$ －n的正因子数目（即$\sigma^0(n)$）
- $\sigma(n)$ －n的所有正因子之和
- $\sigma^k(n)$ － 因子函数，n的所有正因子的k次幂之和，当中k可为任何复数。
- $ID^k(n)$ －幂函数，对于任何复数、实数k，定义$Idk(n)=n^k$（完全积性）

# 常见线性筛

## 线性筛欧拉函数$\varphi$

```cpp
bool bp[N];
int p[N],cnt,phi[N];
void pri(int k){
    bp[0]=bp[1]=1;
    for(int i=2;i<=k;i++){
        if(bp[i]==0)p[++cnt]=i,phi[i]=i-1;
        for(int j=2;j<=cnt;j++){
            if(i*p[j]>k)break;
            bp[i*p[j]]=1;
            if(i%p[j]==0){
                phi[i*p[j]]=phi[i]*p[j];
                    //因为p[j]这个因子已经存在于i中，所以乘上以后，本来互质的仍然互质，本来不互质的仍然不互质。但是与它不互质的数有p[j]个倍数，所以与它互质的也多了p[j]倍。
                break;
            }
            phi[i*p[j]]=phi[i]*phi[p[j]];//i和p[j]互质，利用积性函数的性质
        }
    }
}
```
## 线性筛莫比乌斯函数$\mu$

```cpp
bool bp[N];
int p[N],cnt,u[N];
void pri(int k){
    bp[0]=bp[1]=1,u[1]=1;
    for(int i=2;i<=k;i++){
        if(bp[i]==0)p[++cnt]=i,u[i]=-1;
        for(int j=2;j<=cnt;j++){
            if(i*p[j]>k)break;
            bp[i*p[j]]=1;
            if(i%p[j]==0){
                u[i*p[j]]=0;
                break;
            }
            u[i*p[j]]=-u[i];
        }
    }
}
```
## 线性筛约数个数$\sigma^0$

公式

$$
\begin{split}
&\sigma_0(x)=(a_1+1)(a_2+1)...(a_n+1)\\
&\sigma_0(x)=\prod_{i=1}^n(a_i+1)\\
\end{split}.
$$

​	定义$t[i]$表示i的最小质因子的次数。

```cpp
bool bp[N];
int p[N],cnt,d[N],t[N];
void pri(int k){
    bp[0]=bp[1]=1,d[1]=1;
    for(int i=2;i<=k;i++){
        if(bp[i]==0)p[++cnt]=i,d[i]=2,t[i]=1;
        for(int j=2;j<=cnt;j++){
            if(i*p[j]>k)break;
            bp[i*p[j]]=1;
            if(i%p[j]==0){
                d[i*p[j]]=d[i]/(t[i]+1)*(t[i]+2),t[i*p[j]]=t[i]+1;//多了一个因子
                break;
            }
            d[i*p[j]]=d[i]*d[p[j]],t[i*p[j]]=1;//新的因子
        }
    }
}
```
## 线性筛约数和$\sigma$

公式

$$
\begin{split}
&N=\prod_{i=1}^n{p_i}^{c_i}\\
&\sigma_1(x)=(1+p_1+p_1^2+\cdots +p_1^{c_1})(1+p_2+p_2^2+\cdots +p_2^{c_2})\cdots (1+p_n+\cdots +p_n^{c_n})\\
&\sigma_1(x)=\prod_{i=1}^n\sum_{j=0}^{c_i}{p_i}^{j}
\end{split}.
$$
定义t[i]表示以1为首项，以i的最小质因子为公比，项数为i的次数的等比数列的和。
```cpp
bool bp[N];
int p[N],cnt,sd[N],t[N];
void pri(int k){
    bp[0]=bp[1]=1,d[1]=1;
    for(int i=2;i<=k;i++){
        if(bp[i]==0)p[++cnt]=i,sd[i]=t[i]=i+1;
        for(int j=2;j<=cnt;j++){
            if(i*p[j]>k)break;
            bp[i*p[j]]=1;
            if(i%p[j]==0){
                t[i*p[j]]=t[i]*p[j]+1,sd[i*p[j]]=sd[i]/t[i]*t[i*p[j]];//多了一个因子
                break;
            }
            sd[i*p[j]]=sd[i]*sd[p[j]],t[i*p[j]]=t[p[j]];//新的因子
        }
    }
}
```

# 一般线性筛

对于一个积性函数$f$，考虑以下的线性筛法：

- 要计算$f(n)$，考虑到$n=\prod_{i=1}^k{p_i}^{c_i}$
- 在线性筛的过程中，如果$i\bmod p[j]\neq 0$，就有$f(i\cdot p[j])=f(i)f(p[j])$.
- 否则，考虑$k|i\cdot p[j],k\perp p[j]$，则有$f(i\cdot p[j])=f(k)f\left(\frac{i\cdot p[j]}{k}\right)$.
- 因此，我们只需要记录对于每一个$i\cdot p[j]$对应的$k$，或者推导出从$f(p^{c})$到$f(p^{c+1})$的关系式即可

# 例题

令$f[i]$表示有序三元组$(a,b,c)$的个数，使得$abc=i$。求出$f[1]$~$f[n]$。
n<=10^7

## 子问题1-$n\leq 10^5$

- 考虑枚举a，b。$a\leq n,b\leq n,ab\leq n$;
- 时间复杂度为$\sum_{a=1}^n\frac{n}{a}=log(n)$
- 总复杂度$O(nlog_2n)$.

## 题解

对1~n中的x分解质因数：
$$
x=\prod_{i=1}^k{p_i}^{c_i}
$$
则一个质因数的幂的分配个数为：
$$
g(p^c)=C_{c+2}^2
$$
乘法原理，f[x]为：
$$
f(x)=\prod_{i=1}^kg({p_i}^{c_i})=\prod_{i=1}^kC_{c_i+2}^2
$$
容易证明，f是一个积性函数。因为两个互质的数的质因子是不同的，所以**乘在一起求积**与**分别求积再相乘**的结果是一样的，即当$gcd(x,y)=1$时，$f(xy)=f(x)f(y)$。证明如下：
$$
\begin{split}
&x=\prod_{i=1}^k{p_i}^{c_i},y=\prod_{i=1}^m{p_i}^{c_i}\\
&xy=\prod_{i=1}^k{p_i}^{c_i}*\prod_{i=1}^m{p_i}^{c_i}\\
&f(xy)=\prod_{i=1}^kg({p_i}^{c_i})*\prod_{i=1}^mg({p_i}^{c_i})=f(x)f(y)\\
\end{split}.
$$

- 证明以后，线性筛积性函数即可。
```cpp
bool bp[N];
int p[N],cnt，f[N],t[N];
//f[i]表示除了最小质因子幂的其他质因子幂的三元组排列方式；
//t[i]表示i的最小质因子的指数。
void pri(int k){
    bp[0]=bp[1]=1;
    for(int i=2;i<=k;i++){
        if(bp[i]==0)p[++cnt]=i,f[i]=1,t[i]=1;
        for(int j=2;j<=cnt;j++){
            if(i*p[j]>k)break;
            bp[i*p[j]]=1;
            if(i%p[j]==0){
                f[i*p[j]]=f[i],t[i*p[j]]=t[i]+1;//更新最小质因子幂
                break;
            }
            f[i*p[j]]=f[i]*C(t[i]+2,2),t[i*p[j]]=1;
            //乘上原来的最小质因子幂，然后让p[j]成为最小质因子
        }
    }
    for(int i=1;i<=n;i++)f[i]*=C(t[i]+2,2);//把最小质因子幂乘回去
}
```
