---
title: 欧几里德算法专题
mathjax: true
categories:
  - 数学
abbrlink: 32323
date: 2019-05-01 10:43:58
updated: 2019-05-01 10:43:58
tags:
keywords:
cover: true
---

**摘要**

鉴于初等数论的内容太多，于是单独分出一个欧几里德算法的文章，主要讲欧几里德算法，扩欧和类欧

<!--more-->

# 欧几里得算法

即辗转相除法，基于 $gcd(a,b)=gcd(b,a\bmod b)$ 的原理，用于求解最大公约数的问题

```cpp
int gcd(int a,int b){return b?gcd(b,a%b):a;}
```

# [Luogu4549]裴蜀定理

> 给出n个数$a_1,a_2,\cdots,a_n$，求一组整数序列$x_1,\cdots,x_n$使得$\sum a_ix_i$的值为正且最小，输出这个和。

实际上和裴蜀定理没什么关系，直接全部GCD即可

```cpp
#include<cstdio>
using namespace std;
int n,g=0,a;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		g=gcd(a>0?a:-a,g);
	}
	printf("%d",g);
	return 0;
}
```

# 扩展欧几里德算法

扩展欧几里得算法是欧几里得算法的推广。利用欧几里得算法的思想和递归求得不定方程
$$
ax+by=gcd(a,b)
$$

的一组 x 和 y 的特解。也可求解 
$$
ax+by=d\cdot gcd(a,b)
$$

的一组特解（裴蜀定理）

```cpp
int exgcd(int a,int b,int & x,int & y){
    if(b==0)return x=1,y=0,a;
    int t=exgcd(b,a%b,y,x);
    return y=y-x*(a/b),t;
}
```

## 算法过程

扩欧实际上就是类似辗转相除法的递归。我们知道
$$
ax_1+by_1=gcd(a,b)\\
bx_2+(a\bmod b)y_2=gcd(b,a\bmod b)
$$
假设现在我们已经求得$x_2,y_2$的一组特解，现在我们用$x_2,y_2$来推出$x_1,y_1$.

显然，$gcd(a,b)=gcd(b,a\bmod b)$，因此
$$
ax_1+by_1=bx_2+(a\bmod b)y_2\\
ax_1+by_1=bx_2+\left(a-\left\lfloor\frac{a}{b}\right\rfloor b\right)y_2\\
a(x_1-y_2)+b\left(y_1-x_2+\left\lfloor\frac{a}{b}\right\rfloor y_2\right)=0
$$
于是对应项系数为0,可以得出
$$
\left\{\begin{split}
x_1&=y_2\\
y_1&=x_2-\left\lfloor\frac{a}{b}\right\rfloor y_2
\end{split}\right.
$$
于是递归求解即可

# [LuoguP1516] 青蛙的约会

> 给定 x,y,m,n,l, 求最小的**正整数**t，使 $x+mt\equiv y+nt(\bmod l)$

由等式：

$$
x+mt=y+nt+kl(k\in Z)\\
kl+t(n-m)=x-y
$$

如果 $gcd(l,n-m)|x-y$，则 exgcd 求解方程，否则方程无整数解。

令 $p=n-m,q=x-y$，得到 $kl+tp=q$.令 $g=gcd(p,l)$，则 $g|l,g|q$。

若 $g|q$, 不定方程有整数解；否则无整数解（Impossible）。

若原方程有解整数解，则令 $l'=l/g,p'=p/g,q'=q/g$ 。

所以 $kl'+tp'=q'$ 与原方程同解。又因为 $gcd(p',l')=1$，所以可用扩欧求解 $kl'+tp'=1$，进而求解 $kl'+tp'=q'$, 再取最小整数解即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,m,n,l;
long long exgcd(long long a,long long b,long long & x,long long & y){
	if(b==0)return x=1,y=0,a;
	long long t=exgcd(b,a%b,y,x);
	return y=y-(a/b)*x,t;
}
int main(){
	scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l);
	long long p=n-m,q=x-y,k,t;
	long long g=exgcd(p,l,t,k);
	if(q%g)puts("Impossible");
	else {
		long long r=l/g;
		printf("%lld",(q/g*t%r+r)%r);
	}
	return 0;
}
```

# 类欧几里得算法

类欧算法的本质就是类似辗转相除法的递归求解过程

## 辗转相除法的应用

考虑以下式子的求和
$$
f(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor
$$

### 取模

首先可以将 $a,b$ 对 $c$ 取模：
$$
\begin{split}
f(a,b,c,n)&=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor\\

&=\sum_{i=0}^n\left\lfloor
\frac{\left(\left\lfloor\frac{a}{c}\right\rfloor c+a\bmod c\right)i+\left(\left\lfloor\frac{b}{c}\right\rfloor c+b\bmod c\right)}{c}
\right\rfloor\\

&=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+
\sum_{i=0}^n\left\lfloor
\frac{\left(a\bmod c\right)i+\left(b\bmod c\right)}{c}
\right\rfloor\\

&=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor
+(n+1)\left\lfloor\frac{b}{c}\right\rfloor
+f(a\bmod c,b\bmod c,c,n)
\end{split}
$$

### 递归式

那么考虑 $a<c,b<c$ 的情况
$$
\begin{split}
f(a,b,c,n)&=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor
=\sum_{i=0}^n\sum_{j=0}^{\left\lfloor \frac{ai+b}{c} \right\rfloor-1}1\\
&=\sum_{j=0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1}
\sum_{i=0}^n\left[j<\left\lfloor \frac{ai+b}{c} \right\rfloor\right]\\
\end{split}
$$
接下来化一下判断式，做一些放缩的处理
$$
\begin{split}
j<\left\lfloor \frac{ai+b}{c} \right\rfloor
&\Leftrightarrow j+1\leq \frac{ai+b}{c}\\
&\Leftrightarrow jc+c-b-1< ai\\
&\Leftrightarrow \left\lfloor\frac{jc+c-b-1}{a}\right\rfloor< i\\
\end{split}
$$

令$m=\left\lfloor \frac{an+b}{c} \right\rfloor$，那么原式化为
$$
\begin{split}
f(a,b,c,n)&=\sum_{j=0}^{m-1}
\sum_{i=0}^n\left[ i>\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor \right]\\
&=\sum_{j=0}^{m-1}
n-\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor\\
&=nm-f\left(c,c-b-1,a,m-1\right)
\end{split}
$$


## 扩展

再考虑以下两个函数	
$$
g(a,b,c,n)=\sum_{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor\\
h(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2
$$

### 推导 g

对于 $g$，先取模：
$$
g(a,b,c,n)
=g(a\bmod c,b\bmod c,c,n)+\left\lfloor\frac{a}{c}\right\rfloor\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor\frac{n(n+1)}{2}
$$
考虑 $a<c,b<c$ 的情况，令 $m=\left\lfloor\frac{an+b}{c}\right\rfloor, t=\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor$.
$$
\begin{split}
&g(a,b,c,n)=\sum_{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor\\
&=\sum_{j=0}^{m-1}
\sum_{i=0}^n\left[j<\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\cdot i
=\sum_{j=0}^{m-1}\sum_{i=0}^n[i>t]\cdot i\\

&=\sum_{j=0}^{m-1}\frac{1}{2}(t+n+1)(n-t)\\
&=\frac{1}{2}\left[mn(n+1)-\sum_{j=0}^{m-1}t^2-\sum_{j=0}^{m-1}t\right]\\
&=\frac{1}{2}[mn(n+1)-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)]
\end{split}
$$

### 推导 h

取模：
$$
\begin{split}
h(a,b,c,n)&=h(a\bmod c,b\bmod c,c,n)\\
&+2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n)
+2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)\\
&+\left\lfloor\frac{a}{c}\right\rfloor^2\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor^2(n+1)
+\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor n(n+1)
\end{split}
$$
考虑 $a<c,b<c$ 的情况， $m=\left\lfloor\frac{an+b}{c}\right\rfloor, t=\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor$.

先把 $n^2$ 拆一下：$n^2=2\frac{n(n+1)}{2}-n=\left(2\sum_{i=0}^ni\right)-n$.
$$
\begin{split}
&h(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2
=\sum_{i=0}^n\left( 2\sum_{j=1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j \right)-\left\lfloor\frac{ai+b}{c}\right\rfloor\\
=&\left(2\sum_{i=0}^n\sum_{j=1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j\right) -f(a,b,c,n)
\\

\end{split}
$$
接下来化一下和式
$$
\begin{split}
&\sum_{i=0}^n\sum_{j=1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j\\
=&\sum_{i=0}^n\sum_{j=0}^{\left\lfloor \frac{ai+b}{c} \right\rfloor-1}(j+1)\\
=&\sum_{j=0}^{m-1}(j+1)
\sum_{i=0}^n\left[j<\left\lfloor \frac{ai+b}{c} \right\rfloor\right]\\
=&\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n[i>t]\\
=&\sum_{j=0}^{m-1}(j+1)(n-t)\\
=&\frac{1}{2}nm(m+1)-\sum_{j=0}^{m-1}(j+1)\left\lfloor \frac{jc+c-b-1}{a} \right\rfloor\\
=&\frac{1}{2}nm(m+1)-g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)
\end{split}
$$
因此原式即为
$$
h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)
$$

## 小结

回顾三个式子的取模
$$
\begin{split}
&\begin{split}f(a,b,c,n)=f(a\bmod c,b\bmod c,c,n)+\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor
+(n+1)\left\lfloor\frac{b}{c}\right\rfloor\end{split}\\

&\begin{split}g(a,b,c,n)=g(a\bmod c,b\bmod c,c,n)+\left\lfloor\frac{a}{c}\right\rfloor\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor\frac{n(n+1)}{2}\end{split}\\

&\begin{split}
h(a,b,c,n)&=h(a\bmod c,b\bmod c,c,n)\\
&+2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n)
+2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)\\
&+\left\lfloor\frac{a}{c}\right\rfloor^2\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor^2(n+1)
+\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor n(n+1)
\end{split}

\end{split}
$$
三个式子的迭代
$$
\begin{split}
f(a,b,c,n)&=nm-f\left(c,c-b-1,a,m-1\right)\\
g(a,b,c,n)&=\frac{1}{2}[mn(n+1)-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)]\\
h(a,b,c,n)&=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)
\end{split}
$$
在计算的时侯，因为3个函数各有交错递归，因此可以考虑三个一起整体递归来求，否则有很多项会被多次计算。或者采用记忆化。

模板：Luogu5170

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int P= 998244353;
int i2= 499122177,i6= 166374059;
struct data{
    data(){f=g=h=0;}
    int f,g,h;
};//三个函数打包
data calc(int n,int a,int b,int c) {
    int ac=a/c,bc=b/c,m=(a*n+b)/c,n1=n+1,n21=n*2+1;
    data d;
    if(a==0){//迭代到最底层
        d.f=bc*n1%P;
        d.g=bc*n%P*n1%P*i2%P;
        d.h=bc*bc%P*n1%P;
        return d;
    }
    if(a>=c||b>=c){//取模
        d.f=n*n1%P*i2%P*ac%P+bc*n1%P;
        d.g=ac*n%P*n1%P*n21%P*i6%P+bc*n%P*n1%P*i2%P;
        d.h=ac*ac%P*n%P*n1%P*n21%P*i6%P+bc*bc%P*n1%P+ac*bc%P*n%P*n1%P;
        d.f%=P,d.g%=P,d.h%=P;

        data e=calc(n,a%c,b%c,c);//迭代
        
        d.h+=e.h+2*bc%P*e.f%P+2*ac%P*e.g%P;
        d.g+=e.g,d.f+=e.f;
        d.f%=P,d.g%=P,d.h%=P;
        return d;
    }
    data e=calc(m-1,c,c-b-1,a);
    d.f=n*m%P-e.f,d.f=(d.f%P+P)%P;
    d.g=m*n%P*n1%P-e.h-e.f,d.g=(d.g*i2%P+P)%P;
    d.h=n*m%P*(m+1)%P-2*e.g-2*e.f-d.f;d.h=(d.h%P+P)%P;
    return d;
}
int T, n, a, b, c;
signed main() {
    scanf("%lld", &T);
    while(T--) {
        scanf("%lld%lld%lld%lld", &n, &a, &b, &c);
        data ans=calc(n,a,b,c);
        printf("%lld %lld %lld\n",ans.f,ans.h,ans.g);
    }
    return 0;
}
/*
 * BUG#1: 在取模迭代的时侯，d.h忘加了e.h
 * BUG#2: 在对P取模的时侯没有+P，产生了负数
 */
```

