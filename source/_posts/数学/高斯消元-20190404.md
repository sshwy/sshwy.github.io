---
title: 高斯消元
mathjax: true
abbrlink: 49612
categories:
  - 数学
date: 2019-04-04 22:40:06
updated: 2019-04-05 08:45:06
tags:
keywords:
---


**摘要**

一种求解线性方程组的算法


<!--more-->

# 概述

高斯消元没什么好讲的，原理就是解方程组的那种方法（其实是先咕着）

贴一个洛谷板子

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
int n;
double a[N][N],b[N];
bool Gauss(){
	for(int i=1;i<=n;i++){//消第i个元
		for(int j=i;j<=n;j++){//找到第i个元系数不为0的方程
			if(fabs(a[j][i])>1e-8){
				for(int k=1;k<=n;k++)swap(a[j][k],a[i][k]);
				swap(b[j],b[i]);
				break;
			}
		}
		if(fabs(a[i][i])<1e-8)return 0;//无解
		//消元
		for(int j=1;j<=n;j++){//消去第j个方程的元
			if(i==j)continue;
			double rate=a[j][i]/a[i][i];
			for(int k=i;k<=n;k++)a[j][k]-=a[i][k]*rate;
			b[j]-=b[i]*rate;
		}
	}
	return 1;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)scanf("%lf",&a[i][j]);
		scanf("%lf",&b[i]);
	}
	if(!Gauss())puts("No Solution");
	else for(int i=1;i<=n;i++)printf("%.2lf\n",b[i]/a[i][i]);
	return 0;
}
```

# [JSOI2008]球形空间产生器

> 给出在$n$维空间中的球面上 $n+1$ 个点的坐标$(a_{i,1},a_{i,2},\cdots,a_{i,n})$，确定这个 $n$ 维球体的球心坐标.
>
> 距离：对于n维空间中两点$(a_1,a_2,\cdots,a_n),(b_1,b_2,\cdots,b_n)$，两者距离为$\sqrt{\sum_{i=1}^n(a_i-b_i)^2}$.

设球心的坐标为$(c_1,c_2,\cdots,c_n)$.那么对于两个球面上的点$(a_1,a_2,\cdots,a_n),(b_1,b_2,\cdots,b_n)$有
$$
\sum_{i=1}^n(a_i-c_i)^2=\sum_{i=1}^n(b_i-c_i)^2
$$
化简得
$$
\sum_{i=1}^n2(a_i-b_i)\cdot c_i=\sum_{i=1}^n(a_i^2-b_i^2)
$$
显然这是一个关于$c_i$的线性方程.那么$n+1$个球面坐标可以列出$n$个方程构成线性方程组，高斯消元即可.

```cpp
#include<bits/stdc++.h>
#define FOR(a,b,c) for(int a=b;a<=c;a++)
using namespace std;
const int N=12;
int n;
double a[N][N],c[N][N],b[N];
void Gauss(){
	FOR(i,1,n){
		FOR(j,i,n)if(fabs(c[j][i])>1e-8){
			FOR(k,1,n)swap(c[j][k],c[i][k]);
			swap(b[i],b[j]);
			break;
		}
		FOR(j,1,n){
			if(i==j)continue;
			double rate=c[j][i]/c[i][i];
			FOR(k,i,n)c[j][k]-=c[i][k]*rate;
			b[j]-=b[i]*rate;
		}
	}
}
int main(){
	scanf("%d",&n);
	FOR(i,1,n+1)FOR(j,1,n)scanf("%lf",&a[i][j]);
	FOR(i,1,n)FOR(j,1,n){//构造第i个方程
		c[i][j]=2*(a[i][j]-a[i+1][j]);
		b[i]+=a[i][j]*a[i][j]-a[i+1][j]*a[i+1][j];
	}
	Gauss();
	FOR(i,1,n)printf("%.3lf ",b[i]/c[i][i]);
	return 0;
}
```

