---
title: SCOI2008奖励关
tags:
 - 期望
 - DP
categories:
  - 数学
mathjax: true
abbrlink: 25810
date: 2019-01-17 08:33:50
updated: 2019-01-17 08:33:50
---

# 题意

在奖励关里，系统将依次随机抛出k次宝物，每次你都可以选择吃或者不吃。宝物一共有n种，第k次抛出各个宝物的概率均为$\frac{1}{n}$。

获取第 i 种宝物将得到$P_i$分（$P_i$ 可以是负数），但第i种宝物有一个前提宝物集合$S_i$。只有当Si中所有宝物都至少吃过一次，才能吃第i 种宝物，如果系统抛出了一个目前不能吃的宝物，相当于损失一次机会

假设你采取最优策略，平均情况你一共能在奖励关得到多少分值？

$1 \leq k \leq 100, 1 \leq n \leq 15$.

# 分析

定义$f[i,j]$表示第$1\sim i-1$轮吃过的状态为$j$，第$i\sim k$轮的期望平均得分

那么采用倒推的方式，我们考虑$f[i,j]$由$f[i+1,j']$转移：

1. 如果$a(1\leq a\leq n)$的前提宝物都被吃过：
   1. 那么就能吃$a$：$f[i+1,j|2^{a-1}]+P_a$.
   2. 选择不吃：$f[i+1,j]$.

1. 否则就不能吃$a$，期望为$f[i+1,j]$.

这里的关系是等价的，也就是说，$a$是否能吃是固定的，那么1,2是相互独立的，概率各自为1/0.

而吃或不吃是没有概率之分的，那么1.1和1.2是独立的，选取最大值.

也就是说，对于一个宝物只会在三者中选择一个来贡献

贡献完之后再除以n就是平均值.

# 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=15,K=102;
int k,n;
int p[N],s[N];
double f[K][1<<N];

int main(){
    scanf("%d%d",&k,&n);
    for(int i=1,x;i<=n;i++){
        scanf("%d",&p[i]);
        while(~scanf("%d",&x)&&x)s[i]|=1<<x-1;
    }
    int mxj=1<<n;
    for(int i=k;i>=1;i--){
        for(int j=0;j<mxj;j++){
            for(int a=1;a<=n;a++){
                if((j|s[a])==j)f[i][j]+=max(f[i+1][j],f[i+1][j|1<<(a-1)]+p[a]);
                else f[i][j]+=f[i+1][j];
            }
            f[i][j]/=n;
        }
    }
    printf("%lf",f[1][0]);
    return 0;
}
```

