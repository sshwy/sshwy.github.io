---
title: SCOI2010幸运数字
mathjax: true
abbrlink: 48089
categories:
  - 数学
date: 2019-05-01 08:37:54
updated: 2019-05-01 08:37:54
tags:
keywords:
---

**摘要**

幸运数字：只包含数字6和8的那些号码。近似幸运数字：幸运数字的倍数。求$a\sim b$的近似幸运数字的个数。

$a\leq b\leq 10^{10}$.

<!--more-->

首先想到的就是容斥，考虑预处理所有的近似幸运数字，直接容斥是自闭的。做一下剪枝

如果$lcm\geq b$，直接退出；如果两个幸运数字$x,y$满足$x|y$，那么$y$就是没有意义的，因此可以预处理直接筛掉；将剩下的按从大到小排序以更快到达边界

做了上述剪枝可以拿70.还有什么需要剪的吗？

每一次合并lcm的时侯，lcm至少乘2.因此对于那些$\frac{b}{2}<x\leq b$的近似幸运数字$x$，他们不可能和别的幸运数字做容斥，只能自己做贡献，于是直接算这些贡献，剩下的再来容斥即可。

```cpp
#include <algorithm>
#include <cstdio>
#define int long long
using namespace std;
const int N = 1e5;
int a, b, ans;
int c[N], lc;

void dfs(int x) {
    c[++lc] = x;
    if (x * 10 + 6 > b) return;
    dfs(x * 10 + 6), dfs(x * 10 + 8);
}
void sieve() {
    int tmp[N], lt = 0;
    for (int i = 1; i <= lc; i++) {
        for (int j = 1; j <= lt; j++) {
            if (c[i] % tmp[j]) continue;
            c[i] = 0;
            break;
        }
        if (c[i] > b / 2) ans += b / c[i] - (a - 1) / c[i], c[i] = 0;
        if (c[i]) tmp[++lt] = c[i];
    }
    for (int i = 1; i <= lt; i++) c[i] = tmp[i];
    lc = lt;
}
void prework() {
    dfs(0);
    sort(c + 1, c + lc + 1);
    sieve();
}
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
void dfs(int k, int last, int lcm) {
    if (k != 0) ans += (k % 2 * 2 - 1) * (b / lcm - (a - 1) / lcm);
    for (int i = last - 1; i > 0; i--) {  //倒序
        int g = gcd(lcm, c[i]);
        g = lcm * c[i] / g;
        if (g <= b) dfs(k + 1, i, g);
    }
}
signed main() {
    scanf("%lld%lld", &a, &b);
    prework();
    dfs(0, lc + 1, 1);
    printf("%lld", ans);
    return 0;
}
```

