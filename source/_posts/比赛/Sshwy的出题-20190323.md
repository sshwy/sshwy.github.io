---
title: Sshwy 的出题
mathjax: true
abbrlink: 44134
categories:
  - 比赛
keywords: 'Sailor Jack, SJ, sailorjack'
date: 2019-03-23 09:43:02
updated: 2019-04-05 18:30:40
tags:
---

**摘要**

sshwy 出题啦

<!--more-->

{% encrypt jxrquiz %}

# 切

## Background

$SailorJack$ 被迫来到了异世界，异世界住着可爱善良的外星人。

$SailorJack$ 与外星人语言相同，但是异世界光线暗淡，没有人眼可见光，外星人通过感知红外线作为视觉，然而 $SailorJack$ 肉眼显然看不到红外线，于是他只能通过听觉和触觉与外星人交流。

## Description

$SailorJack$ 喜欢和外星人在一起吃蛋糕。但是作为人类的他看不到蛋糕的形状，他只知道，外星人切蛋糕的每一刀一定会沿着蛋糕的某一条对称轴切，直到所有对称轴都被切过了才结束切蛋糕。

现在外星人已经切了两刀了，并且这两刀所在直线的夹角为 $\alpha$，$SailorJack$ 想知道，外星人最少还要切多少刀？（即，这个图形最少可能有多少条对称轴）

##  Task

### Input

多组数据，第一行一个整数 $T$ 表示数据组数

随后每一行两个整数数 $p,q$ 表示夹角，其中 $\alpha=\frac{p}{q}$，$\alpha$ 单位为角度 $^{\circ}$，**不是弧度**。

### Output

$T$ 行，每行一个数表示最少还要切多少刀

## Sample

### Input

```
1
90 1
```

### Output

```
0
```

### Explanation

外星人切的可能是矩形的蛋糕。当然你说是圆形蛋糕也行，但是圆形就有无限条对称轴，显然不是最少的。

## Constraint

对于 $100\%$ 的数据，$T\leq10^5,1\leq p,q\leq 10^9,0<\alpha\leq90$.

时空限制： $1s,128MB$.

# 蛋

## Background

$SailorJack$ 渐渐习惯了异世界的生活，他还是最喜欢和外星人在一起吃蛋糕。

## Description

今天是 $SJ$ 到异世界的周年庆！为此，友好的外星人们做了许多蛋糕来庆祝。在一个长桌上摆了一排蛋糕，每个蛋糕上面都有一个小写字母。

$SJ$ 希望把蛋糕序列分成连续的几段，使得**每一段**中的不同字符个数都为一个给定的数字 $k$；同时 $SJ$ 希望分得的段数尽量少。现在 $SJ$ 想知道，对于蛋糕序列的每一个前缀，最少可以分为几段？

## Task

### Input

第一行一个数 $k$.

第二行一个字符串 $s$ 表示蛋糕序列上的字符。

### Output

一行一共 $|s|$ 个整数，第 $i$ 个整数表示前 $i$ 个字符组成的前缀子串按 $SJ$ 的要求划分为若干段的最少段数，如果不存在合法方案输出 -1.

## Sample

### Input

```
2
cbbaaacbaa
```

### Output

```
-1 1 1 2 2 2 2 3 3 3
```

## Constraint

对于 $10\%$ 的数据，$|s|\leq 100$.

对于 $20\%$ 的数据，$|s|\leq 1000$.

对于 $100\%$ 的数据，$|s|\leq 5\times 10^6,k\leq 26$.

# 糕

## Background

$SailorJack$ 正在练习盲切蛋糕

## Description

$SailorJack$ 面前有一个巨大的圆形蛋糕，同时他选择了 $n$ 个点，按顺时针标号 $1\sim n$. 他的手里也有一把巨大的刀.$SJ$ 每次选择其中的两个点，并沿着两点的连线切一刀，并且每个点他至多选一次。

我们假定无论 $SJ$ 怎么切，都不会出现三条或以上的切痕交于同一点的情况。现在 $SJ$ 切了若干刀，你想知道两两切痕交点的数量。

由于 $SJ$ 看不见蛋糕，所以他只能盲切，所以你需要求在模 $998244353$ 意义下，交点个数的期望。

## Task

### Input

一行一个正整数 $n$.

### Output

一行一个整数表示交点个数的期望。

## Sample

### Input

```
4
```

### output

```
299473306
```

### Explanation

![n=2](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/03/26/2052.png)

一共有 $10$ 种情况，而总共 $1$ 个交点，期望为 $\frac{1}{10}$.（逆元一下）

## Constraint

对于 $30\%$ 的数据，$n\leq 14$.

对于 $100\%$ 的数据，$n\leq 1000$.

时空限制： $2s,128MB$.

{% endencrypt %}

# Solution

## 切

{% encrypt jxrquizsolone %}

不难证明，一个轴对称图形要么只有一条对称轴，要么所有对称轴交于一点；

对称轴可以相互对称出来，因此对于一个对称轴，其左右夹角为 $\alpha$ 也分别存在一个对称轴。因此可以顺时针逆时针一直对称下去，直到与已有的对称轴重合。显然这是一个 GCD 问题，即
$$
\frac{pk}{q}=180m
$$
其中 $k,m\in\mathbb{N}$.$m$ 为任意值，我们需要求解 $k$ 的最小值，即
$$
k=\frac{180qm}{p}=\frac{lcm(180q,p)}{p}\frac{180q}{gcd(180q,p)}
$$

简单处理一下即可

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int gcd(int a,int b){return b?gcd(b,a%b):a;}

signed main(){
    ios::sync_with_stdio(false);
    int t,p,q;
    cin>>t;
    while(t--){
        cin>>p>>q;
        cout<<180*q/gcd(180*q,p)-2<<endl;
    }
    return 0;
}
```

{% endencrypt %}

## 蛋

{% encrypt jxrquizsoltwo %}

考虑 DP，$f[i]$ 表示第 i 个前缀的最少段数
$$
f[i]=\min_{j=0}^{i-1}\{f[j]+1|\text{ while }s[j+1,i]\text{is a good string}\}.
$$
直接计算，复杂度 $O(n^2)$.

观察到字符串越长，不同字符数越多（单调性）因此合法的转移状态是连续的一段，并且随着 i 自增，这一个状态空间的上下界也是递增的（非严格）。

因此对于每个 i，我们维护合法的转移区间 $[L_i,R_i]$；当 i 增加时更新 $[L_i,R_i]$. 我们维护每个 i 的各个字符的最后出现的位置，就可以在常数时间内更新 $L_i,R_i$，而由于单调性，因此单调队列即可

复杂度 $O(n)$.

### 50pts

某处拉来的某神奇代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,i,j,l,t,q[1111],f[5000005]; string st;
int main(){
	scanf("%d",&m);
    cin>>st;
    st=" "+st,l=st.size();
    memset(f,127,sizeof(f));
    f[0]=0;
	for (i=1;i<l;i++){
		memset(q,0,sizeof(q)); t=0;
		for (j=i;j>=1;j--){
			q[st[j]]++;
			if (q[st[j]]==1) t++;
			if (t==m) f[i]=min(f[i],f[j-1]+1);
			if (t>m) break;
		}
		printf("%d\n",f[i]>999999999?-1:f[i]);
	}
}
```

### 标程

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e6+5;
int m,f[N];
struct counter{
	int t[N],cnt;
	void add(int x){cnt+=t[x]==0,t[x]++;}
	void del(int x){t[x]--,cnt-=t[x]==0;}
};// 每个字符的出现次数，出现的不同字符数
counter cl,cr;// 当前最长好串和最短好串的计数器
char s[N];
int q[N],ql,qr;// 单调队列

int main(){
	scanf("%d%s",&m,s+1);
	int l=1,r=1;// 合法的转移状态区间，初始化为 1
	for(int i=1;s[i];i++){
		cl.add(s[i]),cr.add(s[i]);// 第 i 个字符累加次数
		f[i]=-1;// 先初始化为 -1
		if(cl.cnt<m)continue;// 最长的好串的出现次数都达不到，则继续添加字符
		while(cl.cnt>m)cl.del(s[l]),++l;// 直到大于 m 才删除
		while(cr.cnt>=m)cr.del(s[r]),++r;// 只要大于等于 m 就删除
		--r,cr.add(s[r]);// 最后补回来一个，构成最短好串
		//printf("\033[32mi:%d, [%d,%d] \n\033[0m",i,l,r);
		// 因此可转移的区间为 [l-1,r-1]
		while(ql<=qr&&q[ql]<l-1)++ql;// 排除队首过时的决策
		for(int j=q[qr]+1;j<r;j++){// 添加{f[j]}进单调队列
			if(f[j]==-1)continue;// 这个决策不可用
			//printf("[query]add(%d:%d)\n",j,f[j]);
			while(ql<=qr&&f[q[qr]]>=f[j])--qr;
			q[++qr]=j;
		}
		// 最后更新当前的值
		if(ql<=qr)f[i]=f[q[ql]]+1;
		//printf("\033[41mf[%d]:%d\n\033[0m",i,f[i]);
	}
	for(int i=1;s[i];i++)printf("%d ",f[i]);
	return 0;
}
```

{% endencrypt %}

## 糕

{% encrypt jxrquizsolthree %}

### 30pts

考虑暴力枚举每一种切蛋糕的情况，对每种情况统计交点个数，累加到和中，最后用总的交点数乘上情况总数的逆元就是答案。

统计交点个数相当于 $O(n^2)$ 判断线段是否相交。比较一下端点的标号大小即可。

复杂度 $O(S(n)\cdot n^2)$. 其中 $S(n)$ 表示情况总数。

### 100pts

连一条直线需要两个点，因此所消耗的点总是偶数个。当 $n$ 为偶数时，所有点可以恰好被用完，而当 $n$ 为奇数时，至少会剩下一个点。

我们考虑分别计算交点个数和情况总数。

### 强制切满

假设我们用 $2n$ 个点，且我们要求所有的点都被选一次，即我们**强制要求**切 $n$ 刀。

设 $2n$ 个带标号的点切 $n$ 刀的情况总数为 $f\left(n\right)$. 易知
$$
\begin{split}
f(0)&=f(1)=1\\
f(i)&=(2i-1)f(i-1)\\
f(i)&=\prod_{j=1}^i(2j-1)
\end{split}
$$
接下来考虑切 $n​$ 刀每种情况交点数的总和，考虑每一条线的贡献。对于一条线，假设它左右分别有 $a,b​$ 个点。显然 $a,b​$ 同奇偶且 $a+b=2n-2​$. 我们枚举两边有多少条直线跨过这一条线。

当 $a,b$ 为偶数时，为了使得所有点都有连线，那么就一定有偶数条先穿过这条线，因此贡献为 $2i$，连线的方案数为 $(2i)!$ 此时要在左右分别选 $2i$ 个点，因此方案数为 $C_a^{2i}\times C_b^{2i}$，剩下的点自己连接，有 $f\left(\frac{a-2i}{2}\right)f\left(\frac{b-2i}{2}\right)$ 种方案，因此总的贡献为
$$
\sum_{i=1}^{\frac{1}{2}\min(a,b)}f\left(\frac{a}{2}-i\right)f\left(\frac{b}{2}-i\right)C_a^{2i}C_b^{2i}(2i)!\cdot2i
$$
$a,b$ 为奇数同理，相当于至少连一条线
$$
\sum_{i=0}^{\frac{1}{2}\min(a-1,b-1)}f\left(\frac{a-1}{2}-i\right)f\left(\frac{b-1}{2}-1\right)C_a^{2i+1}C_b^{2i+1}(2i+1)!\cdot(2i+1)
$$
预处理一下，这个可以 $O(a)$ 做。最后由于每个交点与两条直线有关，即每个点被算了两次，所以要除以 2

把上面的结果整理一下，就是强制切满时的答案。

### 当 $n$ 为一般情况

相当于在所有点里面选择偶数个点强制切满，套一个组合数就行了

至于情况总数，把 $f$ 套一个组合数贡献一下就行

总复杂度 $O(n^3)$.

标程

```cpp
#include<bits/stdc++.h>
#define FOR(a,b,c) for(register int a=b;a<=c;a++)
#define int long long
using namespace std;
const int N=5e3+5,P=998244353;
int f[N],fac[N],C[N][N];
int g[N];// 切 n 刀用 2n 个点的方案数
int pw(int a,int m){
	int res=1;
	while(m){
		if(m&1)res=res*a%P;
		a=a*a%P,m>>=1;
	}
	return res;
}
int n;
int calc(int a,int b){//a,b 同奇偶
	int res=0,a2=a/2,b2=b/2;
	if(a%2==0){
		int lim=min(a2,b2);
		FOR(i,1,lim){
			int x=f[a2-i]*f[b2-i]%P,y=C[a][i*2]*C[b][i*2]%P,z=fac[i*2]*(i*2)%P;
			int t=(x*y%P)*z%P;
			res=(res+t)%P;
		}
	}
	else {
		int lim=min(a2,b2);
		FOR(i,0,lim){
			int x=f[a2-i]*f[b2-i]%P,y=C[a][i*2+1]*C[b][i*2+1]%P,z=fac[i*2+1]*(i*2+1)%P;
			int t=(x*y%P)*z%P;
			res=(res+t)%P;
		}
	}
	return res;
}
signed main(){
	scanf("%lld",&n);
	f[0]=f[1]=1;
	FOR(i,2,n)f[i]=f[i-1]*(2*i-1)%P;
	C[0][0]=1;
	FOR(i,1,n){// 组合数
		C[i][0]=1;
		FOR(j,1,i)C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;
	}
	fac[0]=1;
	FOR(i,1,n)fac[i]=fac[i-1]*i%P;// 阶乘
	int inv2=pw(2,P-2);
	FOR(i,1,n){// 计算 g[i]
		FOR(j,1,i-2)g[i]+=i*2*calc(j,i*2-2-j)%P,g[i]%=P;
		g[i]+=i*calc(i-1,i-1)%P,g[i]%=P;
		g[i]=g[i]*inv2%P;
	}
	int p=0,q=1;
	FOR(i,1,n/2){
		p=(p+C[n][i*2]*g[i])%P;
		q=(q+C[n][i*2]*f[i])%P;
	}
	//printf("p:%lld,q:%lld\n",p,q);
	printf("%lld",p*pw(q,P-2)%P);
	return 0;
}
```

30 分暴力

```cpp
#include<bits/stdc++.h>
#define int long long
#define FOR(a,b,c) for(int a=b;a<=c;a++)
using namespace std;
const int N=15,P=998244353;
int n,r,q;
bool vis[N];
struct point{
	int x,y;
	point(int _x=0,int _y=0){x=_x,y=_y;}
};
point p[N];
void print(int k){
	printf("{");
	for(int i=1;i<=k;i++)printf("[%lld,%lld],",p[i].x,p[i].y);
	printf("\b}\n");
}
void calc(int k){
	++q;// 一个方案
	for(int i=1;i<=k;i++){
		for(int j=i+1;j<=k;j++){
			if(p[i].x<p[j].x&&p[j].x<p[i].y&&p[i].y<p[j].y)++r;
			if(p[j].x<p[i].x&&p[i].x<p[j].y&&p[j].y<p[i].y)++r;
		}
	}
}
void dfs(int k,int lst){
	for(int i=lst+1;i<=n;i++)if(!vis[i]){
		for(int j=i+1;j<=n;j++)if(!vis[j]){
			p[k]=point(i,j);
			vis[i]=vis[j]=1;
			calc(k);
			dfs(k+1,i);
			vis[i]=vis[j]=0;
		}
	}
}
int pw(int a,int m){
	int res=1;
	while(m){
		if(m&1)res=res*a%P;
		a=a*a%P,m>>=1;
	}
	return res;
}
signed main(){
	scanf("%lld",&n);
	++q;//0 的情况
	dfs(1,0);
	printf("%lld",r*pw(q,P-2)%P);
	return 0;
}
```

{% endencrypt %}
