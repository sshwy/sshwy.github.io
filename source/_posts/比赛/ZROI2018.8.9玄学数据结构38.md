---
title: ZROI2018.8.9 玄学数据结构
categories:
  - 比赛
mathjax: true
abbrlink: 44813
date: 2018-10-01 20:22:00
updated: 2018-10-01 20:22:00
---
# 数据结构模拟赛
题面 [A][1] [B][2] [C][3]
## A. 黑桃城
直接 DFS 遍历树。子树的 DFN 序是连续的，因此转化为区间上维护，线段树即可。

## B. 红五月
树剖，详细毒瘤的分类讨论

## C. 海棠溪
### Subtask1-3
- 动态规划，定义 f[i,j] 表示两朵花分别位于选择的第 i，j 个人手中（令 i>j）
- 使用滚动数组优化空间。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int INF=999999999;
const int N=200005;
int n,t,a,b;
int p[N];
int f[2][N];
int mabs(int x){return x<0?0-x:x;}
int main(){
    scanf("%d%d%d%d",&n,&t,&a,&b);
	p[0]=a,p[1]=b;
	for(int i=2;i<=t+1;i++)scanf("%d",&p[i]);
	for(int i=0;i<=1;i++)
		for(int j=0;j<=t+1;j++)
			f[i][j]=INF;
	f[1][0]=0;
	for(int i=1;i<=t+1;i++){
        for(int j=0;j<=t+1;j++)f[(i+1)&1][j]=INF;
		for(int j=0;j<=i;j++){
            f[(i+1)&1][i]=min(f[(i+1)&1][i],f[i&1][j]+mabs(p[i+1]-p[j]));
			f[(i+1)&1][j]=min(f[(i+1)&1][j],f[i&1][j]+mabs(p[i+1]-p[i]));
		}
	}
	int ans=INF;
	for(int i=0;i<=t+1;i++)ans=min(ans,f[(t+1)&1][i]);
	printf("%d",ans);
	return 0;
}
```
[1]: https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2018/08/616931843.pdf
[2]: https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2018/08/1391601213.pdf
[3]: https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2018/08/2158944400.pdf