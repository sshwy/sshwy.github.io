---
title: CFGoodBye2018
categories:
  - 比赛
mathjax: true
abbrlink: 30303
date: 2018-12-31 01:09:19
updated: 2018-12-31 01:09:19
tags:
---

# CF1091B

平均数一下

```cpp
#include<cstdio>
#include<iostream>
#define int long long
using namespace std;
int n,x,y;
signed main(){cin>>n;
	for(int i=1,a,b;i<=n*2;i++)cin>>a>>b,x+=a,y+=b;
	cout<<x/n<<" "<<y/n;
	return 0;
}
```

# CF1091C

题意：1-n 的环上走球，每次走的距离为 k，从 1 号走，直到回到 1，这过程中经过的人的编号之和为这次走球的价值（1 号只算一次），问所有可能的价值，从小到达输出

显然只用考虑 $k\leq n$ 的情况

如果 $gcd(k,n)=p$，那么只会经过 $1,1+p,1+2p,\cdots,n+1-p$，等差数列公式计算即可

那么问题转化为枚举 $gcd(k,n)$，即枚举 $n$ 的约数

首先 $O(\sqrt n)$ 分解质因数，然后在质因数表上 $DFS$ 枚举即可

因为 $10^9$ 以内的数的互不相同的质因子的个数不超过 10 个，所以复杂度很小

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
const int N=100005;
int n;
int p[N],c[N],cnt;
int ans[N],ant;
void dfs(int k,int cur){if(k>cnt)return;
	for(int i=0;i<=c[k];i++,cur*=p[k]){ans[++ant]=(n+2-cur)*n/cur/2;
		dfs(k+1,cur);
	}
}
signed main(){cin>>n;
	int n2=n;
	for(int i=2;i*i<=n2;i++){if(n2%i==0){p[++cnt]=i;
			while(n2%i==0)++c[cnt],n2/=i;
		}
	}
	if(n2!=1)p[++cnt]=n2,c[cnt]=1;
	dfs(1,1);
	sort(ans+1,ans+ant+1);
	for(int i=1;i<=ant;i++){if(ans[i]==ans[i-1])continue;
		cout<<ans[i]<<" ";}
	return 0;
}
```

# CF1091D

题意自见

总和为 $\frac{n(n+1)}{2}$，就是说 $n$ 个数刚好是 $1$ 到 $n$.

我们发现，两个相同的数字如果距离为 n，那么他们之间一定有这样的子串

定义 $f[n]$ 表示 n 个数的全排列的子串个数

对于以 $x$ 开头的这 $(n-1)!$ 个连在一起的全排列，除掉 $x$ 不看，剩下的 $n-1$ 个数其实就是 $1$ 到 $n-1$ 的全排列（离散化的思想），而这 $1$ 到 $n-1$ 的全排列两两之间加了一个数字 $x$，对子串的性质没有影响，也就有 $f[n-1]$ 个 $n$ 的子串

这是从 $f[n-1]$ 推过来的，那么有没有新产生的不属于 $f[n-1]$ 的 $n$ 的子串呢？

有。所谓属于 $f[n-1]​$ 的 $n​$ 的子串，其实就是在 $n-1​$ 的子串的前缀或中间插入 $x​$ 来转化；但是这不包括在它的末尾插入 $x​$，因为 $x​$ 是开头的数

因此，在 $n-1$ 子串的末尾插入 $x$ 的序列，有 $(n-1)!-1$ 个（最后一个全排列的末尾没有 1 了），累加即可

最后，有多少个 $x$ 呢？显然有 $n$ 个，那么递推如下
$$
f_n=n\cdot(f_{n-1}+(n-1)!-1)
$$

```cpp
#include<cstdio>
using namespace std;
const int N=1e6+6,P=998244353;
int n;
int f[N],fac[N];
int main(){scanf("%d",&n);
	f[1]=1,fac[1]=1;
	for(int i=2;i<=n;i++){fac[i]=(long long)fac[i-1]*i%P;
		f[i]=(long long)i*(f[i-1]+fac[i-1]-1)%P;
	}
	printf("%d",f[n]);
	return 0;
}
```

