---
title: 'ZROI 提高组 Day5'
categories:
  - 比赛
mathjax: true
abbrlink: 45139
date: 2018-10-01 20:22:00
updated: 2018-10-01 20:22:00
---
# 小结：暴力 & 优化

- **心态不能炸，暴力不能丢**
- 对于每一个数据范围都要思考，从算法复杂度猜测入手，直到确定完整算法<!--more-->
- 对于下一个数据范围，考虑能否对上一个范围的算法做优化（比如 DP 优化）
- 优化大多数时候建立在**基础算法**上
- 不能放弃任何一道题，挂也要写个暴力吊着
- 对于需要建模的题目，构架数学模型（方程）再优化
- 对于玄学算法题目，做适当猜测结论，暴力验证
- 刚写完代码后切不能松懈，思考能否再优化
----------
# A. 数组计数
给定 $n,k$，你需要计算有几个长度为 $k$ 的数组 $a[1..k]$ 满足：
- 对于所有 $i\in [1,k]$，有 $a_i>0$
- 对于所有 $i\in [2,k]$，有 $a_i[geq \sum_{j=1}^{i-1}a_j$
- $\sum_{i=1}^{k}a_i=n$
由于方案数可能过多，你只需要输出答案对 $998244353$ 取模后的值

**输入格式**
第一行两个正整数 n,k
**输出格式**
输出一个非负整数，表示答案对 $998244353$ 取模后的值

**样例输入**
```
5 2
```
**样例输出**
```
2
```
**限制**
对于 30% 的数据，有 $1\leq k\leq 2$.
对于 50% 的数据，有 $1\leq n\leq 2000,1\leq k\leq8$.
另有 20% 的数据，满足 $n≤2^k+100$.
对于 100% 的数据，有 $1\leq n\leq 10^6,1\leq k\leq 20$.
时间限制：2s
空间限制：512MB

## Subtask1
$k\leq2$，直接乱搞......

## Subtask2
既然是 $n^2$ 的模样，想到 DP

$f[i,j]$ 表示长度为 $i$，总和为 $j$ 的数列的方案数， $f[i,j]=\sum_{k=1}^{\left \lfloor \frac{j}{2} \right \rfloor}f[i-1,k]$

总复杂度 $O(n^2k)$.

## Subtask3

大概是给暴搜的人一点福利......

暴搜的时候可以剪枝，考虑到整个序列的增长速度是 $2^k$ 级别（1,1,2,4,8,16...），所以长度为 i 的序列，总和肯定 $\geq 2^{i-1}$，所以搜索的时候剪个枝应该是可以拿到分的。

## Subtask4
显然在 Subtask2 的基础上前缀和优化一下，因为在 j 自增的时候，k 的范围是逐渐变大的，所以内层循环就不需要了，每次累加即可。

总复杂度 $O(nk)$.

```cpp
#include<cstdio>
using namespace std;
const int N=(int)1e6+2,K=20+2,P=998244353;
int n,k;
int ans,a[K+2];
int f[K][N];
//f[i,j] 长度为 i，总和为 j 时的方案数
int main(){
	scanf("%d%d",&n,&k);
	f[0][0]=1;
	for(int i=1;i<=k;i++){
		int mnj=1<<(i-1);//j 的最小值为 2^(i-1)（相当于一个剪枝）
		f[i][mnj]=f[i-1][mnj>>1];// 求和区间的第一个元素
		for(int j=(1<<(i-1))+1;j<=n;j++){
			if(j%2==0)f[i][j]=(f[i][j-1]+f[i-1][j/2])%P;// 范围扩大，累加
			else f[i][j]=f[i][j-1];// 即 j-1 时的 k 的范围
		}
	}
	printf("%d",f[k][n]);
	return 0;
}
```

----------
# B. 旅行
给定一棵 $n$ 个点的树，再给定一个长度为 $m$ 的序列 $a_1,a_2...a_m$.

你需要对每个 $i\in [1,m]$ 都求出一条最短的起点为 $1$，终点为 $a_i$ 的路径（可以多次重复经过同一点），使得 $a_1,a_2...a_{i−1}$ 都在这条路径上，你只需要输出符合条件的最短的路径上边的数量。

**输入格式**
第一行两个正整数 $n,m$
接下来 $n−1$ 行，每行两个正整数 $a,b$，表示一条边 $(a,b)$
接下来一行有 $m$ 个正整数，表示 $a_1,a_2...a_m$
**输出格式**
输出 m 行，第 i 行一个非负整数，表示题目中对 i 求的最短路径上边的数量

**样例输入**

```
4 3
1 2
2 3
2 4
4 3 1
```
**样例输出**
```
2
4
6
```
**限制**
对于 20% 的数据，有 1≤n,m≤5
对于 40% 的数据，有 1≤n,m≤10^3
另有 20% 的数据，满足给定的树是一条链，且 1 号点是端点
另有 20% 的数据，满足所有其他点都和 1 号点有边相连
对于 100% 的数据，有 1≤n,m≤10^5，保证 $a_i$ 互不相同
时间限制：2s
空间限制：512MB

## Subtask1
5 个点，直接暴搜。

## Subtask2
考虑 N 方级别的算法：

对于每一个 i，先把 $a_1\sim a_i$ 的点在树上找到并建树（相当于将 $a_j(1\leq j\leq i)$ 到根节点的路径上的点都加入到新建的树中）。

于是对于这个新建的树 $T'$，要求走到 $T'$ 的每个叶节点，并在 $a_i$ 节点结束。

显然，从根节点到 $a_i$ 的路径上的边只用走一次，其他的边则走两次。所以我们只关心 $T'$ 的边数以及根节点到 $a_i$ 的距离。

根节点到 $a_i$ 的距离即为 $a_i$ 的深度，DFS 遍历即可。而对于 $T'$ 的边数，我们可以 $O(n)$ 构建 $T'$，在构建的过程中统计边数。

具体的构建就是对于每一个 $a_j(1\leq j\leq i)$，不停地向上爬，并标记走过的祖先；遇到已经被标记的祖先就 break. 如此不重不漏，即可 $O(n)$ 构建 $T'$ 并统计边数。

总复杂度 O(nm).

## Subtask3
既然是一条链，则直接统计每个 i 的前缀 max 即为总距离，减去 $a_i$ 到 1 节点的距离即可。

但是在判断是否是链的时候，不仅每个点的度为 2, 还要保证 1 节点的度为 1, 否则不是端点（数据的坑）

## Subtask4
树的深度为 1, 则每新增一个点，距离 +2;

如果 $a_i$ 是 1，那么不用 +2, 但是结果要输出 ans+1（以 1 结尾）.

反正 Sbt3 和 Sbt4 都是乱搞......

## Subtask5
在 Sbt2 的基础上，将建树的总复杂度降至 O(n) 即可，因为对每个 $i$ 建树的结果都可以为 $i+1$ 所用

总复杂度 O(n).

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=(int)1e5,M=(int)1e5;
int n,m,a[M+2];
// 前向星存图
struct qxx{int nex,t;}e[N*2];
int h[N],cnt;
void add_path(int f,int t){e[++cnt]=(qxx){h[f],t};h[f]=cnt;}
// 树结构 - 左儿子右兄弟
struct node{int p,s,b,dp;}t[N+2];
void add_son(int p,int s){t[s].p=p,t[s].b=t[p].s,t[p].s=s;}
//dfs 建树，求深度
bool vis[N+2];
void dfs(int rt,int dp){
	vis[rt]=true,t[rt].dp=dp;
	for(int i=h[rt];i;i=e[i].nex)
		if(!vis[e[i].t]){add_son(rt,e[i].t);dfs(e[i].t,dp+1);}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,a,b;i<n;i++){
		scanf("%d%d",&a,&b);
		add_path(a,b);add_path(b,a);
	}
	for(int i=1;i<=m;i++)scanf("%d",&a[i]);
	dfs(1,1);// 建树，求深度
	memset(vis,0,sizeof(vis));
	int tot=-1;// 边的数量比点的数量少 1
	for(int i=1;i<=m;i++){// 处理每个 i
		for(int k=a[i];!vis[k]&&k;k=t[k].p)tot++,vis[k]=true;// 加边
		printf("%d\n",tot*2-t[a[i]].dp+1);
	}
	return 0;
}
```
