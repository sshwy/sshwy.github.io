---
title: 金华自闭Day1
categories:
  - 比赛
mathjax: true
abbrlink: 55550
date: 2019-02-11 15:06:18
updated: 2019-02-11 15:06:18
tags:
---

# A. 串

## 20pts

$O(n^3)$暴力枚举$i,j,k$.

具体来说，我们先枚举$i,j$，然后按等差数列枚举$k$，check一下统计即可

check失败就break

## 40pts

其他人好像都是前缀和来着。。。

变换一下枚举顺序，先枚举$len=j-i$，即单位串长度

再枚举变换串的起点$i$，然后统计

我们把变换串$s$按单位串的长度分为$t_0t_1\cdots t_x$。

那么我们称$t_i\cdots t_j(i< j)$为$s$的**子变换串**，这个串也满足变换串的性质

因此，枚举了$s$就不用枚举$t_i\cdots t_j$了，我们枚举起点只用枚举$0\sim len-1$，即取遍$len$的剩余系即可。之后的起点都被$0\sim len-1$包括了，那么就不需要统计啦

在统计答案的时候，$t_0t_1\cdots t_x$的贡献显然为$\frac{x(x+1)}{2}$.另外，我们check是检查前后两个串是否至多有一个不同位置，那么在check失败的时候就不用break了，把x清零即可

做这件事情后呢，我们考虑优化check的过程

本来我们需要遍历字符串$O(n)$check，这里考虑一下起点从$i(0\leq i<len)$变化到$i+1$的时候，其实每个字符串只改变了两个位置（开头少一个，结尾多一个），那么我们记录一下相邻两个单位串的不同字符数，就可以做到均摊$O(1)$的check，那么复杂度为$O(n^2)$.

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e5+5;
char s[N];
int ans;
int del[N];
int calc(int a,int b){// unsimilarity
	int tot=0;
	for(int i=0;i<b-a;i++)tot+=(s[i+a]!=s[i+b]);
	return tot;
}
int main(){
	cin>>s;
	int n=strlen(s);
	for(int len=2;len<n;len++){
		for(int i=0;i<len;i++){//起点
			int tot=1;
			for(int k=0;i+k+len+len-1<n;k+=len){
				if(i==0)del[i+k]=calc(i+k,i+k+len);//初始时计算check
				else del[i+k]=del[i+k-1]-(s[i+k-1]!=s[i+k+len-1])+(s[i+k+len-1]!=s[i+k+len+len-1]);//O(1)维护check
				if(del[i+k]<=1)++tot;
				else ans+=tot*(tot-1)/2,tot=1;
			}
			ans+=tot*(tot-1)/2;//累加答案
		}
	}
	cout<<ans;
	return 0;
}

```

## 60pts

杜教：因为20pts**等概率随机**，那么枚举len的时候枚举小一点就行

## 100pts

略解：

若要求绝对相同，这时我们枚举长度，后缀数组来$O(1)$求LCP，LCS，转化为01序列上的1区间的个数，做到$O(\frac{n}{len}log)$的统计，那么总复杂度$O(n\log_2^2n)$.

那么当有一个位置可以不同的时候，在求LCP，LCS的过程中就会遇到失配点

那么我们跳过失配点继续求LCP，LCS，记录区间即可；同样可以转化为01序列上的1区间的个数（把失配点连上），继续统计即可

# B. 树

咕咕。。。

# C. 图

分析这道题首先了解一个概念，线图

## 线图

对于无向图$G=(V,E)$，它的线图 $L(G)$也是一个无向图:

- 它的点集为 $E$，每个点唯一对应着原图的一条边。
- 线图上的两个点之间有边当且仅当这两个点对应的边在原图上有公共点(注意不会有自环)。

如果我们我们把图$G$的点和边都赋上权值。在$L(G)$中，我们可以认为点权为原图中对应边的边权，边权为原图中对应公共点的点权。

上述为线图变换，而由此推出，$L^k(G)$即为$G$经过$k$次变换的图，现在要求求$L^k(G)$的MST.

鉴于$k=0,1,2$，分情况讨论

## k=0

直接MST，kruskal走起

## k=1

这时我们考虑一下一次线图变换的意义。假设原图是这样的

![p1](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/02/11/1914.png)

那么经过线图的变换后会变成这样

![p2](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/02/11/1915.png)

什么意思呢？就是每个顶点会变成对应的团，而边则变成了顶点

在这样的图当中求MST，我们考虑kruskal算法的过程：找到当前未选择的边中最小的边。

注意到我们的$L(G)$中的每一条边都包含在某一个团里面，那么这个团里面的边权又都是相等的（都为$G$中对应顶点的点权），因此对于这个团的顶点，假设顶点数为$k$，如果要在这个团里面选边，那么选的边的数量不会超过$k-1$.因为你选$k-1$条边后这些顶点就都联通了，因此剩下的边没必要考虑。

于是$L(G)$中的每个团只需要考虑$O(n)$数目的边，这个数目与$G$中的顶点数是同级的，因此kruskal的复杂度仍为$O(m\log_2m)$.

## k=2

我们继续考虑两次线图变换的含义

- 对于$L^2(G)$中的点，其本质等价于$L(G)$中的边，等价于$G$中两个具有公共顶点的边
- 对于$L^2(G)$中的边，其本质等价于$L(G)$中两个具有公共顶点的边，而这也等价于$G$中三个连续边链

抽象图示一下，点：

![p3](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/02/11/1934.png)

边：

![p4](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/02/11/1916.png)

也就是说，$L^2(G)$一条边对应$G$中的两个有公共边的v字形结构。并且这个结构也包含了点的线图变换结构，红色和绿色分别对应一个线图的点结构，这两个点结构有公共边。

那么我们考虑一下kruskal算法的过程。之前$k=1$的时候，我们的分析建立在团的连通性上的，相似的逻辑，这次我们把分析建立在边上。那么首先我们要知道，经过线图变换后的边会变成什么

经过一次线图变换后，一条边会变成一个顶点；而再经过一次变换后，这个顶点会变成一个团。也就是说，一条边经过两次线图变换会变成一个团！

那么这个团有怎样的性质呢？易得，这个团的边权是$G$中原边的边权！

那$L^2(G)$的边又是怎么分布的呢？显然，每一条边都在某一个团里面。而又因为某些团是有各自的公共点的，那么只要我们让部分团内部联通，那么就可以使得整个图联通啦（尝试对第2幅图做MST，显然你不用使得每个团内部联通）

既然我们是要求MST，那么点权什么的就可以忽略啦。因此，这个团中的边显然也不用全部枚举，只要使其中的点联通即可。首先，我们要知道$L^2(G)$的顶点数。即求$G$中v字形的个数。这个组合数学算一下即可：
$$
\sum_{u\in V}C_{dgree[u]}^2.
$$
那么我们就连$\sum_{u\in V}C_{dgree[u]}^2-1$条边即可。

同样的，考虑kruskal的算法过程。我们尝试把在$L^2(G)$上的kruskal映射为$G$上的kruskal：

我们从小到达枚举$G$中的边，

- 对于选择的第一条边，它对应$L^2(G)$中的一个团，假设这条边两个端点的**度**分别为$x,y$，那么这个团的顶点数显然为$x+y$。显然**初始时**这个团有$x+y$个联通块，那么我们贪心地连接其中的任意$x+y-1$条边，使其联通成一个整体。这时，这个团显然可以缩点。那么在$L^2(G)$上的缩点对应在$G$上的什么操作呢？——删边！既然这个团缩了点，那么其所有的边都消失了，这个团也消失了（这里的团偏指边集），不就相当于删边吗！因此，我们在原图中把这条边删除（其实就是两个点的度-1）
- 对应之后的边，显然和上述操作一样，根据端点的度来判断连的边数，减少对应的联通块数量，然后在原图上删边即可。直到删去了$\sum_{u\in V}C_{dgree[u]}^2-1$为止.
- 复杂度$O(m\log_2m)$.

