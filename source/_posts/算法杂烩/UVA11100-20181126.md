---
title: '[UVA11100]The Trip'
tags:
 - 贪心
 - 胡搞
 - 题解
categories:
  - 算法杂烩
abbrlink: 4637
date: 2018-11-26 21:32:34
updated: 2018-11-26 21:32:34
---

# 分析

相同大小箱子个数最多的即为答案

然后从大到小依次填充ans个序列即可

# 代码

```cpp
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int N=10006;
int n,a[N],mx,p,dfn;

struct qxx{int nex,t,v;};
qxx e[N*2];
int h[N],cnt;
void add_path(int f,int t,int v){e[++cnt]=(qxx){h[f],t,v},h[f]=cnt;}

int main(){
	while(~scanf("%d",&n)){
		if(!n)return 0;
		for(int i=1;i<=n;i++)scanf("%d",&a[i]);
		sort(a+1,a+n+1);
		mx=0,p=1;//init
		while(p<=n){//找相同最多的盒子的个数
			int cnt=1;
			while(a[p+1]==a[p])++cnt,++p;
			mx=max(mx,cnt),++p;
		}
		dfn=n,cnt=0;
		memset(e,0,sizeof(e));
		memset(h,0,sizeof(h));

		printf("%d\n",mx);
		for(int i=1;i<=n;i++)add_path((i-1)%mx+1,++dfn,a[i]);
		for(int i=1;i<=mx;i++){
			for(int j=h[i];j;j=e[j].nex){
				printf("%d",e[j].v);
				if(e[j].nex)putchar(' ');
			}
			puts("");
		}
		puts("");
	}
	return 0;
}
```

