---
title: 贪心小结
categories:
  - 算法杂烩
mathjax: true
abbrlink: 9827
date: 2018-12-19 19:08:00
updated: 2018-12-19 19:08:00
---

# 小TAG

`观察（贪心思路）` `猜测（减少决策数量）` 

<!--more-->

`证明（从最优解转化为贪心解，并且不改变最优性质，从而证明）`

`多个贪心组合` `贪心与非线性算法` `贪心的单调性` `贪心性质`

# [[CF949A]Zebras](https://codeforces.com/contest/949/problem/A)

定义Zebras为这样的字串：0，010，01010，0101010...

给定一个01串，问能不能把这个01串拆成zebras，要求每个zebras都是01串的**subsequence**。

例如001100=010，010

贪心思路：每次匹配最左边的0或1.

```cpp
#include<bits/stdc++.h>
#define N 200011
using namespace std;

char s[N];
int s0[N],c0,s1[N],c1;
int nex[N],vis[N],k,l[N],st[N];

int main(){
	scanf("%s",s+1);
	for(int i=1;s[i];i++){
		if(s[i]=='0'){
			if(c1)nex[s1[c1]]=i,c1--;
			s0[++c0]=i;
		}
		else {
			if(c0)nex[s0[c0]]=i,c0--;
			else {printf("-1");return 0;}
			s1[++c1]=i;
		}
	}
	if(c1){printf("-1");return 0;}
	for(int i=1;s[i];i++){
		if(!vis[i]){
			++k;int len=0;
			for(int j=i;j;j=nex[j])vis[j]=true,len++;
			l[k]=len,st[k]=i;
		}
	}
	printf("%d\n",k);
	for(int i=1;i<=k;i++){
		printf("%d ",l[i]);
		for(int j=st[i];j;j=nex[j])printf("%d ",j);
		printf("\n");
	}
	return 0;
}
```

# [[CF1003D]Coins and Queries](https://codeforces.com/problemset/problem/1003/D)

有n个硬币，每个硬币的面值都是2的非负整数次幂，面值不超过$10^9$。

有m个询问，给定q，询问可以凑成q的最小硬币数是多少。$n,m\leq 2\times 10^5$.

贪心思路：从大到小减（大的一定是小的的倍数）。

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,q;
int coin[N];//coin[i]:the number of 2^i coin.
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1,a;i<=n;i++){
		scanf("%d",&a);
		int p=0;
		for(int i=1;i<=a;i<<=1,p++);--p;
		coin[p]++;
	}
	for(int i=1,a;i<=q;i++){
		scanf("%d",&a);
		int p=0,s=0,t;
		for(int i=1;i<=a;i<<=1,p++);--p;
		while(p>=0)t=a/(1<<p),t=min(t,coin[p]),s+=t,a-=t*(1<<p),p--;
		if(a!=0)printf("-1\n");
		else printf("%d\n",s);
	}
	return 0;
} 
```

# [CF917A]The Monster

对于每个字符$s_i$开头的子串$O(n)$处理

贪心地把`?`先当做`)`；如果`)`比`(`多了再换成`)`.

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[5010];
int tot;
int main(){
	scanf("%s",s);
	for(int i=0;s[i];i++){//start
		int q=0,cur=0;
		for(int j=i;s[j];j++){
			if(s[j]=='(')cur++;
			else if(s[j]==')')cur--;
			else q++,cur--;//把？当作）
			if(cur<0){
				if(q>0)q--,cur+=2;//为负数，把？换成（
				else break;//没有？可以换了，后面的都不是了
			}
			if(cur==0)tot++;
		}
	}
	printf("%d",tot);
	return 0;
} 
```
# [CF909E]Coprocessor

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int n,m,ans;
int e[N],id[N],F[N],v[N];
vector <int> d[N];
int f(int k){//要完成任务k的最少调用次数（路径上调用co组成的链的最大个数） 
	if(v[k])return F[k];
	else if(e[k]==1){
		F[k]=1;
		for(int i=0;i<d[k].size();i++){
			if(e[d[k][i]]==1)F[k]=max(F[k],f(d[k][i]));
			else F[k]=max(F[k],f(d[k][i])+1);
		}
	}
	else for(int i=0;i<d[k].size();i++)F[k]=max(F[k],f(d[k][i]));
	return v[k]=1,F[k];
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++)scanf("%d",&e[i]);
	for(int i=0,x,y;i<m;i++){
		scanf("%d%d",&x,&y);
		d[y].push_back(x),++id[x];
	}
	for(int i=0;i<n;i++)if(!id[i])ans=max(ans,f(i));
	printf("%d",ans);
	return 0;
}
```
# [CF767E]Change free

先每次都用零钱支付，如果硬币数量变成了负数，就将之前用零钱支付的天中找到代价（dissatisfaction）最小的那天，让那一天用100元支付。

于是你的硬币数会增加100元，而代价相应增加。

用优先队列or堆维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100005;
ll n,m,tot;
ll c[N],w[N],v[N];

struct data{
	ll p,w;
	bool operator<(data tht)const{
		return w>tht.w;
	}
};
priority_queue <data> q;

int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(ll i=1;i<=n;i++)cin>>c[i],v[i]=c[i]/100,c[i]%=100;
	for(ll i=1;i<=n;i++)cin>>w[i],w[i]*=(100-c[i]);
	for(ll i=1;i<=n;i++){
		m-=c[i];
		if(c[i])q.push((data){i,w[i]});
		if(m<0){
			m+=100;
			tot+=q.top().w;
			v[q.top().p]++,c[q.top().p]=0;
			q.pop();
		}
	}
	cout<<tot<<endl;
	for(ll i=1;i<=n;i++){
		cout<<v[i]<<' '<<c[i]<<endl;
	}
	return 0;
}
```
# [CF484A]Bits

贪心，在l上从低位往高位补1，直到超过r就输出。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,l,r;

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>l>>r;
		for(ll cur=1;cur<=r;cur<<=1){
			if((l&cur)==0){
				if(l+cur>r)break;
				else l+=cur;
			}
		}
		printf("%lld\n",l);
	}
	return 0;
}
```
# [HNOI2003]消防局的设立

不要相信洛谷的标签

一道典型的贪心

每次找深度最大的结点，在他的爷爷结点放一个消防站

使用STL优先队列&延迟删除法

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000;
int n,r=1,ans;
struct node{int p,s,b,v;};
node t[N];
void add_son(int p,int s){t[s].p=p,t[s].b=t[p].s,t[p].s=s;}

struct data{
	int idx,dp;//index,deep
	bool operator<(data tht)const{return dp<tht.dp;}
};
priority_queue<data> q;
bool del[N];//延迟删除

void dfs_push(int rt,int dp){
	q.push((data){rt,dp});
	for(int i=t[rt].s;i;i=t[i].b)dfs_push(i,dp+1);
}
void mark(int rt){
	for(int s=t[rt].s;s;s=t[s].b){
		del[s]=true;
		for(int ss=t[s].s;ss;ss=t[ss].b)del[ss]=true;
	}
	for(int s=t[t[rt].p].s;s;s=t[s].b)del[s]=true;
	del[t[rt].p]=del[t[t[rt].p].p]=true;
}
int main(){
	scanf("%d",&n);
	for(int i=2,x;i<=n;i++){
		scanf("%d",&x);
		add_son(x,i);
	}
	while(t[r].p)r=t[r].p;
	dfs_push(r,1);
	while(!q.empty()){
		data now=q.top();q.pop();
		if(del[now.idx])continue;
		if(t[t[now.idx].p].p)mark(t[t[now.idx].p].p);
		else if(t[now.idx].p)mark(t[now.idx].p);
		else mark(now.idx);
		ans++;
	}
	printf("%d",ans);
	return 0;
}
```
