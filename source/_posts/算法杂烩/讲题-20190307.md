---
title: 讲题
mathjax: true
abbrlink: 46704
categories:
  - 算法杂烩
date: 2019-03-07 08:32:24
updated: 2019-03-07 08:32:24
tags:
---

**摘要**


<!--more-->

# Day2T1 无向图

对每种权值判断是否有边（没边就做完了），每次删边判联通

50分直接计算，复杂度$O(n^2)$.

从小到大枚举权值

动态图问题，要求支持加边，删边，问图是否联通

如果只有加边，可以用并查集判断是否联通

发现在时间上，每一条边的存活时间对应两个区间（删比它小的边，删比它大的边）

我们在时间轴上建线段树，区间表示时间，每个结点保存这个时刻删掉的边。叶结点保存这个时刻删除的边的集合（同边权的边一起存在一个叶节点。实际上把边按边权排序后，叶节点也对应一个区间），我们想知道每个时刻（叶节点）图的连通性

每个区间对应线段树上的log个区间

每条边在某个时刻存活

在线段树上DFS时用并查集加边（DFS到的叶子结点是当前删掉的那些边，因此我们要把沿途的兄弟结点包含的边加入到并查集）

删除（回溯）的话，记录加边时并查集（启发式合并）的操作，删除的时候撤销操作（删除变为撤销）

可以发现，每个结点包含的边最多添加/删除一次，而线段树一共有$O(\log_2n)$层，每一层是$O(n)$条边，因此一共有$O(n\log_2n)$次增加/删除操作。每一次操作的复杂度是一个并查集的$O(\log_2n)$.总复杂度$O(n\log_2^2n)$.

# Day2T3 玩游戏

直接DP，复杂度$O(n^2)$.

dp[i,j]=not(dp[i+1,j-i] ans dp[i+1,j+i])

可以用bitset维护DP值

dp[i]=not((dp[i+1]<<i)&(dp[i+1]>>i))

观察发现，DP值的段数很少（平均）

因此我们把不可行区间左移，右移，取并取反即可，归并排序

# Day1T1 智慧树

标算暴力fft转移

考虑点分治+背包，$O(nm)$做背包，加点分治的$O(\log_2n)$，复杂度$O(nm\log_2n)$.

标算

CTSC2010性能优化

# Day1T2 组合数

第一个点lucas定理

第二个点数位DP，一位一位确定

考虑容斥

0-r1,0-r2,0-rn

这样就没有下界了

考虑数位DP

从高位往低位做
