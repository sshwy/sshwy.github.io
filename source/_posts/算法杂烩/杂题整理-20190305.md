---
title: 杂题整理
mathjax: true
categories:
  - 算法杂烩
abbrlink: 63675
date: 2019-03-05 17:44:33
updated: 2019-03-05 17:44:33
tags:
---

**摘要**

主要是 ZROI 的题

<!--more-->

# [ZROI332] 摆花

> 对于一个整数序列和 m 个区间，定义序列的某一**区间**$[l,r]$ 的价值为 $mex(a_i|i\in\{l,\cdots,r\})$（即 sg 函数的 mex）. 而这个序列的价值定义为这 m 个**区间价值**的最小值。
>
> 现在给定 m 个区间和序列长度，求构造一个序列使得价值最大。

显然，整个序列价值的上界为最短区间的长度

那么构造 $a_i=i\bmod len$ 即可。其中 len 为最短区间的长度

# [ZROI333] 打饭

> 给定 k 和 n 个整数 $a_i$，要求安排 $a_i$ 的顺序，最小化
> $$
> \sum_{i=1}^{n-k}|a_i-a_{i+k}|
> $$
> 输出这个最小值。
>
> $n\leq 3\times 10^5,k\leq 5000,a_i\in[-10^9,10^9]$.

可以发现，只有在模 k 的剩余系里相邻的数会产生代价。那么我们将整个序列**按照模 k 的剩余系**分组为 k 个序列，称作**模 k 的剩余序列**。可以证明，对于一个最优的安排方案，分组后其每个模 k 的剩余序列内的数一定是单调的（非严格）。如果不是单调的，就可以交换剩余序列里两个数的位置来使答案更优：

![p1](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/03/05/1856.png)

因此，我们可以将原序列排序。

考虑两个剩余序列中元素的相对关系。对于模 k 余 a 的剩余序列和模 k 余 b 的剩余序列，分别记做 $A,B$. 那么对于 $A_i,A_{i+1}$ 和 $B_j,B_{j+1}$ 而言，这四个数的代价是 $(A_{i+1}-A_i)+(B_{j+1}-B_j)$。显然，当 $A_i\leq A_{i+1}\leq B_j\leq B_{j+1}$ 或者 $B_j\leq B_{j+1}\leq A_i\leq A_{i+1}$ 的时候这四个数的代价最小。否则可以交换它们的位置使得答案更优：

![p2](https://hexo-source-1257756441.cos.ap-chengdu.myqcloud.com/2019/03/05/1917.png)

由此推出，每个剩余序列的元素在原序列里是连续的一段。问题转化为把序列分为 $k$ 段，使得同一段内两相邻数的差的总和最小。不过这 $k$ 段有长度的限制：有 $n\bmod k$ 段的长度为 $\left\lceil\frac{n}{k}\right\rceil$，有 $k-(n\bmod k)$ 段的长度为 $\left\lfloor\frac{n}{k}\right\rfloor$. 因此设计 DP 状态 $f[i,j]$ 表示前面 $i$ 段里有 $j$ 段的长度为 $\left\lceil\frac{n}{k}\right\rceil$，然后就可以转移了

答案即为

$$
\left(\sum_{i=1}^{n-1}a_{i+1}-a_i\right)-f[k,n \bmod k]=a_n-a_1-f[k,n \bmod k]
$$

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=300005,K=5003;
int n,k,ans;
int a[N],f[K][K];

int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	a[0]=a[1];
	// 对于 n 个数，有分 k 组，每组 n/k 个数（有 n%k 个是 n/k+1 个）
	int len=n/k,cnt=n%k;
	//f[i,j] 表示考虑前 i 组，其中有 j 个是大小为 (n/k+1) 的，能放入间隔的最大的数的和
	// 当前的下标 i*len+j
	// 可从 f[i-1,j] 和 f[i-1,j-1] 转移（取最大值）
	for(int i=1;i<=k;i++){int pos=i*len-len;
		f[i][0]=f[i-1][0]+a[pos+1]-a[pos];
		for(int j=1;j<=cnt&&j<=i;j++){
			if(i==j)f[i][j]=f[i-1][j-1]+a[pos+j]-a[pos-1+j];
			else f[i][j]=max(
				f[i-1][j-1]+a[pos+j]-a[pos-1+j],
				f[i-1][j]+a[pos+1+j]-a[pos+j]
			);
		}
	}
	printf("%d",a[n]-a[1]-f[k][cnt]);
	return 0;
}
```

# [ZROI198] 你

> 给出一个 n 个数的序列，为 $A_0,A_1,\cdots,A_{n-1}$，循环移动 $k$ 位之后，这个序列就变成了 $A_k,A_{k+1},\cdots,A_{n-1},A_0,A_1,\cdots,A_{k-1}$。一种优秀的循环移动是，对于任意的前 $i(1\leq i\leq n)$ 项和都满足不小于零。请给出这个序列优秀循环移动的个数。
>
> $n\leq 10^6,A_i\in [-1000,1000]$.

$mnp[i]$ 表示第 $1-i$ 个前缀和中的 $min$，$mns[i]$ 表示第 $i-n$ 个前缀和中的 $min$。

则当把前 k 个数循环移动后的最低前缀和为
$$
\min\{mnp[i]+pre[n]-pre[i],mns[i+1]-pre[i]\}
$$
由此判断正负即可。

```cpp
#include<iostream>
#define min(s1,s2) ((s1)<(s2)?(s1):(s2))
using namespace std;
int n,tot,a[1000001],pre[1000001];
int mnp[1000001],mns[1000001];
int main(){
	cin>>n;
	mnp[0]=mns[n+1]=99999999;
	for(int i=1;i<=n;i++){
		cin>>pre[i];
		pre[i]+=pre[i-1];
	}
	for(int i=1;i<=n;i++)mnp[i]=min(pre[i],mnp[i-1]);
	for(int i=n;i>=1;i--)mns[i]=min(pre[i],mns[i+1]);
	for(int i=1;i<=n;i++){
		if(mnp[i]+pre[n]-pre[i]>=0&&mns[i+1]-pre[i]>=0)tot++;
	}
	cout<<tot;
	return 0;
}
```

# [ZROI224] 移动杠铃

> 在你的面前有两个数轴，摆放和移动杠铃的规则如下：
>
> - 数轴上每个整数坐标处都可以放一个杠铃，一个坐标上最多只能同时放下一个 杠铃。 初始时，两个数轴各自的 $1 \sim n$ 位置上都各放了一个杠铃。
> - 你可以将一个杠铃往左或往右移动一个单位，但需要满足移动到的位置在这之前是空的。这个操作可以对任意多个杠铃进行任意多次，且不耗费力气。
> - 你可以将一个杠铃移动到任意一排的任意一个此前为空的位置（整数坐标处）。这个操 作可以进行多次，每次耗费的力气等于移动的杠铃的质量。
>
> 刚开始架子上摆放着 $n$ 对共 $2n$ 个杠铃，其中每对杠铃拥有相同且唯一的质量，即保证没有 两对杠铃的质量相等。你的目标是进行若干次操作，使得每一对的两个杠铃都被放在了同一排 架子的相邻两个位置上，不需要考虑不同对之间的位置关系。 你需要计算出，在达到目标的前提下，耗费的力气最大的操作最小可以是多少？

架子是无限长的

每个杠铃可进行两种操作：左右微调；跳行

- 第一种操作：相对位置不变，并且保证每个杠铃的左右可以空出空位；不计消耗
- 第二种操作：操作时将更新最大值的答案；不考虑移动次数，因为只要移动了一个，则比其价值小或相等的杠铃都可以移动。

利用第二个操作后，这一对杠铃都可以消失（移动到无限远的地方）
## 二分答案

对于每一个二分答案 mid，可令所有权值比它小的杠铃“消失”，即删除。再考虑剩下的杠铃，是否能两两相邻配对，如果能，降低 mid，否则增加 mid。

## 线段树

考虑两个不在同一架子上的两个杠铃，必然会用到操作二，于是预处理，让它们消失

剩下的都是在同一直线上的杠铃。对于一对杠铃，若中间有其他杠铃间隔，则：要么对这一对杠铃执行操作二，要么对中间的所有杠铃做操作二，于是取两者的最小值，然后让所有做了操作二的杠铃消失。

以此用线段树维护，更新答案，解决问题。

# [ZROI226] 串串

暂时封闭一段时间哦～

{% encrypt gg %}

> 你认为一个字符串是好的当且仅当它由恰好 $m$ 个不同的字符组成。例如当 $m=2$ 时， $abaab$ 就是一个好的字符串，$aaa$ 与 $abaca$ 就不是。
>
> 对 s 的每一个前缀，求它最少能划分成多少个连续的好串，对每个前缀输出段数
>
> $n\leq 2\times 10^5$.

考虑 DP，$f[i]$ 表示第 i 个前缀的最少段数
$$
f[i]=\min_{j=0}^{i-1}\{f[j]+1|\text{ while }s[j+1,i]\text{is a good string}\}.
$$
直接计算，复杂度 $O(n^2)$.

观察到字符串越长，不同字符数越多（单调性）因此合法的转移状态是连续的一段，并且随着 i 自增，这一个状态空间的上下界也是递增的（非严格）。

因此对于每个 i，我们维护合法的转移区间 $[L_i,R_i]$；当 i 增加时更新 $[L_i,R_i]$. 我们维护每个 i 的各个字符的最后出现的位置，就可以在常数时间内更新 $L_i,R_i$，而由于单调性，因此单调队列即可

复杂度 $O(n)$.

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int m,f[N];
struct counter{
	int t[N],cnt;
	void add(int x){cnt+=t[x]==0,t[x]++;}
	void del(int x){t[x]--,cnt-=t[x]==0;}
};// 每个字符的出现次数，出现的不同字符数
counter cl,cr;// 当前最长好串和最短好串的计数器
char s[N];
int q[N],ql,qr;// 单调队列

int main(){
	scanf("%d%s",&m,s+1);
	int l=1,r=1;// 合法的转移状态区间，初始化为 1
	for(int i=1;s[i];i++){
		cl.add(s[i]),cr.add(s[i]);// 第 i 个字符累加次数
		f[i]=-1;// 先初始化为 -1
		if(cl.cnt<m)continue;// 最长的好串的出现次数都达不到，则继续添加字符
		while(cl.cnt>m)cl.del(s[l]),++l;// 直到大于 m 才删除
		while(cr.cnt>=m)cr.del(s[r]),++r;// 只要大于等于 m 就删除
		--r,cr.add(s[r]);// 最后补回来一个，构成最短好串
		//printf("\033[32mi:%d, [%d,%d] \n\033[0m",i,l,r);
		// 因此可转移的区间为 [l-1,r-1]
		while(ql<=qr&&q[ql]<l-1)++ql;// 排除队首过时的决策
		for(int j=q[qr]+1;j<r;j++){// 添加{f[j]}进单调队列
			if(f[j]==-1)continue;// 这个决策不可用
			//printf("[query]add(%d:%d)\n",j,f[j]);
			while(ql<=qr&&f[q[qr]]>=f[j])--qr;
			q[++qr]=j;
		}
		// 最后更新当前的值
		if(ql<=qr)f[i]=f[q[ql]]+1;
		//printf("\033[41mf[%d]:%d\n\033[0m",i,f[i]);
	}
	for(int i=1;s[i];i++)printf("%d\n",f[i]);
	return 0;
}
```

{% endencrypt %}

# [ZROI227] 天天

> 有 n 个长度为 m 的 01 串，定义两个 01 串的距离为他们相同位置上的不同字符数。求一个长度为 m 的 01 串使得它到这 n 个 01 串的距离的最大值最小。输出这个距离
>
> $n\leq 10^5,m\leq 20$.

把距离为 1 的字符串连边，将距离转化为路径。那么我们需要找到一个字符串，使得它到这 n 个字符串的最长的路径最短。那么建立一个虚点连接 n 个字符串，距离为 0，然后跑最短路即可。输出最长的 $dist$ 值，即为目标字符串。

建立虚点的作用是把最短路合并到一起算

# [ZROI228] 摆棋子

> 你有一个 $n\times m$ 的棋盘。 你现在手上有若干个棋子，想要把它们放到棋盘里。不过，你需要保证任意一行任意一列最多只有三个棋子。 现在你想要知道有多少种本质不同的摆放棋子的方案。两种方案本质不同当且仅当一个方 案里某个位置有棋子而另一个方案里没有。
>
> $n,m\leq 64$.

中国象棋的强化版，定义 $f[i,j,k,p]$ 表示前 $i$ 行的棋盘，有 $j$ 列 0 个棋子，$k$ 列 1 个棋子，$p$ 列 2 个棋子，剩下的 $n-j-k-p$ 有 3 列棋子。

~~转移一下就会发现，命都没了~~

可以用小的 DFS 写转移，对当前行放 $0/1/2/3$ 颗棋子的情况，找到三个数 $x,y,z$ 使得 $x+y+z=0/1/2/3$. 这个可以用 DFS 做。转移的时候要乘上系数，因为可以在同棋子数量的列中任选一列放。

# [ZROI325] 自闭的游戏

> 有一个骰子，这个骰子有 $m$ 个面，分别写着 $1\sim m$，并且投掷时每面朝上的概率相同。
>
> 现在，小 S 投了这个骰子 $n$ 次，并且在过程中点数 $v$ 至少出现了一次。现在给出一个正整数 $sum$，表示猜测的这 $n$ 次骰子的点数之和是多少。求这个猜测的正确率（即和为 $sum$ 的概率）
>
> $1\leq n,m\leq 50,1\leq sum\leq n\times m,1\leq v\leq m$.

典型的概率 DP

概率 DP
定义 $f[i,j,1/0]$ 表示丢了 $i$ 次，和为 $j$，$v$ 是否出现的概率。
转移方程如下：
$$
\begin{split}
f[i,j,0]=&\frac{1}{m}\sum_{p=1,p\neq v}^{m}f[i-1,j-p,0]\\
f[i,j,1]=&\frac{1}{m}f[i-1,j-v,0]+\frac{1}{m}\sum_{p=1}^{m}f[i-1,j-p,1]
\end{split}
$$

答案即为

$$
\frac{f[n,sum,1]}{\sum_{j=1}^{mn}f[n,j,1]}
$$

DP 的时候注意上界，$j$ 的上界是 $m\times n$.

# [ZROI232] 小 T 的矩阵

> 小 T 有一个 $n \times n$ 的方阵。 这个方阵的第 $i$ 列从上往下第 $j$ 个数是 $i \bmod j$。我们令第 $i$ 列的 $xor$ 和是 $sum_i$。 现在你想要知道 $sum_1\text{ xor }sum_2\text{ xor }\cdots\text{ xor }sum_n$.
>
> $n\leq 10^6$.

首先知道异或运算的简单性质

1. $a\text{ xor }a=0$.
2. $a\text{ xor }{a+1}=1\text{ (while a is an even number)}$.

把矩阵横排看，第 $j$ 排的模数都是 $j$，即按 $j$ 循环；两个循环节的异或起来是 0. 剩下的用性质 2 组合异或即可

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum,s,n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){//the i-th row
		int p=n/i,q=n%i;
		if(p%2){//q+1~i-1
			int l=q+1,r=i-1;
			if(l%2)sum^=l,l++;
			if(r%2==0)sum^=r,r--;
			sum^=((r-l+1)/2)%2;
		}
		else {//1~q
			sum^=1;
			if(q%2==0)sum^=q,q--;
			sum^=((q-2+1)/2)%2;
		}
	}
	printf("%d",sum);
	return 0;
}
```

复杂度 $O(n)$.

# [ZROI233] 小 T 的算术

> 求
> $$
> \sum_{i=1}^n\sum_{j=1,i\neq j}^m(n\bmod i)(m\bmod j)
> $$
> $n,m\leq 10^9$.

令 $k=min(m,n)$.

$$
\begin{split}
&\sum_{i=1}^n\sum_{j=1,i\neq j}^m(n\bmod i)(m\bmod j)\\

=&\sum_{i=1}^n \left(n-\left\lfloor\frac{n}{i}\right\rfloor i\right)
\sum_{j=1}^m  \left(m-\left\lfloor\frac{m}{j}\right\rfloor j\right)
-\sum_{i=1}^{k}\left(n-\left\lfloor\frac{n}{i}\right\rfloor i\right) \left(m-\left\lfloor\frac{m}{i}\right\rfloor i\right)
\\

=&\left(n^2-\sum_{i=1}^n i\left\lfloor\frac{n}{i}\right\rfloor\right)
\left(m^2-\sum_{j=1}^m j\left\lfloor\frac{m}{j}\right\rfloor\right)-mnk\\
&+\left(m\sum_{i=1}^{k}i\left\lfloor\frac{n}{i}\right\rfloor\right)
+\left(n\sum_{i=1}^{k}i\left\lfloor\frac{m}{i}\right\rfloor\right)
-\left(\sum_{i=1}^{k}\left\lfloor\frac{m}{i}\right\rfloor\left\lfloor\frac{n}{i}\right\rfloor i^2\right)
\end{split}
\\
$$

平方的前缀和用公式处理，向下取整的部分用数论分块
