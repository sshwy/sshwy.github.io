---
title: '[POI2010]GIL-Guilds'
mathjax: true
categories:
  - 算法杂烩
abbrlink: 57867
date: 2019-04-02 20:47:36
updated: 2019-04-02 20:47:36
tags:
  - POI
keywords:
---


**摘要**

之前文化课要准备月考，颓了一会儿 Hexo 博客配置，现在考完了，刷点水题恢复一下


<!--more-->

>  给一张无向图，要求你用黑白灰给点染色，且满足对于任意一个黑点，至少有一个白点和他相邻；对于任意一个白点，至少有一个黑点与他相邻，对于任意一个灰点，至少同时有一个黑点和白点和灰点与他相邻，问能否成功

翻译过来，其实这是一道比较智障的题，直接构造答案. 对该图的生成树直接交替染色即可. 最后要判断是否有孤立点.

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=5e5+5,N=2e5+5;
int n,m;

struct qxx{int nex,t;};
qxx e[M*2];
int h[N],cnt=1;
void add_path(int f,int t){e[++cnt]=(qxx){h[f],t},h[f]=cnt;}
int c[N],iscon[N];
void dfs(int u,int col){c[u]=col+1;
	for(int i=h[u];i;i=e[i].nex){const int v=e[i].t;
		if(c[v])continue;
		dfs(v,!col);
	}
}
int main(){scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add_path(u,v),add_path(v,u);
		iscon[u]=iscon[v]=1;
	}
	for(int i=1;i<=n;i++)if(!iscon[i])return puts("NIE"),0;
	for(int i=1;i<=n;i++)if(!c[i])dfs(i,1);
	puts("TAK");
	for(int i=1;i<=n;i++)puts(c[i]==1?"K":"S");
	return 0;
}
```

