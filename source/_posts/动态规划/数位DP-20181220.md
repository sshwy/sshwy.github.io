---
title: 数位动态规划
categories:
  - 动态规划
tags:
 - 专题
 - DP
mathjax: true
abbrlink: 13990
date: 2018-11-16 15:53:00
updated: 2018-11-16 15:53:00
---
# 简介

数位DP的基本思想就是**按位DP**，对数字的每一位做DP。

数位DP常用于求解区间内满足条件的数的计数问题。其方程通常定义为$f[i,status1,status2...]$，表示从高到低前i位，状态分别为$status1，status2\cdots$时计数的个数。

<!--more-->

考虑到数字大小不超过N，则其中通常有一个状态表示是否到达数位的**上界**。

因为一个数的长度一般≤30，所以数位DP的方程有时会涉及4，5个维度，以满足题目给定的要求；也因此，数位DP的状态转移相对复杂。

区间计数通常使用区间减法，使区间一段固定在0或1的位置，方便计数

# [SCOI2009]windy数-DP累加法

数位DP，定义$f[i,j]$表示长度为$i$，开头数字为$j$的windy数的个数。

$f[i,j]=\sum_{k=0,|k-j|\geq 2}^9f[i-1,k]$

针对两个上界a，b，再分别统计（详见calc()函数）

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
const int NL=15;//数字长度
int f[NL+1][10];
//f[i,j]长度为i，开头数字为j的windy数的个数
void dp_init(){
	for(int i=0;i<=9;i++)f[1][i]=1;
	for(int i=2;i<=NL;i++)
		for(int j=0;j<=9;j++)
			for(int k=0;k<=9;k++)
				if(abs(j-k)>=2)
					f[i][j]+=f[i-1][k];

}
int calc(int k){
	int a[NL+1]={0},cnt=0,res=0;
	while(k)a[++cnt]=k%10,k/=10;
	for(int i=1;i<cnt;i++){//累加所有长度小于k的windy数
		for(int j=1;j<=9;j++)res+=f[i][j];
	}
	for(int i=1;i<a[cnt];i++)res+=f[cnt][i];
		//累加长度等于k，但首位小于k的windy数
	//对于长度为k，开头为a[cnt]的windy数
	for(int i=cnt-1;i>=1;i--){//考虑到第i位
		for(int j=0;j<a[i];j++){//开头为j（未到上界）
			if(abs(a[i+1]-j)>=2)res+=f[i][j];
		}
		if(abs(a[i+1]-a[i])<2)break;
		//对于到达上界的数，如果上界本身不满足年，就break
	}//这个算法不会算到上界本身，所以调用的时候上界要+1
	return res;
}
int main(){
	int p,q;
	dp_init();
	scanf("%d%d",&p,&q);
	printf("%d",calc(q+1)-calc(p));//见calc中注释
	return 0;
}
```