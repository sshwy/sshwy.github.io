---
title: '[HAOI2010] 软件安装'
categories:
  - 动态规划
mathjax: true
abbrlink: 59870
date: 2019-01-16 10:34:35
updated: 2019-01-16 10:34:35
tags:
---

# 题意

有 $N$ 个软件和空间为 $M$ 的硬盘，每个软件有一个占用空间 $W_i$ 和价值 $V_i$ 和一个依赖软件 $D_i$（$D_i=0$ 表示没有依赖）。一个软件要安装，仅当其依赖软件已安装且硬盘空间足够，求最大价值.

$N\leq 100,W_i\leq M\leq 500,V_i\leq 1000,D_i\leq N,D_i\neq i$.

<!--more-->

# 分析

乍一眼树形 DP？

然而这 TM 可能是一个基环树森林

于是 tarjan 缩点，再树形 DP 即可

缩点之后，把森林中的每一棵树的根结点连到 0，方便 DP

$f_k[i,j]$ 以 i 为根的子树在容量为 j 的情况下考虑前 k 个子结点，i 本身取 / 不取的最大价值

设 i 的子结点序列为 $s_1,s_2,\cdots,s_m$.
$$
\begin{split}
f[i,j]=&0(j<W_i)\\
f_k[i,j]=&\max_{p=W_i}^{j}\{f_{k-1}[i,p]+f[s_k,j-p]\}\\
f[i,j]=&f_m[i,j]+V_i
\end{split}
$$
这就是一维 0/1 背包，那么 $j$ 倒序循环即可

目标：$f[0,M]$.

# 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=220,M=510;
int n,m;
int w[N],v[N],d[N];

struct qxx{int nex,t;};
qxx e[N*4];
int h[N],cnt=1;
void add_path(int f,int t){e[++cnt]=(qxx){h[f],t},h[f]=cnt;}

int idx[N],cur;// 缩点后的编号
int dfn[N],low[N],dfncnt;
int s[N],tp,vis[N];
void tarjan(int u){
    dfn[u]=low[u]=++dfncnt,s[++tp]=u,vis[u]=1;
	for(int i=h[u];i;i=e[i].nex){const int &v=e[i].t;
		if(!dfn[v])tarjan(v),low[u]=min(low[u],low[v]);
		else if(vis[v])low[u]=min(low[v],dfn[v]);
	}
	if(low[u]==dfn[u]){
		++cur;
		while(s[tp]!=u)vis[s[tp]]=0,idx[s[tp]]=cur,--tp;
		vis[s[tp]]=0,idx[s[tp]]=cur,--tp;
	}
}
int f[N][M];
void dp(int u){for(int i=h[u];i;i=e[i].nex)dp(e[i].t);
	for(int j=1;j<w[u];j++)f[u][j]=0;
	for(int j=w[u];j<=m;j++)f[u][j]=v[u];
	for(int i=h[u];i;i=e[i].nex){
        const int &v=e[i].t;
		for(int j=m;j>=w[u];j--){
            for(int p=w[u];p<=j;p++)f[u][j]=max(f[u][j],f[u][p]+f[v][j-p]);
		}
	}
}
int ind[N];// 入度
int main(){scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&w[i]);
	for(int i=1;i<=n;i++)scanf("%d",&v[i]);
	for(int i=1;i<=n;i++)scanf("%d",&d[i]),d[i]==0?0:(add_path(d[i],i),0);
	cur=n;// 避免与原图冲突
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
	for(int i=1;i<=n;i++)v[idx[i]]+=v[i],w[idx[i]]+=w[i];
	for(int i=1;i<=n;i++)if(d[i]&&idx[d[i]]!=idx[i])
        add_path(idx[d[i]],idx[i]),ind[idx[i]]++;
	for(int i=1+n;i<=cur;i++)if(!ind[i])add_path(0,i);
	dp(0);
	printf("%d",f[0][m]);
	return 0;
}
```

