---
title: '[LuoguP1273] 有线电视网'
tags:
 - DP
 - 背包
 - 题解
categories:
  - 动态规划
mathjax: true
abbrlink: 12363
date: 2018-11-08 19:30:02
updated: 2018-11-08 19:30:02
---

# 题解

树上背包。定义 $f[i,j]$ 表示在 $subtree(i)$ 中选 $j$ 个用户的最大利润（可能为负）。目标即满足 $f[1,i]\geq 0$ 的最大的 $i$.

对于结点 $u$，将其子结点作为分组，做分组 01 背包。令 $f[u,j]$ 表示遍历前 $k-1$ 个子结点，选 $j$ 个用户的最大利润。则对于当前子结点 $k$，使用

$$
f[u,j]=\max_{p=1}^{user(k)}\left\{f[u,j-p]+f[k,p]-v[k]\right\}
$$
对每个 $f[u,j]$ 更新（其中 $j$ 要倒序循环，$user(k)$ 表示 $subtree(k)$ 中的用户的个数，$v[k]$ 表示 $k$ 到父结点 $u$ 的传输费用）

注意初始化的时候，$f[i,j]=-INF,f[i,0]=0,f[i(i>n-m),1]=money[i]$.

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define FOR(a,b,c) for(int a=b;a<=c;a++)
using namespace std;
const int N=3003;
int n,m;
int p[N],s[N],v[N],b[N],mon[N],f[N][N];
void add_son(int par,int son,int val){p[son]=par,b[son]=s[par],s[par]=son,v[son]=val;
}
int dfs(int u){if(u>n-m)return 1;
	int sz=0,t;// 目前的用户总数；当前子树的用户数
	for(int i=s[u];i;i=b[i]){t=dfs(i),sz+=t,f[i][0]=0;
		for(int j=sz;j>0;j--){//01 背包
			for(int k=1;k<=t;k++){if(k>j)break;// 在当前子树选 k 个用户
				f[u][j]=max(f[u][j],f[u][j-k]+f[i][k]-v[i]);
			}
		}
	}
	return sz;
}
int main(){scanf("%d%d",&n,&m);
	//initialize
	memset(f,~0x3f,sizeof(f));
	FOR(i,1,n)f[i][0]=0;
	//read
	FOR(i,1,n-m){int k,ai,ci;scanf("%d",&k);
		FOR(j,1,k){scanf("%d%d",&ai,&ci);
			add_son(i,ai,ci);
		}
	}
	FOR(i,1,m)scanf("%d",&f[n-m+i][1]);
	dfs(1);
	for(int i=n;i>=0;i--){if(f[1][i]>=0){printf("%d",i);return 0;}
	}
	return 0;
}
```

