---
title: '[IOI1998]Polygon'
categories:
  - 动态规划
tags:
 - 题解
 - DP
abbrlink: 56537
date: 2018-10-02 15:20:00
updated: 2018-10-02 15:20:00
---
倍长环为链

考虑负负得正，定义$f[i,j]$表示合并$[i,j]$的最大值，$g[i,j]$表示合并$[i,j]$后的最小值

按要求转移即可

<!--more-->

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=102;

int n;
int a[N*2],op[N*2];
int f[N*2][N*2];//f[i,j]把[i,j]合并后的最高分数
int g[N*2][N*2];//g[i,j]把[i,j]合并后的最低分数
int ans=0,p[N*2],cnt;

signed main(){
	cin>>n;//scanf("%lld",&n);
	memset(g,0x3f,sizeof(g));
	memset(f,0xc0,sizeof(f));
	for(int i=1;i<=n;i++){
		char opr[5];
		cin>>opr>>a[i];//scanf("%s %lld",opr,&a[i]);
		if(opr[0]=='x')op[i]=1;//0 +;1 *
		a[i+n]=a[i],op[i+n]=op[i];
		f[i][i]=g[i][i]=f[i+n][i+n]=g[i+n][i+n]=a[i];//init
	}
	for(int i=1;i<n;i++){//枚举区间长度
		for(int j=1;j+i<=n*2;j++){//枚举开头
			//[j,j+i]
			for(int k=j+1;k<=j+i;k++){
				if(op[k]==0){
					f[j][j+i]=max(f[j][j+i],f[j][k-1]+f[k][j+i]);
					g[j][j+i]=min(g[j][j+i],g[j][k-1]+g[k][j+i]);
				}
				if(op[k]==1){
					f[j][j+i]=max(f[j][j+i],f[j][k-1]*f[k][j+i]);
					f[j][j+i]=max(f[j][j+i],g[j][k-1]*g[k][j+i]);//负负得正

					g[j][j+i]=min(g[j][j+i],g[j][k-1]*g[k][j+i]);
					g[j][j+i]=min(g[j][j+i],f[j][k-1]*g[k][j+i]);
						//一个超大正数乘一个超大负数等于一个超大负数
					g[j][j+i]=min(g[j][j+i],g[j][k-1]*f[k][j+i]);
						//一个超大正数乘一个超大负数等于一个超大负数
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(f[i][i+n-1]>ans){
			ans=f[i][i+n-1];
			p[cnt=1]=i;
		}
		else if(f[i][i+n-1]==ans)p[++cnt]=i;
	}
	cout<<ans<<endl;
	//printf("%lld\n",ans);
	for(int i=1;i<=cnt;i++)cout<<p[i]<<' ';//printf("%lld ",p[i]);
	return 0;
}
```
