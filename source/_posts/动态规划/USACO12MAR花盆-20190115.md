---
title: '[USACO12MAR] 花盆'
categories:
  - 动态规划
mathjax: true
abbrlink: 52740
date: 2019-01-15 10:08:17
updated: 2019-01-15 10:08:17
tags:
---

# 题意

给定 n 个点 $(x,y)$ 和一个整数 $d$，求一个最小区间 $[l,r]$，使得点集 $\{(x,y),x\in[l,r]\}$ 中的纵坐标的极差 $\geq d$ 最大.

输出区间长度 $r-l$.

$n\leq 10^5,x,y,d\leq 10^6$.

<!--more-->

# 分析

将点按横坐标排序

二分答案，单调队列找最小最大值判断即可

# 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<deque>
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=1e6;
int n,d;
pii a[N];
bool check(int k){deque<pii> qmin,qmax;
	int pos=0,di=0;
	while(pos<n){
		++pos;
		while(qmin.size()&&qmin.front().x+k<a[pos].x)qmin.pop_front();
		while(qmin.size()&&qmin.back().y>=a[pos].y)qmin.pop_back();
		qmin.push_back(a[pos]);
		while(qmax.size()&&qmax.front().x+k<a[pos].x)qmax.pop_front();
		while(qmax.size()&&qmax.back().y<=a[pos].y)qmax.pop_back();
		qmax.push_back(a[pos]);
		di=max(di,qmax.front().y-qmin.front().y);
	}
	return di>=d;
}
int main(){scanf("%d%d",&n,&d);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i].x,&a[i].y);//y,x
	sort(a+1,a+n+1);
	int l=0,r=1000001,mid;
	while(l<r){mid=(l+r)>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	printf("%d",l==1000001?-1:l);
	return 0;
}
```

