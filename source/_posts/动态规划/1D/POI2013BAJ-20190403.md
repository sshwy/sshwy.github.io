---
title: '[POI2013]BAJ-Bytecomputer'
mathjax: true
categories:
  - 动态规划
abbrlink: 11049
date: 2019-04-03 21:07:31
updated: 2019-04-03 21:07:31
tags:
 - POI
keywords:
---


**摘要**

题意：一个序列只有$-1,0,1$，每次可以选一个$i(i>1)$使$a[i]+=a[i-1]$，求操作最少次数使得整个序列非严格单调递增.


<!--more-->

小清新的DP题～

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e6+6;
int n,a[N];
int f[N][3];//f[i,0/1/2]表示把前i个数变单调且最后一个数的状态为-1/0/1的最少次数

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	memset(f,0x3f,sizeof(f));
	f[1][a[1]+1]=0;
	for(int i=2;i<=n;i++){
		if(a[i]==1){
			f[i][0]=f[i-1][0]+2;//拉2次
			f[i][1]=f[i-1][0]+1;//拉1次
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}
		else if(a[i]==0){
			f[i][0]=f[i-1][0]+1;//拉1次
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=f[i-1][2]+1;
		}
		else {
			f[i][0]=f[i-1][0];
			f[i][2]=f[i-1][2]+2;//拉2次
		}
	}
	int ans=min(f[n][0],min(f[n][1],f[n][2]));
	if(ans>=0x3f3f3f3f)puts("BRAK");
	else printf("%d",ans);
	return 0;
}
```

