---
title: '[HAOI2011]Problem A'
categories:
  - 动态规划
mathjax: true
abbrlink: 32240
date: 2019-01-16 07:52:41
updated: 2019-01-16 07:52:41
tags:
---

# 题意

一次考试共有 $n$ 个人参加，第 $i$ 个人说：“有 $a_i$ 个人分数比我高，$b_i$ 个人分数比我低。” 问最少有几个人没有说真话（可能有相同的分数）

$n\leq 10^5,0\leq a_i,b_i\leq n$.

<!--more-->

# 分析

我们可以求最多有多少人说了真话

题目中的 $a_i,b_i$ 可以转化为，成绩按降序排序，第 $i$ 个人处在 $[a_i+1,n-b_i]$ 的区间，这个区间的人的分数与 $i$ 都相同。

那么把 $a_i,b_i$ 处理成区间 $[l,r]$ 后，把相同的区间合并，区间的出现次数为该区间的权值 $v$. 显然有以下条件：

- $l\leq r$.
- $[l,r].v\leq r-l+1$.

不满足第一个条件的就删掉，不满足第二个条件的就把权值赋为 $r-l+1$.（最多有 $r-l+1$ 个人说了真话）

那么问题转化为，有 $k(k\leq n)$ 个区间，每个区间有一个权值 $v$，求不相交区间的最大权值和。

鉴于 $a_i,b_i\leq n \leq 10^5$，直接 $O(n)$DP 即可

$f[i]$ 表示 $[1..i]$ 选取区间的最大权值和
$$
f[i]=\max\left\{\max_{j=1}^{j\leq k,r_j\leq i}\{f[l_j-1]+v_j\},f[i-1]\right\}
$$

# 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e5+5;
int n,n_,tot;
struct data{int l,r,v;};
data a[N];
bool cmp(data x,data y){return x.r==y.r?x.l<y.l:x.r<y.r;}
int f[N];
int main(){scanf("%d",&n);
	n_=n;
	for(int i=1;i<=n_;i++){scanf("%d%d",&a[i].l,&a[i].r),a[i].l++,a[i].r=n-a[i].r;
		if(a[i].l>a[i].r)--i,--n_,++tot;// 条件 1
	}
	sort(a+1,a+1+n_,cmp);
	int cur=0;
	for(int i=1;i<=n_;i++){if(a[i].l==a[i-1].l&&a[i].r==a[i-1].r)++a[cur].v;
		else {a[cur].v=min(a[cur].v,a[cur].r-a[cur].l+1);// 条件 2
			a[++cur]=a[i],a[cur].v=1;
		}
	}
	a[cur].v=min(a[cur].v,a[cur].r-a[cur].l+1);// 条件 2
	int pos=1;
	for(int i=1;i<=n;i++){f[i]=f[i-1];
		while(a[pos].r<=i&&pos<=cur)f[i]=max(f[i],f[a[pos].l-1]+a[pos].v),++pos;
	}
	printf("%d",n_-f[n]+tot);
	return 0;
}
```

​	