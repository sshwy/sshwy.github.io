---
title: 斜率优化 DP 小结
categories:
  - 动态规划
mathjax: true
abbrlink: 62601
top: true
date: 2019-01-15 16:06:17
updated: 2019-04-27 10:55:17
tags:
---

# 前言

本蒟蒻的第一道斜率优化 DP 前后卡了 3 小时...... 海星

有时候好不容易推出一个 DP 的式子，结果发现数据范围太大？

单调队列无法优化？

那就考虑斜率优化吧

<!--more-->

# [APIO2014] 序列分割

你正在玩一个关于长度为 n 的非负整数序列的游戏。这个游戏中你需要把序列分成 k + 1 个非空的块。为了得到 k + 1 块，你需要重复下面的操作 k 次：

- 选择一个元素数多于 1 的块（初始时你只有一块，即整个序列）
- 选择两个相邻元素把这个块从中间分开，得到两个非空的块。
- 每次操作后你将获得那两个新产生的块的元素和的乘积的分数。

最大化最后的总得分。

### 样例

输入

```
7 3
4 1 3 4 0 2 3
```

输出

```
108
1 3 5
```

### 说明

你可以通过下面这些操作获得 108 分：

初始时有一块 $(4, 1, 3, 4, 0, 2, 3)$。在第 1 个元素后面分开，获得 $4 \times (1 + 3 + 4 + 0 + 2 + 3) = 52$ 分。

你现在有两块 $(4), (1, 3, 4, 0, 2, 3)$。在第 3 个元素后面分开，获得 $(1 + 3) \times (4 + 0 + 2 + 3) = 36$ 分。

你现在有三块 $(4), (1, 3), (4, 0, 2, 3)$。在第 5 个元素后面分开，获得 $(4 + 0) \times (2 + 3) = 20$ 分。

所以，经过这些操作后你可以获得四块 $(4),(1,3),(4,0),(2,3)$ 并获得 $52 + 36 + 20 = 108$ 分。

## 小结论

把一个序列分成三段，得分如下：
$$
a(b+c)+bc=ab+(a+b)c
$$
因此发现，得分只与切的位置有关，与切的顺序无关

## DP 方程

既然不关心切的顺序，就把每次切的当做前 $i$ 个中的第一次吧

$f[i,j]$ 表示前 $i$ 个数分 $j$ 次的最大得分：

令 $S_n=\sum_{i=1}^na_i$（前缀和）
$$
f[i,j]=\max_{k=1}^{i-1}\{f[k,j-1]+S_k\times(S_i-S_k)\}
$$
直接转移，复杂度 $O(n^2k)$.

单调队列？然而 $S_k\times S_i$ 就不好处理了

## 解读方程

斜率优化说简单点，就是对付 $S_k\times S_i$ 这种东西的

我们知道，$S_i$ 对当前我们要求的 $f[i,j]$ 来说是一个常量，而 $S_k$ 随决策 $k$ 的变化而变化，是相对的变量

因此，面对常量乘变量这种形式，我们就将其抽象成数学的函数模型

先化一下方程式，我们暂且把 $max$ 去掉：
$$
f[i,j]=f[k,j-1]+S_k\times(S_i-S_k)
$$
观察这个等式：

- $i,j,S_i$ 是**常量**，而 $k,f[k,j-1],S_k$ 是**变量**
- $S_k(S_i-S_k)$ 是**转移的代价**，而 $f[k,j-1]$ 是之前计算的子问题的最优解（**决策值**），$f[i,j]$ 是要求解的问题
- 相比较而言，$f[k,j-1],S_k,S_i$ 是**已知的**（之前就计算好了），而 $f[i,j]$ 是**未知的**（我们正在求啊）

我们对式子进行变形，将未知量，已知量分开，同时将常量与变量分开：
$$
f[i,j]=S_kS_i+(f[k,j-1]-{S_k}^2)
$$
我们来说一些废话......

式子被分成三部分：

- $f[i,j]$：未知量
- $S_kS_i$：变量 $\times$ 常量；已知量
- $(f[k,j-1]-{S_k}^2)$：变量；已知量

**用已知量求解未知量**是显然的思维方式，但我们发现了“变量 $\times$ 常量＋变量”这样的性质，而我们可以这样分析它为：

【未知量 $f[i,j]$】＝【关于 k 的变量 $S_k$】$\times$【常量 $S_i$】＋【关于 k 的另一个变量 $(f[k,j-1]-{S_k}^2)$】.

那么两个变量都和 k 有关，我们可以将其描述为二元组 $(S_k,f[k,j-1]-{S_k}^2)$.

那么这个二元组有什么用呢？

## 抽象出函数模型

我们可以将方程式理解为一个一次函数：
$$
x=S_k,y=(f[k,j-1]-{S_k}^2),m=S_i,b=f[i,j]\\
\Rightarrow b=mx+y\\
\Rightarrow y=-mx+b
$$
看上去很友好对吧

$m$ 是已**知常量**，$x,y$ 是关于 $k$ 的**已知变量**，$b$ 是**未知量**

二元组 $(S_k,f[k,j-1]-{S_k}^2)$ 就变成了决策点 $(x,y)$.

因此我们的问题变成了：

给定 $m$ 和坐标系中若干个点 $(x_i,y_i)$，要求我们最小化 $mx+y$，也就是求最小截距。

## 斜率优化

到上面为止，我们添油加醋地抽象出了一次函数的模型。利用这样一个模型，我们开始斜率优化

### 两个决策之间的关系

我们考虑两个决策点 $P(x,y),Q(x_1,y_1),x<x_1$，如果 $(x,y)$ 比 $(x_1,y_1)$ 更优，那么显然
$$
\begin{split}
mx+y=b>&b_1=mx_1+y_1\\
mx+y>&mx_1+y_1\\
m(x-x_1)>&y_1-y\\
m<&\frac{y_1-y}{x-x_1}\\
-m>&\frac{y-y_1}{x-x_1}\\
\end{split}
$$
可以看出 $\frac{y-y_1}{x-x_1}$ 是直线 PQ 的斜率，记为 $K(P,Q)$。因此我们有这样的引理

**引理 1 ** 对于两个决策点 $P(x,y),Q(x_1,y_1)$，如果 $-m>K(P,Q)$，那么 P 比 Q 更优，反之亦然。

### 决策的单调性

由引理 1，我们可以推导出以下的引理

**引理 2** 对于三个决策点 $P(x,y),Q(x_1,y_1),R(x_2,y_2),x<x_1<x_2$，如果 $K(P,Q)<K(Q,R)$，那么 Q 不可能成为最优决策。

证明：

- 如果 $K(P,Q)<K(Q,R)<-m$，那么 P 优于 Q 优于 R；
- 如果 $K(P,Q)<-m<K(Q,R)$，那么 P 优于 Q，R 优于 Q，最优决策在 P 或者 R 中产生
- 如果 $-m<K(P,Q)<K(Q,R)$，那么 R 优于 Q 优于 P；

$Q.E.D.$

由引理 2，我们考虑从小到大枚举 $x$，维护一个斜率递减的决策二元组序列

### 决策点的环境变化

尽管我们已经想到了维护单调的决策队列，但在这之前我们要确认决策的出现顺序与决策集合的变化

- $i$ 是从 $1$ 枚举到 $n$ 的，这意味着 $-m=-S_i$ 是**单调递减**的
- $k$ 是从 $1$ 枚举到 $i-1$ 的，这意味着 $x=S_k$ 是**单调递增**的
- 随着 $i$ 变成 $i+1$，$k$ 的取值集合从 $[1,i-1]$ 变成了 $[1,i]$，即增加了决策点 $(S_i,f[i,j-1]-{S_i}^2)$.
- 因此，只要我们保证 $j$ 不变，那么上述决策集合可以在均摊 $O(1)$ 的时间内完成转移

### 整体算法

于是，我们将 $j$ 放在最外层循环，在里面维护一个从队首到队尾**斜率递减，横坐标 x 递增**的决策二元组队列。

因为 $x$ 是单增的，意味着我们每次会向队列的末尾添加新的决策点 $(S_i,f[i,j-1]-{S_i}^2)$. 在插入的过程中要根据**引理 2**来维护上凸壳的性质不变。

因为 $-m$ 是单减的，根据**引理 1**，意味着我们每次需要排除队首不满足 $-m>K(P,Q)$ 的决策，然后再用当前队首的决策更新当前的未知量。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int N=1e5+5,K=210;
signed n,k,p[N][K],q[N],l,r;
int s[N],ff[N],gg[N],*f,*g;// 滚存优化

double slope(int a,int b){// 两个决策点的斜率
	return s[a]==s[b]?1e18:(g[a]-s[a]*s[a]-g[b]+s[b]*s[b])*1.0/(s[a]-s[b]);
}
signed main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d",&s[i]),s[i]+=s[i-1];
	f=ff,g=gg;
	for(int j=1;j<=k;j++){
		l=r=1,q[r]=0;
		for(int i=1;i<=n;i++){
			while(l<r&&slope(q[l],q[l+1])>=-s[i])++l;// 队首出队
			f[i]=g[q[l]]+s[q[l]]*(s[i]-s[q[l]]),p[i][j]=q[l];// 记录当前最优解
			while(l<r&&slope(q[r-1],q[r])<=slope(q[r],i))--r;// 维护凸壳
			q[++r]=i;
		}
		swap(f,g);
	}
	printf("%lld\n",g[n]);
	signed cur=p[n][k];
	while(k)printf("%d ",cur),cur=p[cur][--k];// 输出方案
	return 0;
}
```

# [HNOI2008] 玩具装箱

给一个整数序列 $c_1,c_2,\cdots,c_n$ 和整数 $L$，把 $c_l,c_{l+1},\cdots,c_r(l\leq r)$ 放入一个容器的代价为
$$
\left[\left(r-l+\sum_{i=l}^rc_i\right)-L\right]^2
$$
不关心容器的个数，问把所有数放进容器的最小代价。

## 分析

既然不关心个数，那么

设 $f[i]$ 表示放前 i 个数的最小代价

定义 $S_n=\sum_{i=1}^nC_i$.（前缀和）
$$
\begin{split}
f[i]=&\min_{j=1}^i\{f[j-1]+((i-j+S_i-S_{j-1})-L)^2\}\\
f[i]=&\min_{j=1}^i\{f[j-1]+(i+S_i-L-S_{j-1}-j)^2\}\\
\end{split}
$$
那么化一下式子
$$
\begin{split}
f[i]=&f[j-1]+(i+S_i-L-S_{j-1}-j)^2\\
f[i]=&f[j-1]+[(i+S_i-L)-(S_{j-1}+j)]^2\\
f[i]=&f[j-1]+(i+S_i-L)^2+(S_{j-1}+j)^2-2(i+S_i-L)(S_{j-1}+j)\\
\end{split}
$$
抽象一下模型
$$
x=S_{j-1}+j,y=(S_{j-1}+j)^2+f[j-1],m=(i+S_i-L),b=f[i]\\
\Rightarrow b=-2mx+y+m^2
$$
同样的，$m$ 是与 $i$ 和 $L$ 有关的**已知常量**，$x,y$ 是关于 $j$ 的**已知变量**，$b$ 是**未知量**

坐标系的点对应如下：$(S_{j-1}+j,(S_{j-1}+j)^2+f[j-1])\Rightarrow (x,y)$.

那么决策 $x<x_1$，$x$ 优于 $x_1$ 的条件为：
$$
\begin{split}
-2mx+y+m^2<&-2mx_1+y_1+m^2\\
-2mx+y<&-2mx_1+y_1\\
2m<&\frac{y-y_1}{x-x_1}\\
\end{split}.
$$

那么对于 $P(x,y),Q(x_1,y_1),R(x_2,y_2),x<x_1<x_2$，

当 $K(P,Q)>K(Q,R)$，Q 不会成为最优决策。

于是维护一个下凸壳即可

每次增加的决策点是 $j=i$.

## 代码

```cpp
#include<cstdio>
#define int long long
using namespace std;
const int N=5e4+5;
int n,L,s[N],q[N],l,r,f[N];
int sqr(int x){return x*x;}
double slope(int x,int y){
	return (sqr(s[x-1]+x)+f[x-1]-sqr(s[y-1]+y)-f[y-1])*1.0/(s[x-1]+x-s[y-1]-y);
}
signed main(){
	scanf("%lld%lld",&n,&L);
	for(int i=1;i<=n;i++)scanf("%lld",&s[i]),s[i]+=s[i-1];
	l=1,r=0,f[0]=0;
	for(int i=1;i<=n;i++){
		// 添加决策 j=i
		const int m=i+s[i]-L;
		while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i))--r;
		q[++r]=i;
		while(l<r&&slope(q[l],q[l+1])<=2*m)++l;// 排除队首无用决策
		const int j=q[l],x=s[j-1]+j;
		f[i]=-2*m*x+x*x+f[j-1]+m*m;
	}
	printf("%lld",f[n]);
	return 0;
}
```

# [APIO2010] 特别行动队

给三个整数 $a,b,c$ 表示一个函数 $F(x)=ax^2+bx+c$.

给一个整数序列 $x_1,x_2,\cdots,x_n$，并且合并 $x_l,x_{l+1},\cdots,x_r(l\leq r)$ 成一组的代价为 $F\left(\sum_{i=l}^rx_i\right)$.

不考虑组数，问把所有数合并成若干组的最大代价。

## 分析

列式如下
$$
\begin{split}
F(x)=&ax^2+bx+c\\
S_n=&\sum_{i=1}^nx_i \\
f[i]=&\max_{j=0}^i\{f[j]+F(S_i-S_j)\}\\
\end{split}\\
$$

推式子

$$
\begin{split}
f[i]=&f[j]+a(S_i-S_j)^2+b(S_i-S_j)+c\\
=&-2aS_iS_j+(a{S_i}^2+bS_i+c)+(a{S_j}^2-bS_j+f[j])\\
\end{split}\\
$$

抽象模型

$$
\begin{split}
x=&S_j,y=(a{S_j}^2-bS_j+f[j]),\\
T=&(a{S_i}^2+bS_i+c),m=-2aS_i,b=f[i]\\
\Rightarrow b=&mx+y+T\\
\end{split}\\
$$

探求最优条件

$$
\begin{split}
mx+y+T>&mx_1+y_1+T\\
-m>&\frac{y-y_1}{x-x_1}\\
\end{split}
$$

## 代码

这里给出一个斜率优化模板代码，可读性较强，适合初学者使用

```cpp
#include<cstdio>
#define int long long
using namespace std;
const int N=1e6+6;
int n,a,b,c;
int s[N],l,r,q[N],f[N];

int X(int j){return s[j];}
int Y(int j){return a*s[j]*s[j]-b*s[j]+f[j];}
int T(int i){return a*s[i]*s[i]+b*s[i]+c;}
int M(int i){return -2*a*s[i];}

double slope(int x,int y){return (Y(x)-Y(y))*1.0/(X(x)-X(y));}

signed main(){
	scanf("%lld%lld%lld%lld",&n,&a,&b,&c);
	for(int i=1;i<=n;i++)scanf("%lld",&s[i]),s[i]+=s[i-1];
	l=1,r=0;
	for(int i=1;i<=n;i++){
		// 添加决策 i-1.
		while(l<r&&slope(q[r-1],q[r])<=slope(q[r],i-1))--r;
		q[++r]=i-1;
		while(l<r&&slope(q[l],q[l+1])>=-M(i))++l;
		f[i]=M(i)*X(q[l])+Y(q[l])+T(i);//b=mx+y+T
	}
	printf("%lld",f[n]);
	return 0;
}
```

# 总结

回顾三道例题的 DP 方程：
$$
\begin{split}
f[i,j]=&\max_{k=1}^{i-1}\{f[k,j-1]+S_k\times(S_i-S_k)\}\\
f[i]=&\min_{j=1}^i\{f[j-1]+(i+S_i-L-S_{j-1}-j)^2\}\\
f[i]=&\max_{j=0}^i\{f[j]+F(S_i-S_j)\\
\end{split}
$$

最后他们分别被化为了
$$
\begin{split}
f[i,j]=&S_kS_i+(f[k,j-1]-{S_k}^2)\\
f[i]=&-2(i+S_i-L)(S_{j-1}+j)+[(S_{j-1}+j)^2+f[j-1]]+(i+S_i-L)^2\\
f[i]=&-2aS_iS_j+(a{S_j}^2-bS_j+f[j])+(a{S_i}^2+bS_i+c)\\
\end{split}
$$
抽象出的数学模型归纳为
$$
b=mx+y+T
$$
其中 $b$ 是**未知量**，$m,T$ 是**关于已知量的常量**，$x,y$ 是**关于已知量的变量**。那么我们根据题目要求，判断是维护上凸壳（最大值）还是下凸壳（最小值），并更新 DP 值即可。

# 关于非单调的扩展

## 决策点非单调

如果决策点的横坐标 $x$ 不单调，那么如何维护凸壳？

这个时候，有可能会在中间插入一个决策 $P(x,y)$，那么我们在决策点序列上二分，找到两个相邻的点 $A(x_1,y_1),B(x_2,y_2)$，使得 $x_1<x<x_2$，

然后用 $P(x,y)$ 结合引理 2 把 P 两边不需要的决策删掉，维护凸壳性质，再插入 P 决策即可，可采用平衡树维护凸壳序列。

## 门槛斜率非单调

如果斜率 $m$ 非单调呢？

这个时候就需要我们维护整个凸壳，每次找最优解的时候在凸壳上二分，找到一个决策点 $P_i(x,y)$ 使得 $K(P_{i-1},P_i)<m<K(P_i,P_{i+1})$（下凸壳）

或者 $K(P_{i-1},P_i)>m>K(P_i,P_{i+1})$（上凸壳），则决策 $P$ 就是当前未知量的最优决策。

这个过程要加一个 $log$ 的复杂度。
