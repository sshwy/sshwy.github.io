---
title: IOI1999花店橱窗布置
categories:
  - 动态规划
tags:
 - 题解
 - DP
mathjax: true
abbrlink: 4237
date: 2018-10-01 20:22:00
updated: 2018-10-01 20:22:00
---

## 分析

动态规划法，用$f[i,j]$表示用了$i$朵花，摆了$j$个花瓶的最大美学值(不一定要摆第$j$个花瓶)，$m[i,j,k]$表示第i朵花摆第$j-k$个花瓶中最大的一个花瓶的美学值
$$
f[i,j]=\max_{k=i-1}^{j-1}\{f[i-1,k]+m[i,k+1,j]\}
$$
$O(n^3)$处理m数组，$O(n^3)$DP，总复杂度O(n^3).

## 代码

```cpp
#include<iostream>

using namespace std;

int n,v,mx,mxn;
int a[101][101],f[101][101],m[101][101][101];
int pre[101][101];

void sol_print(int ni,int vi){
	if(!pre[ni][vi])return;
	sol_print(ni-1,pre[ni][vi]);
	cout<<pre[ni][vi]<<' ';
}

int main(){
    cin>>n>>v;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=v;j++){
            cin>>a[i][j];
            f[i][j]=0-999999;
        }
    }
    for(int i=1;i<=n&&i<=v;i++)f[i][i]=f[i-1][i-1]+a[i][i];
    for(int i=1;i<=n;i++){
        for(int j=i;j<=v;j++){
            m[i][j][j]=a[i][j];
            for(int k=j+1;k<=v;k++){
                if(m[i][j][k-1]>a[i][k])m[i][j][k]=m[i][j][k-1];
                else m[i][j][k]=a[i][k];
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=i;j<=v;j++){
            for(int k=i-1;k<j;k++){
                if(f[i][j]<f[i-1][k]+m[i][k+1][j]){
                    f[i][j]=f[i-1][k]+m[i][k+1][j];
                    pre[i][j]=k;
                }
            }
        }
    }
    for(int j=1;j<=v;j++)if(f[n][j]>mx)mx=f[n][j],mxn=j;
    cout<<f[n][mxn]<<endl;
    sol_print(n,mxn);
    cout<<mxn;
    return 0;
}
```
