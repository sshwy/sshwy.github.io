---
title: '[ZJOI2005]午餐'
tags:
 - DP
 - 贪心
 - 题解
categories:
  - 动态规划
mathjax: true
abbrlink: 11336
date: 2018-11-18 10:14:10
updated: 2018-11-18 10:14:10
---

# 分析

DP&贪心

首先贪心地想到，让吃饭时间长的先排队（邻项微扰证明）

定义$f[i,j]$表示前i个人，1号窗口打饭总时间为$j$时的最早吃完饭的时间。

- 当第$i$个人在1号窗口时，吃完饭的时间为$max(f[i-1][j-a[i]],j+b[i])$，$f[i-1][j-a[i]]$包含了2号窗口吃完饭的时间，而$j+b[i]$表示第$i$个人吃完饭的时间，两者取最大值。
- 同理，当第$i$个人在2号窗口时，吃完饭时间为$max(f[i-1][j],\sum_{k=1}^ia[k]-j+b[i])$.求和的部分用前缀和优化即可。
- $f[i,j]$初始化INF，$f[0,0]=0$.
- 答案即$\min_{i=0}^{\sum_{j=1}^na[j]}\left\{ f[n,i] \right\}​$.

# 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=203;
int n,f[N][N*N];//前i个人，在1窗口打饭时间为j的最早吃完饭的时间
int ps[N];//pre_sum

struct data{int a,b;};
data d[N];
bool cmp(data x,data y){return x.b>y.b;}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&d[i].a,&d[i].b);
	sort(d+1,d+n+1,cmp);
	for(int i=1;i<=n;i++)ps[i]=ps[i-1]+d[i].a;//前缀和
	memset(f,0x3f,sizeof(f));
	f[0][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=ps[i];j++){
			f[i][j]=max(f[i-1][j],ps[i]-j+d[i].b);//j在2窗
			if(j>=d[i].a)f[i][j]=min(f[i][j],max(f[i-1][j-d[i].a],j+d[i].b));
		}
	}
	int ans=0x3f3f3f3f;
	for(int i=0;i<=ps[n];i++)ans=min(ans,f[n][i]);
	printf("%d",ans);
	return 0;
}
```

