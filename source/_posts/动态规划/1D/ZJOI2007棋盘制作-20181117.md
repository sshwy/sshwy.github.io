---
title: '[ZJOI2007]棋盘制作'
tags:
 - DP
 - 悬线法
categories:
  - 动态规划
mathjax: true
abbrlink: 14225
date: 2018-11-17 23:32:20
updated: 2018-11-17 23:32:20
---

悬线法。以每一个点向上达到的最长的长度作为悬线，左右扫，记录可以到达的最左边的长度以及最右边的长度，再以此更新答案即可。

更具体的，$up[i][j]$表示从$(i,j)$往上最长的黑白相间的格子的高度；

$l[i][j]$表示从$(i,j)$往左最长的黑白相间的格子的长度；

$r[i][j]$表示从$(i,j)$往右最长的黑白相间的格子的长度；

在从上往下遍历每一行的时候，可以用上一行的l,r更新当前行的l,r，并结合up，可以算出当前矩形的长宽，然后更新答案即可。

```cpp
#include<cstdio>
#include<algorithm>
#define FOR(a,b,c) for(int a=b;a<=c;a++)
#define ROF(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
const int N=2003;
int n,m,ans1,ans2;
int qp[N][N],up[N][N],l[N][N],r[N][N];
int main(){
	scanf("%d%d",&n,&m);
	FOR(i,1,n)FOR(j,1,m){
		scanf("%d",&qp[i][j]);
		l[i][j]=j==1?1:(qp[i][j]==qp[i][j-1]?1:l[i][j-1]+1);
	}
	FOR(i,1,n)ROF(j,m,1)r[i][j]=j==m?1:(qp[i][j]==qp[i][j+1]?1:r[i][j+1]+1);
	FOR(i,1,n)FOR(j,1,m){//以up[i][j]为悬线
		if(i==1)up[i][j]=1;
		else {
			if(qp[i-1][j]==qp[i][j])up[i][j]=1;
			else {
				up[i][j]=up[i-1][j]+1;
				l[i][j]=min(l[i][j],l[i-1][j]);
				r[i][j]=min(r[i][j],r[i-1][j]);
			}
		}
		const int w=l[i][j]+r[i][j]-1,h=up[i][j];
		ans1=max(ans1,w*h),ans2=max(ans2,min(w,h)*min(w,h));
	}
	printf("%d\n%d",ans2,ans1);
	return 0;
}
```

