---
title: '[SCOI2010] 股票交易'
categories:
  - 动态规划
mathjax: true
abbrlink: 61952
date: 2019-01-16 20:04:21
updated: 2019-01-16 20:04:21
tags:
---

# 题意

对于一个股市，给出第 $i$ 天买 / 卖股票的价格和买 / 卖股票的数量，依次为 $AP_i,BP_i,AS_i,BS_i$.

并要求手上的股票数不超过 $MaxP$，两次交易的**间隔**时间至少 $W$ 天（买卖都各算一次交易），初始时有无数多的钱和 0 股票，求 $T$ 天后的最大净利润。

$0\leq W \leq T \leq 2000,1\leq MaxP\leq 2000,1\leq BP_i\leq AP_i\leq 1000,1\leq AS_i,BS_i\leq MaxP$.

<!--more-->

# 分析

观察数据范围就知道设 $f[i,j]$ 表示第 i 天，交易后股票数为 j 时的净利润

有 4 种情况的转移

# 从 0 开始买

$$
f[i,j]=-AP_i\times j(j\leq AS_i)
$$

# 不交易

$$
f[i,j]=f[i-1][j]
$$

# 买股票

买入 $j-p$ 股
$$
f[i,j]=\max_{p=max(0,j-AS_i)}^{j-1}\left\{f[i-W-1,p]-(j-p)\times AP_i \right\}
$$

因为有**不交易**的转移，所以不用考虑第一维在 $[1,\cdots,i-w-2]$ 的情况

# 卖股票

卖出 $p-j$ 股
$$
f[i,j]=\max_{p=j+1}^{min(MaxP,j+BS_i)}\left\{f[i-W-1,p]+(p-j)\times BP_i \right\}
$$

# 单调队列

直接转移，复杂度是 $O(T\times MaxP^2)$.

我们化一下转移 3 的方程
$$
f[i,j]=\max_{p=max(0,j-AS_i)}^{j-1}\left\{f[i-W-1,p]+p\times AP_i \right\}-j\times AP_i
$$
那就是单调队列没错了

同理，化一下转移 4 的方程
$$
f[i,j]=\max_{p=j+1}^{min(MaxP,j+BS_i)}\left\{f[i-W-1,p]+p\times BP_i \right\}-j\times BP_i
$$
于是复杂度 $O(T\times MaxP)$.

注意初始化成 $-INF$.

# 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int T=2003,MaxP=2003;
int t,maxp,w;
int ap[T],bp[T],as[T],bs[T];
int f[T][MaxP];

int main(){scanf("%d%d%d",&t,&maxp,&w);
	for(int i=1;i<=t;i++)scanf("%d%d%d%d",&ap[i],&bp[i],&as[i],&bs[i]);
//target: max{f[t][0..maxp]}.
	memset(f,-0x3f,sizeof(f));
	f[0][0]=0;
	for(int i=1;i<=t;i++){int q1[MaxP][2],l1=1,r1=0;
		int q2[MaxP][2],l2=1,r2=0;
		if(i-w-1>=0){// 初始化队列
			//p=[0,-1]=none.#3
			//p=[1,min(maxp,bs[i])].#4
			for(int p=1;p<=min(maxp,bs[i]);p++){int cur=f[i-w-1][p]+p*bp[i];
				while(l2<=r2&&q2[r2][0]<=cur)--r2;
				q2[++r2][0]=cur,q2[r2][1]=p;
			}
		}
		for(int j=0;j<=maxp;j++){if(j<=as[i])f[i][j]=max(f[i][j],-ap[i]*j);//#1
			f[i][j]=max(f[i][j],f[i-1][j]);//#2
			if(i-w-1<0)continue;
			if(l1<=r1)f[i][j]=max(f[i][j],q1[l1][0]-j*ap[i]);//#3
			if(l2<=r2)f[i][j]=max(f[i][j],q2[l2][0]-j*bp[i]);//#4
			// 下面维护单调队列
			//add(j),del(j-as[i]).#3
			int p=j,cur=f[i-w-1][p]+p*ap[i];
			while(l1<=r1&&q1[r1][0]<=cur)--r1;
			q1[++r1][0]=cur,q1[r1][1]=p;
			while(l1<=r1&&q1[l1][1]<=j-as[i])++l1;
			//add(j+1+bs[i]),del(j+1).#4
			if(j+1+bs[i]<=maxp){int p=j+1+bs[i],cur=f[i-w-1][p]+p*bp[i];
				while(l2<=r2&&q2[r2][0]<=cur)--r2;
				q2[++r2][0]=cur,q2[r2][1]=p;
			}
			while(l2<=r2&&q2[l2][1]<=j+1)++l2;
		}
	}
	int ans=-1e9;
	for(int i=0;i<=maxp;i++)ans=max(ans,f[t][i]);
	printf("%d",ans);
	return 0;
}
```
