---
title: '[SCOI2005] 最大子矩阵'
tags:
 - DP
categories:
  - 动态规划
mathjax: true
abbrlink: 52956
date: 2018-12-13 19:11:25
updated: 2018-12-13 19:11:25
---

# 题意

矩形的每一个格子有权值

一个宽 1 或 2 的矩形选出 k 个子矩形，问最大权值和

# 分析

既然宽度只有 2, 状压一下每行状态 DP 即可

定义 $f[i,j,k]$ 表示前 $i$ 行选 $j$ 个子矩形的最大权值. 其中 k:

- k=0 表示第 $i$ 行没有选
- k=1 表示第 $i$ 行选左边的矩形
- k=2 表示第 $i$ 行选右边的矩形
- k=3 表示第 $i$ 行选宽度为 2 的矩形
- k=4 表示第 $i$ 行选两个并排宽度为 1 的矩形

转移即可

m=1 同理, 要更简单一些

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=105,K=12;
int n,m,k;
int a[N][2];

int solve1(){int f[N][K][2];
	memset(f,-0x3f,sizeof(f));
	f[0][0][0]=0;
	for(int i=1;i<=n+1;i++){for(int j=0;j<=k;j++){//f[i][j][0]
			f[i][j][0]=max(f[i][j][0],f[i-1][j][0]);
			f[i][j][0]=max(f[i][j][0],f[i-1][j][1]);
			//f[i][j][1]
			f[i][j][1]=max(f[i][j][1],f[i][j-1][0]);
			f[i][j][1]=max(f[i][j][1],f[i-1][j][1]);
			f[i][j][1]+=a[i][0];
		}
	}
	return f[n+1][k][0];
}
int solve2(){int f[N][K][5];
	memset(f,-0x3f,sizeof(f));
	f[0][0][0]=0;
	for(int i=1;i<=n+1;i++){for(int j=0;j<=k;j++){//f[i][j][0]
			for(int p=0;p<5;p++)f[i][j][0]=max(f[i][j][0],f[i-1][j][p]);
			//f[i][j][1]
			f[i][j][1]=max(f[i][j][1],f[i-1][j][1]);// 和上一行相连
			f[i][j][1]=max(f[i][j][1],f[i-1][j][4]);
			if(j>0)f[i][j][1]=max(f[i][j][1],f[i][j-1][0]);// 独自成一个矩形
			f[i][j][1]+=a[i][0];
			//f[i][j][2]
			f[i][j][2]=max(f[i][j][2],f[i-1][j][2]);
			f[i][j][2]=max(f[i][j][2],f[i-1][j][4]);
			if(j>0)f[i][j][2]=max(f[i][j][2],f[i][j-1][0]);
			f[i][j][2]+=a[i][1];
			//f[i][j][3]，横放 1*2
			f[i][j][3]=max(f[i][j][3],f[i-1][j][3]);
			if(j>0)f[i][j][3]=max(f[i][j][3],f[i][j-1][0]);
			f[i][j][3]+=a[i][0]+a[i][1];
			//f[i][j][4]，并排纵向
			f[i][j][4]=max(f[i][j][4],f[i-1][j][4]);
			if(j>1)f[i][j][4]=max(f[i][j][4],f[i][j-2][0]);// 独自成两个
			if(j>0)f[i][j][4]=max(f[i][j][4],f[i-1][j-1][1]);// 左边连通，右边多一个
			if(j>0)f[i][j][4]=max(f[i][j][4],f[i-1][j-1][2]);// 右边连通，左边多一个
			f[i][j][4]+=a[i][0]+a[i][1];
		}
	}
	return f[n+1][k][0];
}

int main(){scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)for(int j=0;j<m;j++)scanf("%d",&a[i][j]);
	printf("%d",m==1?solve1():solve2());
	return 0;
}
```

