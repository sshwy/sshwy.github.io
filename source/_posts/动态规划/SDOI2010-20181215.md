---
title: '[SDOI2010] 地精部落'
tags:
 - DP
 - 前缀和
categories:
  - 动态规划
mathjax: true
abbrlink: 37415
date: 2018-12-15 20:19:17
updated: 2018-12-15 20:19:17
---

# 题意

问 1-n 的排列中，峰谷交替的排列有多少个，答案对 P 取模。

峰谷交替：即对于一个排列中的任意一个数 $a_i$，满足以下条件之一：

$$
a_{i-1}>a_i<a_{i+1}\\
a_{i-1}<a_i>a_{i+1}
$$

$n\leq 4200,P\leq 10^9$.

# 分析

首先有一个简单 DP，定义 $f[i][j][0/1]$ 表示 $i$ 个数，其中第一个数是从小到达中排第 $j$ 的数，且比第二个数（小 0/ 大 1）时的方案数。
$$
f[i][j][0]=\sum_{k=j}^{i-1}f[i-1][k][1]\\
f[i][j][1]=\sum_{k=1}^{j-1}f[i-1][k][0]
$$
初始化 $f[1][1][0]=f[1][1][1]=1$，目标 $\sum_{i=1}^nf[n][i][0]+f[n][i][1]$.

观察方程，然后前缀和优化即可

定义 $p[i][j][k]=\sum_{p=1}^jf[i][p][k]$.
$$
\begin{split}
&f[i][j][0]=p[i-1][i-1][1]-p[i-1][j-1][1]\\
&f[i][j][1]=p[i-1][j-1][0]\\
&p[i][j][0]=p[i][j-1][0]+f[i][j][0]\\
&p[i][j][1]=p[i][j-1][1]+f[i][j][1]
\end{split}(\bmod P)
$$
然后你的 $f[i][j][k]$ 就不需要了......

初始化 $p[1][1][0]=p[1][1][1]=1$，目标 $p[n][n][0]+p[n][n][1]$.

复杂度 $O(n^2)$.

# 代码

```cpp
#include<cstdio>
using namespace std;
const int N=4205;
int n,P,ans,p[N][N][2];
int main(){scanf("%d%d",&n,&P);
	p[1][1][0]=p[1][1][1]=1;
	for(int i=2;i<=n;i++){
        for(int j=1;j<=i;j++){
            p[i][j][1]=((long long)p[i][j-1][1]+p[i-1][j-1][0])%P;
			p[i][j][0]=((long long)p[i][j-1][0]+p[i-1][i-1][1]-p[i-1][j-1][1])%P;
		}
	}
	ans=(((long long)p[n][n][0]+p[n][n][1])%P+P)%P;
	printf("%d",ans);
	return 0;
}
```

