---
title: DP 小汇
categories:
  - 动态规划
tags:
 - ZROI
 - DP
mathjax: true
abbrlink: 17103
date: 2018-10-05 11:28:01
updated: 2019-06-12 21:42:01
---

# SRM 679 FiringEmployees
> 有一个 n 个点的树, 每个点有点权 (点权可能为负), 求包含点 1 的最大权连通子图 (的权值和)。$n\leq 2500$

入门树形 DP，$f[i]$ 表示以 i 为根的子树 $subtree(i)$ 中包含结点 $i$ 的最大权连通子图。

$f[i]=w_i+\sum_{j\in son(i)}max(f[j],0)$.

# SRM 602 TypoCoderDiv1
> - 某人是一个乐于炸鱼的 OI 选手, 有一天他觉得自己的炸鱼水平还不够高超, 决定去算一个更优的炸鱼方案。
> - 假设某网站的 rating 系统是一个按固定 rating 分级的系统, 即 rating 大于 L 时是 div1 , 否则为 div2。某人一天打了 n 场比赛, 第 i 场的 rating 变化量为 $D_i$ , 即假设打之前的 rating 为 x , 赢了这场 rating 变为 $x + D_i$ , 输了这场 rating 变为 $max(x−D_i,0)$ (以某人的实力当然是想赢就赢想输就输了)
> - 由于某人的目的是炸鱼, 所以**当他打上 div1 以后他需要在下一场比赛立刻跌到 div2** (如果这场比赛不是最后一场的话)。为了表演高超的炸鱼技巧, 某人想最大化他在组别间横跳的次数。求最大的横跳次数。
> - $n\leq 50,L\leq 3000,D_i\leq 10^9$

定义 $f[i,j]$ 表示第 i 场比赛，rating 为 j 时最大横跳次数。

刷表法，通过判断第 i 场比赛是否上线来转移：
- 赢了不上线，则转移到下一场比赛： $f[i-1,max(j-D_{i+1},0)]$ 和 $f[i+1,j+D_{i+1}]$
- 赢了上线，则转移到 $f[i-1,max(j-D_{i+1},0)]$ 和 $f[i+2,j+D_{i+1}-D_{i+2}]$ （如果第二次能下线就转移，否则只转移第一个）

# SRM 698 RepeatString
> 又有坏掉的复读机破坏了队形, 现在复读机群员们要把这个队形修复。现在有一个字符串 $s$ , 你可以进行三种操作:
- 在任意一个位置插入任意字符
- 删除任意一个字符
- 修改任意一个位置的字符

> 求最少的操作次数把 s 重新修改成 aa 的形式 (即一个字符串 a 重复两次)。 $|s| ≤ 100$

考虑将字符串分段匹配，枚举最终 $aa$ 之间的断点， $f[i,j]$ 表示将 $s[1,i]$ 与 $s[i+1,j]$ 编辑成相同字符串的最小代价
$$
f[i,j]=min
\left\{\begin{matrix}
f[i-1,j-1]+1,s_i=s_j \\
min(f[i,j-1],f[i-1,j])+1,s_i\neq s_j
\end{matrix}\right.
$$

# [NOI2007]Cash

读《从 Cash 浅谈一类分治算法的应用》

> 初始时有 S 元人民币，N 天每天三个参数 $a_i,b_i,r_i$. 表示 A 券价格，B 券价格，比例系数。第 i 天可以做这样的操作：
>
> 1. 把 AB 券按比例 x 卖出，$0\leq x\leq 1$，x 是实数。
> 2. 用 x 元购入 AB 券，并要求买入的 AB 券比例为 $r_i$。
> 3. 每天可以进行多次操作。
>
> 问 N 天后最大收入。（可以是小数）**注意这里的简化版题目描述与原题目稍有不同**

把问题抽象一点，设一个三元组 $(S,A,B)$ 分别表示人民币，AB 券的数量。对于第一个操作相当于

$$
(S,A,B)\rightarrow (S+Aa_ix+Bb_ix,A(1-x),B(1-x)),0\leq x\leq 1
$$

买入 AB 券相当于

$$
(S,A,B)\rightarrow \left(S-x,A+\frac{xr_i}{r_ia_i+b_i},B+\frac{x}{r_ia_i+b_i}\right),0\leq x\leq S
$$
显然我们的操作就是通过买卖券来最大化收入。因此贪心地考虑，每天我们一定要么全部卖出，要么全部买入。

设 $f[i],\alpha[i],\beta[i]$ 分别表示第 i 天能获得的最大人民币、A 券、B 券数量（可以在当他兑换）
$$
f[i]=\max_{0\leq j<i}\{a_i\alpha[j]+b_i\beta[j]\}
$$
其中根据贪心策略可以得到
$$
\alpha[i]=\frac{f[i]r_i}{r_ia_i+b_i}\\
\beta[i]=\frac{f[i]}{r_ia_i+b_i}
$$

## 优化 DP

$$
\underline{\beta[j]}_y=\underline{-\frac{a_i}{b_i}}_m\cdot\underline{\alpha[j]}_x+\underline{\frac{f[i]}{b_i}}_b
$$

可以把这个方程写成线性函数形式。而这个方程中 m,x 都非单调（注意 x 是不单调的，因为 $\alpha$ 与 $a_i,b_i,r_i$ 都有关，后三者是不单调的）对于这样的情况，相当于我们需要动态维护凸壳。

## 平衡树维护凸壳

简单说一下平衡树维护凸壳的过程。由于取 MAX，因此维护的是一个上凸壳。以点的横坐标作为键值。每次插入一个点的时侯，判断前驱后继的斜率关系。如果能插入，再分别考虑前驱后继的删除问题。这些可以用 Splay 或者 FHQ 做出来。总复杂度 $O(n\log_2n)$.

## 分治优化 DP

平衡树的做法较复杂，实现起来难度高。DP 相当于是在用之前的决策更新当前的 DP 值。因此考虑这样一个过程：我们要求解 $f[1\sim n]$，那么我们先求出 $f[1\sim mid]$ 的 DP 值，然后来静态更新 $mid+1\sim n$ 的 DP 值。显然这是一个递归的过程。

针对本题，具体地说，我们求 DP 序列，那么就先计算前一半的 DP 值，然后构造前一半的凸壳，并将后一半的按斜率 m 排序。这样就能扫一遍静态更新 DP 值。左右两半递归进行这个过程。求凸壳也需要排序，因此可以递归完成后做归并排序。静态更新的复杂度是线性的，总复杂度就是 $O(n\log_2n)$ 的。这样做的实现难度小，较为适合。
