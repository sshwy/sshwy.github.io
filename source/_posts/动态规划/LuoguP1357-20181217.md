---
title: '[LuoguP1357] 花园'
tags:
 - 矩阵
 - 状压
 - DP
categories:
  - 动态规划
mathjax: true
abbrlink: 62199
date: 2018-12-17 21:24:20
updated: 2018-12-17 21:24:20
---

# 暴力 DP

首先有一个暴力状压 DP,$f[i,j]$ 表示以第 $i$ 个花盆结尾，后 $m$ 个花盆的二进制状态为 $j$（1 为 C,0 为 P）时的方案数

对于环形的处理，我们让两个相同状态作为 DP 的初始和结尾即可．具体的说，初始化 $f[0,x]=1$，表示第 $n-m+1$ 到 $n$ 的花盆的状态为 $x$，目标 $f[n,x]$（n，0 重合）
$$
f[i][j]=\sum_{k=0}^{2^m-1}f[i-1,k](v[k,j]=1)
$$
其中 $v[k,j]=1$ 表示 k 可以转移到 j.

```cpp
#include<cstdio>
#include<cstring>
#define int long long
#define FOR(a,b,c) for(int a=b;a<=c;a++)
using namespace std;
const int N=1e5,M=5,P=1000000007;
int n,m,k,ans;
int f[N][1<<M];
int s[1<<M],cnt;// 可行状态集
bool v[1<<M][1<<M];
void pre_work(){//v[i,j]=1 表示可以从 s[i] 转移到 s[j]
    int m2=(1<<m)-1;
    FOR(i,0,m2)if((i&1)+(i>>1&1)+(i>>2&1)+(i>>3&1)+(i>>4&1)<=k)s[++cnt]=i;
    FOR(i,1,cnt)FOR(j,1,cnt)if((s[i]<<1&m2)==(s[j]&(m2-1)))v[i][j]=1;
}
int calc(int st){
    memset(f,0,sizeof(f));
    f[0][st]=1;
    FOR(i,1,n)FOR(j,1,cnt)FOR(k,1,cnt)
        if(v[k][j])f[i][j]=(f[i][j]+f[i-1][k])%P;
    return f[n][st];
}
signed main(){
    scanf("%lld%lld%lld",&n,&m,&k);
    pre_work();
    FOR(i,1,cnt)(ans+=calc(i))%=P;
    printf("%lld",ans);
    return 0;
}
```

# 矩阵优化

本题 $n\leq 10^{15}$，显然不能直接 DP，则只有矩阵优化. 改写方程
$$
f[i][j]=\sum_{k=0}^{2^m-1}f[i-1,k]\times v[k,j]
$$
忽略第一维 $i$
$$
f[0,j]=\sum_{k=0}^{2^m-1}f[0,k]\times v[k,j]
$$
则把 $f$ 当作 $1\times (2^m-1)$ 的矩阵，$v$ 当作 $(2^m-1)\times(2^m-1)$ 的矩阵，俨然一个矩阵乘法模型

这是一次转移，而一共转移 $n$ 次，于是给 $v$ 来一个矩阵 $n$ 次快速幂;

最后统计答案，按我们之前的思路，每一次初始化 $f[0,x]=1$，转移出来乘上矩阵的结果恰好为为 $v^n[x,x]$，则整体的答案相当于 $v^n$ 的对角线之和

[本题解建立在这篇文章上](http://www.cnblogs.com/ppprseter/p/9254871.html)

# 代码

```cpp
#include<cstdio>
#include<cstring>
#define int long long
#define FOR(a,b,c) for(int a=b;a<=c;a++)
using namespace std;
const int N=1e5,M=5,P=1000000007;
int n,m,k,ans;
int f[N][1<<M],s[1<<M],cnt;// 可行状态集
struct matrix{int c[1<<M][1<<M];};
matrix mt;
matrix operator*(matrix a,matrix b){// 定义矩阵乘法
	matrix c;
	for(int i=1;i<=cnt;i++){
        for(int j=1;j<=cnt;j++){
            c.c[i][j]=0;
			for(int k=1;k<=cnt;k++)(c.c[i][j]+=a.c[i][k]*b.c[k][j])%=P;
		}
	}
	return c;
}
matrix ksm(matrix a,int m){
	matrix res=a;--m;
	while(m){
        if(m&1)res=res*a;
		a=a*a,m>>=1;
	}
	return res;
}
void pre_work(){
    int m2=(1<<m)-1;
	FOR(i,0,m2)if((i&1)+(i>>1&1)+(i>>2&1)+(i>>3&1)+(i>>4&1)<=k)s[++cnt]=i;
	FOR(i,1,cnt)FOR(j,1,cnt)if((s[i]<<1&m2)==(s[j]&(m2-1)))mt.c[i][j]=1;
}
signed main(){
    scanf("%lld%lld%lld",&n,&m,&k);
	pre_work();// 计算 mt 矩阵
	mt=ksm(mt,n);//n 次幂计算
	for(int i=1;i<=cnt;i++)(ans+=mt.c[i][i])%=P;
	printf("%lld",ans);
	return 0;
}
```

