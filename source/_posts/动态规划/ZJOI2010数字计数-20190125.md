---
title: '[ZJOI2010]数字计数'
categories:
  - 动态规划
mathjax: true
abbrlink: 20240
date: 2019-01-25 11:19:37
updated: 2019-01-25 11:19:37
tags:
---

# 题意

给定两个正整数a和b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。

 $a\leq b\leq 10^{12}$.

<!--more-->

# 十元组及其运算

数位统计题的优点在于题面简单，暴力好打

首先我们定义一个十元组结构体$Data$表示$0\sim 9$的出现次数，那么加减运算就顺便可以定义了

```cpp
#define FOR(a,b,c) for(int a=b;a<=c;a++)
using namespace std;
struct data{
	int c[10];
	data(){FOR(i,0,9)c[i]=0;}//构造函数
	data(int cnt){FOR(i,0,9)c[i]=cnt;}
	data operator+(data d){//加法
		FOR(i,0,9)d.c[i]+=c[i];
		return d;
	}
	data operator-(data d){//减法
		data res=*this;
		FOR(i,0,9)res.c[i]-=d.c[i];
		return res;
	}
	void add(int dig,int cnt){c[dig]+=cnt;}//增加某一数码的出现次数
	void print(){FOR(i,0,9)printf("%lld ",c[i]);}//输出
};
```

# 差分统计

那么首先把区间差分一下，考虑$[1,a]$中$1\sim 9$的出现次数

首先定义$f(i,j)$表示以$i$为首位的$j$位数的$0\sim 9$的出现次数（Data）

显然这个可以直接求，因为后$j-1$位不用考虑前导0的问题，每个数码的出现次数都为$(j-1)10^{j-2}$，再加上数码$i$的出现次数$10^{j-1}$就行：

```cpp
const int m10[]={1,10,(int)1e2,(int)1e3,(int)1e4,(int)1e5,(int)1e6,(int)1e7,(int)1e8,(int)1e9,(int)1e10,(int)1e11,(int)1e12};
data f(int i,int j){//首位为i的j位数中每个数码出现的次数
	int t=j>1?(j-1)*m10[j-2]:0;//j=1时特判
	data res(t);
	res.add(i,m10[j-1]);
	return res;
}
```

# 拆分组合

那么结合上面的统计，对于$len$位数$a$，那么按位统计累加即可

没到达位上限就直接用$f$函数累加，到达上限了就把上限数码的次数累加，然后考虑下一位就行

```cpp
#define swap(a,b) (a^=b^=a^=b)
data calc(int n){
	data res;
	int s[20]={0},len=0,sub[20]={0};//后缀数
	while(n)s[++len]=n%10,n/=10;//拆位
	for(int i=1;i<=len;i++)sub[i]=sub[i-1]+s[i]*m10[i-1];
	for(int i=1,j=len;i<j;i++,j--)swap(s[i],s[j]),swap(sub[i],sub[j]);//翻转
	FOR(i,1,9)FOR(j,1,len-1)res=res+f(i,j);//统计1~len-1位数
	FOR(i,1,len){//首位上限为s[i]，位数为len-i+1,对应的sub_num为sub[i+1]
		FOR(k,i==1?1:0,s[i]-1)res=res+f(k,len-i+1);//第一位是特殊情况
		res.add(s[i],sub[i+1]+1);//到达上限
	}
	return res;
}

```

# 主函数

代码的其他部分

当然要开longlong

```cpp
#include<cstdio>
#define int long long 
using namespace std;
int a,b;
signed main(){
	scanf("%lld%lld",&a,&b);
	(calc(b)-calc(a-1)).print();
	return 0;
}
```